/**
 * Code Generation Templates
 * 
 * Centralized templates and constants for code generation
 * Eliminates duplication of common patterns across 90+ files
 */

/**
 * Standard @generated header for generated files
 * Used across all generators (90+ occurrences)
 */
export const GENERATED_HEADER = `// @generated
// This file is automatically generated. Do not edit manually.
`

/**
 * Standard @generated header with timestamp
 */
export function generatedHeaderWithTimestamp(): string {
  return `// @generated at ${new Date().toISOString()}
// This file is automatically generated. Do not edit manually.
`
}

/**
 * Standard import for Prisma client
 */
export const PRISMA_IMPORT = `import prisma from '@/db'`

/**
 * Standard import for Prisma types
 */
export const PRISMA_TYPES_IMPORT = `import type { Prisma } from '@prisma/client'`

/**
 * Standard import for Express types
 */
export const EXPRESS_TYPES_IMPORT = `import type { Request, Response, NextFunction } from 'express'`

/**
 * Standard import for Express Router
 */
export const EXPRESS_ROUTER_IMPORT = `import { Router } from 'express'`

/**
 * Standard imports bundle for service files
 */
export function generateServiceImports(modelName: string, modelLower: string): string {
  return `${GENERATED_HEADER}
${PRISMA_IMPORT}
import type { ${modelName}CreateDTO, ${modelName}UpdateDTO, ${modelName}QueryDTO } from '@/contracts/${modelLower}'
${PRISMA_TYPES_IMPORT}
import { logger } from '@/logger'
import { handleNotFound, handleNotFoundBoolean } from '@/utils/prisma-errors'
`
}

/**
 * Standard imports bundle for controller files
 */
export function generateControllerImports(modelName: string, modelLower: string): string {
  return `${GENERATED_HEADER}
${EXPRESS_TYPES_IMPORT}
import { ${modelLower}Service } from '@/services/${modelLower}'
import { safeErrorMessage } from '@/utils/errors'
import { getPrismaErrorMessage, getPrismaErrorStatusCode } from '@/utils/prisma-errors'
`
}

/**
 * Standard imports bundle for route files
 */
export function generateRouteImports(modelName: string, modelLower: string): string {
  return `${GENERATED_HEADER}
${EXPRESS_ROUTER_IMPORT}
import * as ${modelLower}Controller from '@/controllers/${modelLower}'
import { validate${modelName}Create, validate${modelName}Update, validate${modelName}Query } from '@/validators/${modelLower}'

export const ${modelLower}Router = Router()
`
}

/**
 * Generate file header comment with description
 */
export function fileHeader(description: string, isGenerated = true): string {
  const header = isGenerated ? GENERATED_HEADER : ''
  return `${header}/**
 * ${description}
 */

`
}

/**
 * Generate JSDoc comment for a function
 */
export function jsdocComment(description: string, params?: Record<string, string>, returns?: string): string {
  let doc = `/**
 * ${description}`
  
  if (params && Object.keys(params).length > 0) {
    doc += '\n *'
    for (const [param, desc] of Object.entries(params)) {
      doc += `\n * @param ${param} ${desc}`
    }
  }
  
  if (returns) {
    doc += `\n * @returns ${returns}`
  }
  
  doc += '\n */\n'
  return doc
}

/**
 * Generate export statement for barrel file
 */
export function barrelExport(path: string): string {
  return `export * from './${path}.js'\n`
}

/**
 * Generate barrel file with multiple exports
 */
export function generateBarrelFile(exports: string[], description?: string): string {
  let content = ''
  
  if (description) {
    content += `// ${description}\n\n`
  }
  
  content += exports.map(exp => barrelExport(exp)).join('')
  
  return content
}

/**
 * Generate TypeScript interface
 */
export function generateInterface(name: string, properties: Record<string, string>, exported = true): string {
  const exportKeyword = exported ? 'export ' : ''
  let content = `${exportKeyword}interface ${name} {\n`
  
  for (const [prop, type] of Object.entries(properties)) {
    content += `  ${prop}: ${type}\n`
  }
  
  content += '}\n'
  return content
}

/**
 * Generate TypeScript type alias
 */
export function generateType(name: string, definition: string, exported = true): string {
  const exportKeyword = exported ? 'export ' : ''
  return `${exportKeyword}type ${name} = ${definition}\n`
}

/**
 * Generate const export
 */
export function generateConstExport(name: string, type: string, value: string): string {
  return `export const ${name}: ${type} = ${value}\n`
}

/**
 * Generate async function
 */
export function generateAsyncFunction(
  name: string,
  params: string,
  returnType: string,
  body: string,
  exported = true
): string {
  const exportKeyword = exported ? 'export ' : ''
  return `${exportKeyword}async function ${name}(${params}): Promise<${returnType}> {
${body}
}\n`
}

/**
 * Generate try-catch block with error handling
 */
export function generateTryCatch(tryBody: string, catchBody: string, finallyBody?: string): string {
  let code = `try {
${tryBody}
} catch (error) {
${catchBody}
}`
  
  if (finallyBody) {
    code += ` finally {
${finallyBody}
}`
  }
  
  return code
}

/**
 * Generate standard Prisma query with error handling
 */
export function generatePrismaQueryWithErrorHandling(
  modelLower: string,
  operation: 'findUnique' | 'findMany' | 'create' | 'update' | 'delete',
  params: string
): string {
  return `try {
  return await prisma.${modelLower}.${operation}(${params})
} catch (error) {
  ${operation === 'update' || operation === 'delete' ? 'return handleNotFound(error)' : 'throw error'}
}`
}

/**
 * Generate pagination response structure
 */
export function generatePaginationResponse(dataExpression: string): string {
  return `{
  data: ${dataExpression},
  meta: {
    total,
    skip,
    take,
    hasMore: skip + take < total
  }
}`
}

/**
 * Generate standard logger call
 */
export function generateLoggerCall(
  level: 'info' | 'warn' | 'error',
  context: Record<string, string>,
  message: string
): string {
  const contextStr = Object.entries(context)
    .map(([key, value]) => `${key}: ${value}`)
    .join(', ')
  
  return `logger.${level}({ ${contextStr} }, '${message}')`
}

/**
 * Common code snippets
 */
export const CODE_SNIPPETS = {
  /** Standard ID parsing for controllers */
  parseId: (idType: 'string' | 'number') => 
    idType === 'number' 
      ? 'const id = parseInt(req.params.id, 10)'
      : 'const id = req.params.id',
  
  /** Standard query extraction */
  extractQuery: 'const query = req.query as any',
  
  /** Standard body extraction */
  extractBody: 'const data = req.body',
  
  /** Standard 404 response */
  notFoundResponse: "return res.status(404).json({ error: 'Not found' })",
  
  /** Standard success response */
  successResponse: (data: string) => `return res.json(${data})`,
  
  /** Standard created response */
  createdResponse: (data: string) => `return res.status(201).json(${data})`,
  
  /** Standard error response */
  errorResponse: "return res.status(500).json({ error: safeErrorMessage(error) })",
}

/**
 * Template for Express route handler
 */
export function generateRouteHandler(
  method: 'get' | 'post' | 'put' | 'patch' | 'delete',
  path: string,
  middlewares: string[],
  handlerName: string
): string {
  const middlewareStr = middlewares.length > 0 ? middlewares.join(', ') + ', ' : ''
  return `router.${method}('${path}', ${middlewareStr}${handlerName})`
}

/**
 * Template for validation middleware
 */
export function generateValidationMiddleware(validatorName: string): string {
  return `export function ${validatorName}(req: Request, res: Response, next: NextFunction) {
  try {
    // Validation logic here
    next()
  } catch (error) {
    return res.status(400).json({ error: safeErrorMessage(error) })
  }
}`
}

