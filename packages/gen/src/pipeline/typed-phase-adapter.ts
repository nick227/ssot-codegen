/**
 * Typed Phase Adapter
 * 
 * Bridges between the legacy PhaseContext system and the new strongly-typed system.
 * Allows incremental migration of phases to strong typing without breaking existing code.
 * 
 * @example
 * ```ts
 * // Before (runtime checks):
 * class MyPhase extends GenerationPhase {
 *   async execute(context: PhaseContext) {
 *     if (!context.schema) throw new Error('Schema required')
 *     // ...
 *   }
 * }
 * 
 * // After (compile-time safety):
 * class MyPhase extends TypedPhaseAdapter<ContextAfterPhase1, MyOutput> {
 *   readonly name = 'myPhase'
 *   readonly order = 5
 *   
 *   async executeTyped(context: ContextAfterPhase1): Promise<MyOutput> {
 *     // TypeScript guarantees schema exists!
 *     const { schema } = context
 *     // ...
 *   }
 * }
 * ```
 */

import { GenerationPhase, type PhaseContext, type PhaseResult } from './phase-runner.js'
import type { BaseContext } from './typed-context.js'

/**
 * Adapter that bridges legacy PhaseContext to strongly-typed context
 * 
 * @template TRequires - Strongly-typed context required by the phase
 * @template TProvides - Strongly-typed output provided by the phase
 */
export abstract class TypedPhaseAdapter<
  TRequires extends BaseContext,
  TProvides extends object
> extends GenerationPhase<TProvides> {
  
  /**
   * Execute with legacy PhaseContext (for compatibility)
   * Delegates to executeTyped() with type assertion
   */
  async execute(context: PhaseContext): Promise<PhaseResult<TProvides>> {
    try {
      // Cast to typed context (phases should validate at runtime if needed)
      const typedContext = context as unknown as TRequires
      
      // Call strongly-typed implementation
      const output = await this.executeTyped(typedContext)
      
      // Merge output into context for subsequent phases
      Object.assign(context, output)
      
      return {
        success: true,
        data: output,
        filesGenerated: this.countFiles(output)
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error))
      }
    }
  }
  
  /**
   * Strongly-typed execution method
   * Subclasses implement this instead of execute()
   * 
   * @param context - Strongly-typed context with all required fields
   * @returns Typed output to merge into context
   */
  abstract executeTyped(context: TRequires): Promise<TProvides>
  
  /**
   * Optional: Count files generated by this phase (for logging)
   * Override if phase generates files
   */
  protected countFiles(output: TProvides): number {
    return 0
  }
  
  /**
   * Optional: Check if phase should run
   * Can access typed context safely
   */
  shouldRunTyped?(context: TRequires): boolean
  
  /**
   * Legacy shouldRun implementation (delegates to typed version if available)
   */
  override shouldRun(context: PhaseContext): boolean {
    if (this.shouldRunTyped) {
      return this.shouldRunTyped(context as unknown as TRequires)
    }
    return true
  }
}

/**
 * Helper to validate required context fields at runtime
 * Useful during migration to catch issues early
 * 
 * @example
 * ```ts
 * async executeTyped(context: ContextAfterPhase1): Promise<MyOutput> {
 *   // Runtime validation during migration
 *   validateContext(context, ['schema', 'modelNames'])
 *   
 *   // Now we know fields exist
 *   const { schema, modelNames } = context
 * }
 * ```
 */
export function validateContext<T extends BaseContext>(
  context: T,
  requiredFields: (keyof T)[]
): asserts context is T {
  const missing = requiredFields.filter(field => {
    const value = context[field]
    return value === undefined || value === null
  })
  
  if (missing.length > 0) {
    throw new Error(
      `Phase context missing required fields: ${missing.join(', ')}. ` +
      `This indicates phases are running out of order or a previous phase failed to set required data.`
    )
  }
}

