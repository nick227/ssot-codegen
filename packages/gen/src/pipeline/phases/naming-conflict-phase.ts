/**
 * Naming Conflict Detection Phase
 * Detects filename collisions between models and service annotations
 */

import { toKebabCase } from '../../utils/naming.js'
import {
  ErrorSeverity,
  PhaseStatus,
  type GenerationPhase,
  type PhaseResult,
  type IGenerationContext,
  type GenerationError
} from '../generation-types.js'

/**
 * Detects potential filename conflicts
 * 
 * Responsibilities:
 * - Detect collisions between model-based files and service files
 * - Warn about naming conventions that could cause issues
 * - Suggest alternatives for conflicting names
 * 
 * Example conflict:
 * - Model: UserService → user-service.controller.ts
 * - Service: user-service → user-service.controller.ts
 * Result: Later file overwrites earlier one
 */
export class NamingConflictPhase implements GenerationPhase {
  readonly name = 'naming-conflicts'
  readonly order = 2
  
  shouldExecute(context: IGenerationContext): boolean {
    // Only run if we have service annotations
    return context.cache.getAllServiceAnnotations().length > 0
  }
  
  async execute(context: IGenerationContext): Promise<PhaseResult> {
    const errors: GenerationError[] = []
    const fileNames = new Set<string>()
    const conflicts: Array<{ file: string; sources: string[] }> = []
    
    // Collect all model-based filenames
    for (const model of context.schema.models) {
      const modelKebab = toKebabCase(model.name)
      const files = [
        `${modelKebab}.controller.ts`,
        `${modelKebab}.routes.ts`,
        `${modelKebab}.service.ts`
      ]
      
      for (const file of files) {
        if (fileNames.has(file)) {
          const existing = conflicts.find(c => c.file === file)
          if (existing) {
            existing.sources.push(`model:${model.name}`)
          } else {
            conflicts.push({
              file,
              sources: ['model:<previous>', `model:${model.name}`]
            })
          }
        } else {
          fileNames.add(file)
        }
      }
    }
    
    // Check service annotations for conflicts
    for (const [modelName, annotation] of context.cache.getAllServiceAnnotations()) {
      const serviceFiles = [
        `${annotation.name}.controller.ts`,
        `${annotation.name}.routes.ts`,
        `${annotation.name}.service.scaffold.ts`
      ]
      
      for (const file of serviceFiles) {
        if (fileNames.has(file)) {
          const existing = conflicts.find(c => c.file === file)
          if (existing) {
            existing.sources.push(`service:${annotation.name}`)
          } else {
            conflicts.push({
              file,
              sources: ['<previous>', `service:${annotation.name}`]
            })
          }
        }
      }
    }
    
    // Report conflicts
    if (conflicts.length > 0) {
      for (const conflict of conflicts) {
        errors.push({
          severity: ErrorSeverity.WARNING,
          message: `Filename conflict: ${conflict.file} would be generated by: ${conflict.sources.join(', ')}`,
          phase: this.name
        })
      }
      
      console.warn(
        `[ssot-codegen] Found ${conflicts.length} potential naming conflict(s). ` +
        `Consider renaming models or services to avoid overwrites.`
      )
    }
    
    return {
      success: true,  // Conflicts are warnings, not failures
      status: PhaseStatus.COMPLETED,
      errors
    }
  }
}

