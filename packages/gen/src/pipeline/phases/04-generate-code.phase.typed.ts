/**
 * Phase 4: Generate Code (Strongly-Typed)
 * 
 * Generates all code files (DTOs, validators, services, controllers, routes, SDK, plugins).
 * 
 * MIGRATION STATUS: âœ… Migrated to typed context
 */

import path from 'node:path'
import { generateCode, countGeneratedFiles } from '../../code-generator.js'
import { analyzeModel } from '@/utils/relationship-analyzer.js'
import { TypedPhaseAdapter } from '../typed-phase-adapter.js'
import { defaultPaths } from '../../config/default-paths.js'
import type { 
  ContextAfterPhase3, 
  GenerateCodeOutput 
} from '../typed-context.js'

export class GenerateCodePhaseTyped extends TypedPhaseAdapter<
  ContextAfterPhase3,      // Requires: Phase 0-3 outputs
  GenerateCodeOutput       // Provides: pathsConfig, generatedFiles, totalFiles, breakdown
> {
  readonly name = 'generateCode'
  readonly order = 4
  
  getDescription(): string {
    return 'Generating code'
  }
  
  /**
   * Strongly-typed execution
   * 
   * TypeScript guarantees:
   * - context.schema exists (from Phase 1)
   * - context.outputDir exists (from Phase 0)
   * - context.config exists (from BaseContext)
   * - context.logger exists (from BaseContext)
   * - context.modelNames exists (from Phase 1)
   * 
   * NO RUNTIME CHECKS NEEDED!
   */
  async executeTyped(context: ContextAfterPhase3): Promise<GenerateCodeOutput> {
    const { schema, config, logger, outputDir, modelNames } = context
    
    // Setup output directory and config
    const srcDir = path.join(outputDir, 'src')
    const cfg = { ...defaultPaths, ...config.paths, rootDir: srcDir }
    const framework = config.framework || 'express'
    const useRegistry = process.env.USE_REGISTRY === 'true'
    
    // Generate all code
    const generatedFiles = await generateCode(schema, { 
      framework,
      useEnhancedGenerators: !useRegistry,
      useRegistry,
      projectName: config.projectName || path.basename(outputDir),
      
      // Feature plugins
      features: {
        googleAuth: process.env.ENABLE_GOOGLE_AUTH === 'true' ? {
          enabled: true,
          clientId: process.env.GOOGLE_CLIENT_ID,
          clientSecret: process.env.GOOGLE_CLIENT_SECRET,
          callbackURL: process.env.GOOGLE_CALLBACK_URL,
          strategy: (process.env.AUTH_STRATEGY as 'jwt' | 'session') || 'jwt',
          userModel: process.env.AUTH_USER_MODEL || 'User'
        } : undefined
      }
    })
    
    // Log per-model progress
    for (const model of schema.models) {
      logger.startModel(model.name)
      
      // Detect junction tables using centralized utility
      const analysis = analyzeModel(model, schema)
      if (analysis.isJunctionTable) {
        logger.logJunctionTable(model.name)
      }
      
      // Count files for this model
      let modelFiles = 0
      const modelLower = model.name.toLowerCase()
      
      if (generatedFiles.contracts.has(model.name)) {
        modelFiles += generatedFiles.contracts.get(model.name)!.size
      }
      if (generatedFiles.validators.has(model.name)) {
        modelFiles += generatedFiles.validators.get(model.name)!.size
      }
      if (generatedFiles.services.has(`${modelLower}.service.ts`)) {
        modelFiles++
      }
      if (generatedFiles.controllers.has(`${modelLower}.controller.ts`)) {
        modelFiles++
      }
      if (generatedFiles.routes.has(`${modelLower}.routes.ts`)) {
        modelFiles++
      }
      
      logger.completeModel(model.name, modelFiles)
    }
    
    const totalFiles = countGeneratedFiles(generatedFiles)
    
    // Calculate breakdown by layer
    const breakdown = [
      { layer: 'contracts', count: Array.from(generatedFiles.contracts.values()).reduce((sum, m) => sum + m.size, 0) },
      { layer: 'validators', count: Array.from(generatedFiles.validators.values()).reduce((sum, m) => sum + m.size, 0) },
      { layer: 'services', count: generatedFiles.services.size },
      { layer: 'controllers', count: generatedFiles.controllers.size },
      { layer: 'routes', count: generatedFiles.routes.size }
    ]
    
    // Return strongly-typed output
    return {
      pathsConfig: cfg,
      generatedFiles,
      totalFiles,
      breakdown
    }
  }
  
  /**
   * Count files generated by this phase
   */
  protected override countFiles(output: GenerateCodeOutput): number {
    return output.totalFiles
  }
}

