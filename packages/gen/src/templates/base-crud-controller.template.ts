/**
 * Base CRUD Controller Template
 * Generated once per project to eliminate controller boilerplate
 */

export function getBaseCRUDControllerTemplate(): string {
  return `// @generated
// This file is automatically generated. Do not edit manually.

import type { Request, Response } from 'express'
import { ZodError, type ZodSchema } from 'zod'
import { logger } from '@/logger'

/**
 * Generic CRUD service interface
 */
export interface CRUDService<T, CreateDTO, UpdateDTO, QueryDTO> {
  list(query: QueryDTO): Promise<{ data: T[]; meta: any }>
  findById(id: number | string): Promise<T | null>
  create(data: CreateDTO): Promise<T>
  update(id: number | string, data: UpdateDTO): Promise<T | null>
  delete(id: number | string): Promise<boolean>
  count(where?: any): Promise<number>
}

/**
 * Validation schemas for CRUD operations
 */
export interface CRUDSchemas<CreateDTO, UpdateDTO, QueryDTO> {
  create: ZodSchema<CreateDTO>
  update: ZodSchema<UpdateDTO>
  query: ZodSchema<QueryDTO>
}

/**
 * Controller configuration
 */
export interface CRUDControllerConfig {
  modelName: string
  idType: 'number' | 'string'
  idField?: string
}

/**
 * Base CRUD Controller
 * 
 * Eliminates 80-85% of boilerplate from generated controllers by providing
 * common functionality: validation, error handling, logging, ID parsing, etc.
 * 
 * @example
 * \`\`\`typescript
 * const postCRUD = new BaseCRUDController(
 *   postService,
 *   { create: PostCreateSchema, update: PostUpdateSchema, query: PostQuerySchema },
 *   { modelName: 'Post', idType: 'number' }
 * )
 * 
 * export const listPosts = postCRUD.list
 * export const getPost = postCRUD.getById
 * \`\`\`
 */
export class BaseCRUDController<T, CreateDTO, UpdateDTO, QueryDTO> {
  constructor(
    private service: CRUDService<T, CreateDTO, UpdateDTO, QueryDTO>,
    private schemas: CRUDSchemas<CreateDTO, UpdateDTO, QueryDTO>,
    private config: CRUDControllerConfig
  ) {}

  /**
   * Parse and validate ID from request params
   */
  private parseId(req: Request, res: Response): number | string | null {
    const idField = this.config.idField || 'id'
    const rawId = req.params[idField]
    
    if (this.config.idType === 'number') {
      const id = parseInt(rawId, 10)
      if (isNaN(id)) {
        logger.warn({ id: rawId }, \`Invalid \${this.config.modelName} ID format\`)
        res.status(400).json({ error: 'Invalid ID format' })
        return null
      }
      return id
    }
    
    // String ID (UUID, CUID, etc.)
    if (!rawId || rawId.trim() === '') {
      logger.warn(\`Missing \${this.config.modelName} ID\`)
      res.status(400).json({ error: 'ID is required' })
      return null
    }
    
    return rawId
  }

  /**
   * Handle validation errors
   */
  private handleValidationError(error: ZodError, operation: string, res: Response): void {
    logger.warn(
      { error: error.errors, operation },
      \`Validation error in \${operation}\`
    )
    res.status(400).json({
      error: 'Validation Error',
      details: error.errors
    })
  }

  /**
   * Handle general errors
   */
  private handleError(error: unknown, operation: string, context: Record<string, any>, res: Response): void {
    logger.error(
      { error, ...context, operation },
      \`Error in \${operation}\`
    )
    res.status(500).json({ error: 'Internal Server Error' })
  }

  /**
   * List all records with pagination
   */
  list = async (req: Request, res: Response): Promise<Response> => {
    try {
      const query = this.schemas.query.parse(req.query)
      const result = await this.service.list(query)
      return res.json(result)
    } catch (error) {
      if (error instanceof ZodError) {
        this.handleValidationError(error, \`list\${this.config.modelName}s\`, res)
        return res
      }
      this.handleError(error, \`list\${this.config.modelName}s\`, {}, res)
      return res
    }
  }

  /**
   * Get single record by ID
   */
  getById = async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const id = this.parseId(req, res)
      if (id === null) return  // Response already sent
      
      const item = await this.service.findById(id)
      
      if (!item) {
        const idKey = \`\${this.config.modelName.toLowerCase()}Id\`
        logger.debug({ [idKey]: id }, \`\${this.config.modelName} not found\`)
        return res.status(404).json({ error: \`\${this.config.modelName} not found\` })
      }
      
      return res.json(item)
    } catch (error) {
      this.handleError(error, \`get\${this.config.modelName}\`, { id: req.params.id || req.params[this.config.idField || 'id'] }, res)
      return res
    }
  }

  /**
   * Create new record
   */
  create = async (req: Request, res: Response): Promise<Response> => {
    try {
      const data = this.schemas.create.parse(req.body)
      const item = await this.service.create(data)
      return res.status(201).json(item)
    } catch (error) {
      if (error instanceof ZodError) {
        this.handleValidationError(error, \`create\${this.config.modelName}\`, res)
        return res
      }
      this.handleError(error, \`create\${this.config.modelName}\`, {}, res)
      return res
    }
  }

  /**
   * Update existing record
   */
  update = async (req: Request, res: Response): Promise<Response | void> => {
    try {
      const id = this.parseId(req, res)
      if (id === null) return  // Response already sent
      
      const data = this.schemas.update.parse(req.body)
      const item = await this.service.update(id, data)
      
      if (!item) {
        const idKey = \`\${this.config.modelName.toLowerCase()}Id\`
        logger.debug({ [idKey]: id }, \`\${this.config.modelName} not found for update\`)
        return res.status(404).json({ error: \`\${this.config.modelName} not found\` })
      }
      
      return res.json(item)
    } catch (error) {
      if (error instanceof ZodError) {
        this.handleValidationError(error, \`update\${this.config.modelName}\`, res)
        return res
      }
      this.handleError(error, \`update\${this.config.modelName}\`, { id: req.params.id || req.params[this.config.idField || 'id'] }, res)
      return res
    }
  }

  /**
   * Delete record
   */
  delete = async (req: Request, res: Response): Promise<Response | void> {
    try {
      const id = this.parseId(req, res)
      if (id === null) return  // Response already sent
      
      const deleted = await this.service.delete(id)
      
      if (!deleted) {
        const idKey = \`\${this.config.modelName.toLowerCase()}Id\`
        logger.debug({ [idKey]: id }, \`\${this.config.modelName} not found for delete\`)
        return res.status(404).json({ error: \`\${this.config.modelName} not found\` })
      }
      
      return res.status(204).send()
    } catch (error) {
      this.handleError(error, \`delete\${this.config.modelName}\`, { id: req.params.id || req.params[this.config.idField || 'id'] }, res)
      return res
    }
  }

  /**
   * Count records
   */
  count = async (_req: Request, res: Response): Promise<Response> => {
    try {
      const total = await this.service.count()
      return res.json({ total })
    } catch (error) {
      this.handleError(error, \`count\${this.config.modelName}s\`, {}, res)
      return res
    }
  }
}

/**
 * Create controller for domain method that returns data
 * 
 * @example
 * \`\`\`typescript
 * export const getPostBySlug = createDomainMethodController(
 *   postService.findBySlug,
 *   { modelName: 'Post', methodName: 'getPostBySlug', idType: 'string', paramName: 'slug' }
 * )
 * \`\`\`
 */
export function createDomainMethodController<T>(
  serviceFn: (...args: any[]) => Promise<T | null>,
  config: {
    modelName: string
    methodName: string
    idType?: 'number' | 'string'
    paramName?: string
    parseParams?: (req: Request) => any[]
  }
) {
  return async (req: Request, res: Response): Promise<Response | void> => {
    try {
      let args: any[]
      
      if (config.parseParams) {
        args = config.parseParams(req)
      } else {
        const paramName = config.paramName || 'id'
        const rawValue = req.params[paramName]
        
        if (config.idType === 'number') {
          const numValue = parseInt(rawValue, 10)
          if (isNaN(numValue)) {
            logger.warn({ [paramName]: rawValue }, 'Invalid parameter format')
            return res.status(400).json({ error: 'Invalid parameter format' })
          }
          args = [numValue]
        } else {
          if (!rawValue || rawValue.trim() === '') {
            logger.warn(\`Missing \${paramName} parameter\`)
            return res.status(400).json({ error: \`\${paramName} parameter is required\` })
          }
          args = [rawValue]
        }
      }
      
      const item = await serviceFn(...args)
      
      if (!item) {
        const idKey = \`\${config.modelName.toLowerCase()}Id\`
        logger.debug({ [idKey]: args[0] }, \`\${config.modelName} not found\`)
        return res.status(404).json({ error: \`\${config.modelName} not found\` })
      }
      
      return res.json(item)
    } catch (error) {
      logger.error({ error, method: config.methodName }, \`Error in \${config.methodName}\`)
      return res.status(500).json({ error: 'Internal Server Error' })
    }
  }
}

/**
 * Create controller for domain method that returns void or doesn't need response data
 * 
 * @example
 * \`\`\`typescript
 * export const incrementPostViews = createVoidDomainMethodController(
 *   postService.incrementViews,
 *   { modelName: 'Post', methodName: 'incrementPostViews', idType: 'number' }
 * )
 * \`\`\`
 */
export function createVoidDomainMethodController(
  serviceFn: (...args: any[]) => Promise<void | any>,
  config: {
    modelName: string
    methodName: string
    idType?: 'number' | 'string'
    paramName?: string
    parseParams?: (req: Request) => any[]
  }
) {
  return async (req: Request, res: Response): Promise<Response | void> => {
    try {
      let args: any[]
      
      if (config.parseParams) {
        args = config.parseParams(req)
      } else {
        const paramName = config.paramName || 'id'
        const rawValue = req.params[paramName]
        
        if (config.idType === 'number') {
          const numValue = parseInt(rawValue, 10)
          if (isNaN(numValue)) {
            logger.warn({ [paramName]: rawValue }, 'Invalid parameter format')
            return res.status(400).json({ error: 'Invalid parameter format' })
          }
          args = [numValue]
        } else {
          if (!rawValue || rawValue.trim() === '') {
            logger.warn(\`Missing \${paramName} parameter\`)
            return res.status(400).json({ error: \`\${paramName} parameter is required\` })
          }
          args = [rawValue]
        }
      }
      
      await serviceFn(...args)
      return res.status(204).send()
    } catch (error) {
      logger.error({ error, method: config.methodName }, \`Error in \${config.methodName}\`)
      return res.status(500).json({ error: 'Internal Server Error' })
    }
  }
}

/**
 * Create controller for list method with custom service function
 * 
 * @example
 * \`\`\`typescript
 * export const listPublishedPosts = createListMethodController(
 *   postService.listPublished,
 *   PostQuerySchema,
 *   { modelName: 'Post', methodName: 'listPublishedPosts' }
 * )
 * \`\`\`
 */
export function createListMethodController<QueryDTO>(
  serviceFn: (query: QueryDTO) => Promise<{ data: any[]; meta: any }>,
  querySchema: ZodSchema<QueryDTO>,
  config: { modelName: string; methodName: string }
) {
  return async (req: Request, res: Response): Promise<Response> => {
    try {
      const query = querySchema.parse(req.query)
      const result = await serviceFn(query)
      return res.json(result)
    } catch (error) {
      if (error instanceof ZodError) {
        logger.warn({ error: error.errors }, \`Validation error in \${config.methodName}\`)
        return res.status(400).json({
          error: 'Validation Error',
          details: error.errors
        })
      }
      logger.error({ error }, \`Error in \${config.methodName}\`)
      return res.status(500).json({ error: 'Internal Server Error' })
    }
  }
}
`
}

// Export as constant for backwards compatibility
export const baseCRUDControllerTemplate = getBaseCRUDControllerTemplate()

