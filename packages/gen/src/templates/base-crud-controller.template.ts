/**
 * Base CRUD Controller Template
 * Generated once per project to eliminate controller boilerplate
 */

export function getBaseCRUDControllerTemplate(): string {
  return `// @generated
// This file is automatically generated. Do not edit manually.

import type { Request, Response } from 'express'
import { ZodError, type ZodSchema, z } from 'zod'
import { logger } from '@/logger'

/**
 * Generic CRUD service interface
 * 
 * Note: T may include relations (e.g., { user: {...}, ... }), so we use a flexible type
 */
export interface CRUDService<T, CreateDTO, UpdateDTO, QueryDTO> {
  list(query: QueryDTO): Promise<{ data: T[]; meta: any }>
  findById(id: number | string): Promise<T | null>
  create(data: CreateDTO): Promise<T>
  update(id: number | string, data: UpdateDTO): Promise<T | null>
  delete(id: number | string): Promise<boolean>
  count(where?: any): Promise<number>
  createMany?(data: CreateDTO[]): Promise<{ count: number } | any>
  updateMany?(where: any, data: UpdateDTO): Promise<{ count: number } | any>
  deleteMany?(where: any): Promise<{ count: number } | any>
  search?(params: any): Promise<T[]>
  findBySlug?(slug: string): Promise<T | null>
  [key: string]: any  // Allow additional methods (getByX, listPublished, etc.)
}

/**
 * Validation schemas for CRUD operations
 * Note: Zod schemas may have slightly different inferred types than DTOs due to validation structure
 * (e.g., nested where clauses), but they validate correctly at runtime.
 * Using 'any' here is necessary because Zod's type inference doesn't always match DTO types exactly,
 * but runtime validation ensures correctness.
 */
export interface CRUDSchemas<CreateDTO, UpdateDTO, QueryDTO> {
  create: ZodSchema<any>  // Use 'any' to accommodate Zod schemas with defaults/coercions
  update: ZodSchema<any>
  query: ZodSchema<any>  // Zod schemas validate correctly at runtime even if types don't match exactly
}

/**
 * Controller configuration
 */
export interface CRUDControllerConfig {
  modelName: string
  idType: 'number' | 'string'
  idField?: string
}

/**
 * Base CRUD Controller - Eliminates 80-85% of boilerplate
 */
export class BaseCRUDController<T, CreateDTO, UpdateDTO, QueryDTO> {
  constructor(
    private service: CRUDService<T, CreateDTO, UpdateDTO, QueryDTO>,  // Maintain type safety
    private schemas: CRUDSchemas<CreateDTO, UpdateDTO, QueryDTO>,
    private config: CRUDControllerConfig
  ) {
    // Log controller initialization
    logger.debug({ model: config.modelName, idType: config.idType }, \`Initialized BaseCRUDController for \${config.modelName}\`)
  }

  private getIdFromRequest(req: Request): number | string | null {
    const idField = this.config.idField || 'id'
    const rawId = req.params[idField] || req.params.id
    
    if (!rawId) {
      return null
    }
    
    if (this.config.idType === 'number') {
      const id = parseInt(rawId, 10)
      if (isNaN(id)) {
        return null
      }
      return id
    }
    
    if (typeof rawId === 'string' && rawId.trim() === '') {
      return null
    }
    
    return rawId
  }

  private parseId(req: Request, res: Response): number | string | null {
    const id = this.getIdFromRequest(req)
    
    if (id === null) {
      logger.warn(\`Missing or invalid \${this.config.modelName} ID\`)
      res.status(400).json({ error: 'ID is required and must be valid' })
      return null
    }
    
    return id
  }

  private handleValidationError(error: ZodError, operation: string, res: Response): void {
    logger.warn({ error: error.errors, operation }, \`Validation error in \${operation}\`)
    res.status(400).json({ error: 'Validation Error', details: error.errors })
  }

  private handleError(error: unknown, operation: string, context: Record<string, any>, res: Response): void {
    // Handle common database errors (Prisma, Sequelize, etc.)
    if (error && typeof error === 'object' && 'code' in error) {
      const errorCode = (error as { code: string }).code
      
      // Record not found errors (Prisma, Sequelize, etc.)
      if (errorCode === 'P2025' || errorCode === 'P2016' || errorCode === 'P2018' || errorCode === 'ENOTFOUND') {
        const idKey = \`\${this.config.modelName.toLowerCase()}Id\`
        const id = context.id || context[idKey] || (context.req ? this.getIdFromRequest(context.req) : null)
        logger.debug({ [idKey]: id }, \`\${this.config.modelName} not found\`)
        res.status(404).json({ error: \`\${this.config.modelName} not found\` })
        return
      }
      
      // Unique constraint violations
      if (errorCode === 'P2002') {
        logger.warn({ error, ...context, operation }, \`Unique constraint violation in \${operation}\`)
        res.status(409).json({ 
          error: 'Conflict', 
          message: 'A record with this value already exists',
          details: error instanceof Error ? error.message : String(error)
        })
        return
      }
    }
    
    // Preserve error context for better debugging
    const errorMessage = error instanceof Error ? error.message : String(error)
    const errorStack = error instanceof Error ? error.stack : undefined
    
    logger.error({ error: errorMessage, stack: errorStack, ...context, operation }, \`Error in \${operation}\`)
    
    // Return error details in development, generic message in production
    const isDevelopment = process.env.NODE_ENV !== 'production'
    
    // Sanitize context to remove non-serializable objects (like req/res) to avoid circular reference errors
    const sanitizedContext = this.sanitizeContext(context)
    
    res.status(500).json({ 
      error: 'Internal Server Error',
      ...(isDevelopment && { message: errorMessage, details: sanitizedContext })
    })
  }

  /**
   * Remove non-serializable objects from context to prevent circular reference errors
   */
  private sanitizeContext(context: Record<string, any>): Record<string, any> {
    const sanitized: Record<string, any> = {}
    
    for (const [key, value] of Object.entries(context)) {
      // Skip Request/Response objects and other non-serializable objects
      if (value && typeof value === 'object') {
        // Check for common Express objects that have circular references
        if (key === 'req' || key === 'res' || key === 'request' || key === 'response') {
          // Replace with a simple identifier instead of the full object
          sanitized[key] = \`[\${key} object]\`
        } else if (value.constructor && value.constructor.name === 'IncomingMessage') {
          sanitized[key] = '[Request object]'
        } else if (value.constructor && value.constructor.name === 'ServerResponse') {
          sanitized[key] = '[Response object]'
        } else {
          // For other objects, try to serialize safely
          try {
            JSON.stringify(value)
            sanitized[key] = value
          } catch {
            sanitized[key] = \`[\${typeof value} object]\`
          }
        }
      } else {
        sanitized[key] = value
      }
    }
    
    return sanitized
  }

  async list(req: Request, res: Response): Promise<Response> {
    try {
      logger.debug({ model: this.config.modelName, query: req.query }, \`Listing \${this.config.modelName}s\`)
      
      // Parse and validate query parameters using schema (handles string coercion)
      const query = this.schemas.query.parse(req.query)
      const result = await this.service.list(query)
      
      // Ensure consistent response shape
      return res.json({
        data: result.data || [],
        meta: result.meta || {}
      })
    } catch (error) {
      if (error instanceof ZodError) {
        this.handleValidationError(error, \`list\${this.config.modelName}s\`, res)
        return res
      }
      this.handleError(error, \`list\${this.config.modelName}s\`, { query: req.query }, res)
      return res
    }
  }

  async search(req: Request, res: Response): Promise<Response> {
    try {
      if (!this.service.search) {
        return res.status(501).json({ error: 'Search not supported' })
      }
      
      // POST /search: accepts complex filtering in request body
      const query = this.schemas.query.parse(req.body)
      const result = await this.service.search(query)
      return res.json(result)
    } catch (error) {
      if (error instanceof ZodError) {
        this.handleValidationError(error, \`search\${this.config.modelName}s\`, res)
        return res
      }
      this.handleError(error, \`search\${this.config.modelName}s\`, {}, res)
      return res
    }
  }

  async getById(req: Request, res: Response): Promise<Response | void> {
    try {
      const id = this.parseId(req, res)
      if (id === null) return
      
      logger.debug({ id, model: this.config.modelName }, \`Fetching \${this.config.modelName}\`)
      
      const item = await this.service.findById(id)
      if (!item) {
        const idKey = \`\${this.config.modelName.toLowerCase()}Id\`
        logger.debug({ [idKey]: id }, \`\${this.config.modelName} not found\`)
        return res.status(404).json({ error: \`\${this.config.modelName} not found\` })
      }
      
      return res.json({ data: item })
    } catch (error) {
      const id = this.getIdFromRequest(req)
      this.handleError(error, \`get\${this.config.modelName}\`, { id, req }, res)
      return res
    }
  }

  async create(req: Request, res: Response): Promise<Response> {
    try {
      logger.debug({ model: this.config.modelName }, \`Creating \${this.config.modelName}\`)
      
      const data = this.schemas.create.parse(req.body)
      const item = await this.service.create(data)
      
      // Safely access id property (T may not always have id, but most models do)
      const itemId = (item as any)?.id || 'unknown'
      logger.info({ id: itemId, model: this.config.modelName }, \`Created \${this.config.modelName}\`)
      return res.status(201).json({ data: item })
    } catch (error) {
      if (error instanceof ZodError) {
        this.handleValidationError(error, \`create\${this.config.modelName}\`, res)
        return res
      }
      this.handleError(error, \`create\${this.config.modelName}\`, { body: req.body }, res)
      return res
    }
  }

  async update(req: Request, res: Response): Promise<Response | void> {
    try {
      const id = this.parseId(req, res)
      if (id === null) return
      
      logger.debug({ id, model: this.config.modelName }, \`Updating \${this.config.modelName}\`)
      
      const data = this.schemas.update.parse(req.body)
      const item = await this.service.update(id, data)
      
      if (!item) {
        const idKey = \`\${this.config.modelName.toLowerCase()}Id\`
        logger.debug({ [idKey]: id }, \`\${this.config.modelName} not found for update\`)
        return res.status(404).json({ error: \`\${this.config.modelName} not found\` })
      }
      
      logger.info({ id, model: this.config.modelName }, \`Updated \${this.config.modelName}\`)
      return res.json({ data: item })
    } catch (error) {
      if (error instanceof ZodError) {
        this.handleValidationError(error, \`update\${this.config.modelName}\`, res)
        return res
      }
      const id = this.getIdFromRequest(req)
      this.handleError(error, \`update\${this.config.modelName}\`, { id, body: req.body, req }, res)
      return res
    }
  }

  async deleteRecord(req: Request, res: Response): Promise<Response | void> {
    try {
      const id = this.parseId(req, res)
      if (id === null) return
      
      logger.debug({ id, model: this.config.modelName }, \`Deleting \${this.config.modelName}\`)
      
      const result = await this.service.delete(id)
      
      // Handle soft-delete services that return the deleted item
      if (result === false || result === null) {
        const idKey = \`\${this.config.modelName.toLowerCase()}Id\`
        logger.debug({ [idKey]: id }, \`\${this.config.modelName} not found for deletion\`)
        return res.status(404).json({ error: \`\${this.config.modelName} not found\` })
      }
      
      logger.info({ id, model: this.config.modelName }, \`Deleted \${this.config.modelName}\`)
      return res.status(204).send()
    } catch (error) {
      const id = this.getIdFromRequest(req)
      this.handleError(error, \`delete\${this.config.modelName}\`, { id, req }, res)
      return res
    }
  }

  async count(req: Request, res: Response): Promise<Response> {
    try {
      // Parse query parameters if provided for filtered counting
      let where: any
      
      if (req.query.where) {
        try {
          where = JSON.parse(req.query.where as string)
        } catch (parseError) {
          logger.warn({ query: req.query.where }, 'Invalid JSON in where parameter')
          return res.status(400).json({ 
            error: 'Invalid JSON in where parameter',
            details: parseError instanceof Error ? parseError.message : String(parseError)
          })
        }
      } else {
        const parsedQuery = this.schemas.query.parse(req.query)
        where = parsedQuery.where
      }
      
      const total = await this.service.count(where)
      return res.json({ total })
    } catch (error) {
      if (error instanceof ZodError) {
        this.handleValidationError(error, \`count\${this.config.modelName}s\`, res)
        return res
      }
      this.handleError(error, \`count\${this.config.modelName}s\`, { query: req.query }, res)
      return res
    }
  }

  async bulkCreate(req: Request, res: Response): Promise<Response> {
    try {
      if (!this.service.createMany) {
        return res.status(501).json({ error: 'Bulk create not supported' })
      }
      
      if (!req.body || typeof req.body !== 'object') {
        return res.status(400).json({ error: 'Request body is required and must be an object' })
      }
      
      const body = req.body
      if (!Array.isArray(body.data)) {
        return res.status(400).json({ error: 'data must be an array' })
      }
      
      // Validate each item in the array
      const validatedData = body.data.map((item: any) => {
        try {
          return this.schemas.create.parse(item)
        } catch (error) {
          if (error instanceof ZodError) {
            throw new Error(\`Validation error in bulk create: \${error.errors.map(e => e.message).join(', ')}\`)
          }
          throw error
        }
      })
      
      logger.debug({ count: validatedData.length, model: this.config.modelName }, \`Bulk creating \${this.config.modelName} records\`)
      
      const result = await this.service.createMany(validatedData)
      // Handle Prisma BatchPayload or { count: number } return type
      const count = (result as any)?.count ?? 0
      logger.info({ count }, \`Bulk created \${this.config.modelName} records\`)
      return res.status(201).json({ 
        data: { count },
        meta: { 
          total: count,
          message: \`Created \${count} \${this.config.modelName} records\`
        }
      })
    } catch (error) {
      if (error instanceof ZodError) {
        this.handleValidationError(error, \`bulk create \${this.config.modelName}s\`, res)
        return res
      }
      this.handleError(error, \`bulk create \${this.config.modelName}s\`, { body: req.body }, res)
      return res
    }
  }

  async bulkUpdate(req: Request, res: Response): Promise<Response> {
    try {
      if (!this.service.updateMany) {
        return res.status(501).json({ error: 'Bulk update not supported' })
      }
      
      if (!req.body || typeof req.body !== 'object') {
        return res.status(400).json({ error: 'Request body is required and must be an object' })
      }
      
      const { where, data } = req.body
      if (!where || !data) {
        return res.status(400).json({ error: 'where and data are required' })
      }
      
      // Validate update data using schema
      const validatedData = this.schemas.update.parse(data)
      
      logger.debug({ model: this.config.modelName }, \`Bulk updating \${this.config.modelName} records\`)
      
      const result = await this.service.updateMany(where, validatedData)
      // Handle Prisma BatchPayload or { count: number } return type
      const count = (result as any)?.count ?? 0
      logger.info({ count }, \`Bulk updated \${this.config.modelName} records\`)
      return res.json({ 
        data: { count },
        meta: { 
          total: count,
          message: \`Updated \${count} \${this.config.modelName} records\`
        }
      })
    } catch (error) {
      if (error instanceof ZodError) {
        this.handleValidationError(error, \`bulk update \${this.config.modelName}s\`, res)
        return res
      }
      this.handleError(error, \`bulk update \${this.config.modelName}s\`, { body: req.body }, res)
      return res
    }
  }

  async bulkDelete(req: Request, res: Response): Promise<Response> {
    try {
      if (!this.service.deleteMany) {
        return res.status(501).json({ error: 'Bulk delete not supported' })
      }
      
      if (!req.body || typeof req.body !== 'object') {
        return res.status(400).json({ error: 'Request body is required and must be an object' })
      }
      
      const { where } = req.body
      if (!where || typeof where !== 'object') {
        return res.status(400).json({ error: 'where is required and must be an object' })
      }
      
      logger.debug({ where, model: this.config.modelName }, \`Bulk deleting \${this.config.modelName} records\`)
      
      const result = await this.service.deleteMany(where)
      // Handle Prisma BatchPayload or { count: number } return type
      const count = (result as any)?.count ?? 0
      logger.info({ count }, \`Bulk deleted \${this.config.modelName} records\`)
      return res.json({ 
        data: { count },
        meta: { 
          total: count,
          message: \`Deleted \${count} \${this.config.modelName} records\`
        }
      })
    } catch (error) {
      this.handleError(error, \`bulk delete \${this.config.modelName}s\`, { body: req.body }, res)
      return res
    }
  }
}

/**
 * Parse parameters from request for domain methods
 * Returns parsed args or throws error for invalid params
 */
function parseDomainMethodParams(
  req: Request,
  config: {
    idType?: 'number' | 'string'
    paramName?: string
    parseParams?: (req: Request) => any[]
    paramSchema?: z.ZodType<any, any, any>
  }
): any[] {
  if (config.parseParams) {
    const args = config.parseParams(req)
    
    // Validate parsed params if schema provided
    if (config.paramSchema) {
      const validated = config.paramSchema.parse(args)
      return Array.isArray(validated) ? validated : [validated]
    }
    
    return args
  }
  
  const paramName = config.paramName || 'id'
  const rawValue = req.params[paramName]
  
  if (config.idType === 'number') {
    const numValue = parseInt(rawValue, 10)
    if (isNaN(numValue)) {
      throw new Error(\`Invalid parameter format: \${paramName} must be a number\`)
    }
    return [numValue]
  }
  
  if (!rawValue || (typeof rawValue === 'string' && rawValue.trim() === '')) {
    throw new Error(\`Missing required parameter: \${paramName}\`)
  }
  
  return [rawValue]
}

export function createDomainMethodController<T>(
  serviceFn: (...args: any[]) => Promise<T | null>,
  config: {
    modelName: string
    methodName: string
    idType?: 'number' | 'string'
    paramName?: string
    parseParams?: (req: Request) => any[]
    paramSchema?: z.ZodType<any, any, any>
  }
) {
  return async (req: Request, res: Response): Promise<Response | void> => {
    try {
      logger.debug({ method: config.methodName, params: req.params }, \`Calling \${config.methodName}\`)
      
      const args = parseDomainMethodParams(req, config)
      const item = await serviceFn(...args)
      
      if (!item) {
        const idKey = \`\${config.modelName.toLowerCase()}Id\`
        logger.debug({ [idKey]: args[0] }, \`\${config.modelName} not found\`)
        return res.status(404).json({ error: \`\${config.modelName} not found\` })
      }
      
      return res.json({ data: item })
    } catch (error) {
      if (error instanceof ZodError) {
        logger.warn({ error: error.errors, params: req.params }, \`Validation error in \${config.methodName}\`)
        return res.status(400).json({
          error: 'Validation Error',
          details: error.errors
        })
      }
      
      // Handle parameter parsing errors
      if (error instanceof Error && error.message.includes('parameter')) {
        logger.warn({ error: error.message, params: req.params }, \`Invalid parameters for \${config.methodName}\`)
        return res.status(400).json({ error: error.message })
      }
      
      const errorMessage = error instanceof Error ? error.message : String(error)
      const errorStack = error instanceof Error ? error.stack : undefined
      logger.error({ error: errorMessage, stack: errorStack, method: config.methodName, params: req.params }, \`Error in \${config.methodName}\`)
      
      const isDevelopment = process.env.NODE_ENV !== 'production'
      return res.status(500).json({ 
        error: 'Internal Server Error',
        ...(isDevelopment && { message: errorMessage })
      })
    }
  }
}

export function createVoidDomainMethodController(
  serviceFn: (...args: any[]) => Promise<void | any>,
  config: {
    modelName: string
    methodName: string
    idType?: 'number' | 'string'
    paramName?: string
    parseParams?: (req: Request) => any[]
    paramSchema?: z.ZodType<any, any, any>
  }
) {
  return async (req: Request, res: Response): Promise<Response | void> => {
    try {
      logger.debug({ method: config.methodName, params: req.params }, \`Calling \${config.methodName}\`)
      
      const args = parseDomainMethodParams(req, config)
      await serviceFn(...args)
      
      logger.info({ method: config.methodName, params: req.params }, \`Completed \${config.methodName}\`)
      return res.status(204).send()
    } catch (error) {
      if (error instanceof ZodError) {
        logger.warn({ error: error.errors, params: req.params }, \`Validation error in \${config.methodName}\`)
        return res.status(400).json({
          error: 'Validation Error',
          details: error.errors
        })
      }
      
      // Handle parameter parsing errors
      if (error instanceof Error && error.message.includes('parameter')) {
        logger.warn({ error: error.message, params: req.params }, \`Invalid parameters for \${config.methodName}\`)
        return res.status(400).json({ error: error.message })
      }
      
      const errorMessage = error instanceof Error ? error.message : String(error)
      const errorStack = error instanceof Error ? error.stack : undefined
      logger.error({ error: errorMessage, stack: errorStack, method: config.methodName, params: req.params }, \`Error in \${config.methodName}\`)
      
      const isDevelopment = process.env.NODE_ENV !== 'production'
      return res.status(500).json({ 
        error: 'Internal Server Error',
        ...(isDevelopment && { message: errorMessage })
      })
    }
  }
}

export function createListMethodController(
  serviceFn: (query: any) => Promise<{ data: any[]; meta: any }>,
  querySchema: ZodSchema<any> | z.ZodType<any, any, any>,
  config: { modelName: string; methodName: string }
) {
  return async (req: Request, res: Response): Promise<Response> => {
    try {
      logger.debug({ method: config.methodName, query: req.query }, \`Calling \${config.methodName}\`)
      
      // Express query params are strings/arrays, Zod schemas handle coercion
      // Parse and validate query parameters - runtime validation ensures correctness
      // Type assertions bypass strict type checking since Zod validates at runtime
      const parsedQuery = querySchema.parse(req.query) as any
      
      // Call service function with validated query - type safety ensured by runtime validation
      const result = await serviceFn(parsedQuery)
      
      // Ensure consistent response shape
      return res.json({
        data: result.data || [],
        meta: result.meta || {}
      })
    } catch (error) {
      if (error instanceof ZodError) {
        logger.warn({ error: error.errors, query: req.query }, \`Validation error in \${config.methodName}\`)
        return res.status(400).json({
          error: 'Validation Error',
          details: error.errors
        })
      }
      
      const errorMessage = error instanceof Error ? error.message : String(error)
      const errorStack = error instanceof Error ? error.stack : undefined
      logger.error({ error: errorMessage, stack: errorStack, method: config.methodName, query: req.query }, \`Error in \${config.methodName}\`)
      
      const isDevelopment = process.env.NODE_ENV !== 'production'
      return res.status(500).json({ 
        error: 'Internal Server Error',
        ...(isDevelopment && { message: errorMessage })
      })
    }
  }
}
`
}

// Export as constant for backwards compatibility
export const baseCRUDControllerTemplate = getBaseCRUDControllerTemplate()
