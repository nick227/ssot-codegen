/**
 * Base Service Controller Template
 * Eliminates boilerplate from service integration controllers
 */

export function getBaseServiceControllerTemplate(): string {
  return `// @generated
// This file is automatically generated. Do not edit manually.

import type { Request, Response } from 'express'
import { ZodError, type ZodSchema } from 'zod'
import { logger } from '@/logger'

// AuthRequest type - defined locally to avoid dependency on auth plugin
// If @/auth/jwt exists, it will export AuthRequest with user property
type AuthRequest = Request & {
  user?: {
    userId?: number | string
    [key: string]: any
  }
}

/**
 * Configuration for service controller
 */
export interface ServiceControllerConfig {
  serviceName: string
}

/**
 * Options for wrapping a service method
 */
export interface WrapOptions<T = any> {
  schema?: ZodSchema<T>
  statusCode?: number
  extractParams?: (req: Request) => any[]
  requireAuth?: boolean
}

/**
 * Base Service Controller
 * 
 * Eliminates 90-96% of boilerplate from service integration controllers
 * by providing common functionality: auth checking, validation, error handling, logging.
 * 
 * @example
 * \`\`\`typescript
 * const controller = new BaseServiceController({ serviceName: 'ai-agent' })
 * 
 * export const sendMessage = controller.wrap(
 *   'sendMessage',
 *   aiAgentService.sendMessage
 * )
 * \`\`\`
 */
export class BaseServiceController {
  constructor(private config: ServiceControllerConfig) {}

  /**
   * Wrap a service method with standard auth, validation, and error handling
   * 
   * @param methodName - Name of the service method
   * @param serviceFn - Service function to call (receives userId as first param)
   * @param options - Additional options (schema, statusCode, etc.)
   */
  wrap<T>(
    methodName: string,
    serviceFn: (userId: number | string, ...args: any[]) => Promise<T>,
    options: WrapOptions = {}
  ) {
    const requireAuth = options.requireAuth !== false  // Default: true
    
    return async (req: AuthRequest | Request, res: Response): Promise<Response | void> => {
      try {
        // 1. Extract and validate user ID (if auth required)
        let userId: number | string | undefined
        
        if (requireAuth) {
          userId = (req as AuthRequest).user?.userId
          if (!userId) {
            logger.warn({ method: methodName }, 'Authentication required')
            return res.status(401).json({ error: 'Authentication required' })
          }
        }
        
        // 2. Parse and validate request data
        let data = req.body
        if (options.schema) {
          try {
            data = options.schema.parse(req.body)
          } catch (error) {
            if (error instanceof ZodError) {
              logger.warn(
                { error: error.errors, method: methodName },
                \`Validation error in \${methodName}\`
              )
              return res.status(400).json({
                error: 'Validation Error',
                details: error.errors
              })
            }
            throw error
          }
        }
        
        // 3. Extract additional parameters
        const params = options.extractParams
          ? options.extractParams(req)
          : [data]
        
        // 4. Call service method
        const result = await serviceFn(userId!, ...params)
        
        // 5. Log success
        logger.info(
          { userId, method: methodName, service: this.config.serviceName },
          \`Service method \${methodName} executed successfully\`
        )
        
        // 6. Return response
        const statusCode = options.statusCode || 201
        return res.status(statusCode).json(result)
      } catch (error: any) {
        return this.handleServiceError(error, methodName, req as AuthRequest, res)
      }
    }
  }

  /**
   * Handle service errors with consistent error responses
   */
  private handleServiceError(
    error: any,
    methodName: string,
    req: AuthRequest,
    res: Response
  ): Response {
    // Validation errors (should be caught earlier, but defensive)
    if (error instanceof ZodError) {
      logger.warn(
        { error: error.errors, method: methodName },
        \`Validation error in \${methodName}\`
      )
      return res.status(400).json({
        error: 'Validation Error',
        details: error.errors
      })
    }
    
    // Authorization/Forbidden errors
    if (
      error.message?.includes('Unauthorized') ||
      error.message?.includes('Forbidden') ||
      error.message?.includes('unauthorized') ||
      error.message?.includes('forbidden')
    ) {
      logger.warn(
        { error: error.message, userId: req.user?.userId, method: methodName },
        \`Authorization error in \${methodName}\`
      )
      return res.status(403).json({ error: error.message })
    }
    
    // Not found errors
    if (
      error.message?.includes('not found') ||
      error.message?.includes('Not found') ||
      error.message?.includes('NOT FOUND')
    ) {
      logger.warn(
        { error: error.message, method: methodName },
        \`Resource not found in \${methodName}\`
      )
      return res.status(404).json({ error: error.message })
    }
    
    // Generic server errors
    logger.error(
      { error, userId: req.user?.userId, method: methodName, service: this.config.serviceName },
      \`Error in \${methodName}\`
    )
    
    return res.status(500).json({
      error: 'Internal Server Error',
      message: process.env.NODE_ENV === 'development' ? error.message : undefined
    })
  }
  
  /**
   * Create a public (non-authenticated) service method wrapper
   * 
   * @example
   * \`\`\`typescript
   * export const initiateLogin = controller.wrapPublic(
   *   'initiateLogin',
   *   googleAuthService.initiateLogin
   * )
   * \`\`\`
   */
  wrapPublic<T>(
    methodName: string,
    serviceFn: (...args: any[]) => Promise<T>,
    options: Omit<WrapOptions, 'requireAuth'> = {}
  ) {
    return async (req: Request, res: Response): Promise<Response | void> => {
      try {
        // 1. Parse and validate request data
        let data = req.body
        if (options.schema) {
          try {
            data = options.schema.parse(req.body)
          } catch (error) {
            if (error instanceof ZodError) {
              logger.warn(
                { error: error.errors, method: methodName },
                \`Validation error in \${methodName}\`
              )
              return res.status(400).json({
                error: 'Validation Error',
                details: error.errors
              })
            }
            throw error
          }
        }
        
        // 2. Extract parameters
        const params = options.extractParams
          ? options.extractParams(req)
          : [data]
        
        // 3. Call service method
        const result = await serviceFn(...params)
        
        // 4. Log success
        logger.info(
          { method: methodName, service: this.config.serviceName },
          \`Public service method \${methodName} executed successfully\`
        )
        
        // 5. Return response
        const statusCode = options.statusCode || 201
        return res.status(statusCode).json(result)
      } catch (error: any) {
        return this.handleServiceError(error, methodName, {} as AuthRequest, res)
      }
    }
  }
}
`
}

// Export as constant for backwards compatibility
export const baseServiceControllerTemplate = getBaseServiceControllerTemplate()

