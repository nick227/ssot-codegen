// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Plugin Output Snapshots > Google Auth Plugin > should match Google OAuth strategy snapshot 1`] = `
"// @generated
// Google OAuth 2.0 Strategy using Passport.js

import passport from 'passport'
import { Strategy as GoogleStrategy } from 'passport-google-oauth20'
import { authService } from '../services/auth.service.js'
import type { GoogleProfile } from '../types/auth.types.js'

/**
 * Configure Google OAuth Strategy
 */
export function configureGoogleStrategy() {
  passport.use(
    new GoogleStrategy(
      {
        clientID: process.env.GOOGLE_CLIENT_ID!,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
        callbackURL: process.env.GOOGLE_CALLBACK_URL || 'http://localhost:3000/auth/google/callback',
        scope: ['profile', 'email']
      },
      async (accessToken, refreshToken, profile, done) => {
        try {
          // Extract profile data
          const googleProfile: GoogleProfile = {
            googleId: profile.id,
            email: profile.emails?.[0]?.value || '',
            name: profile.displayName,
            avatar: profile.photos?.[0]?.value,
            accessToken,
            refreshToken
          }
          
          // Find or create user
          const user = await authService.findOrCreateGoogleUser(googleProfile)
          
          done(null, user)
        } catch (error) {
          done(error as Error)
        }
      }
    )
  )
  
  // Using JWT strategy - no serialization needed
}
"
`;

exports[`Plugin Output Snapshots > Google Auth Plugin > should match JWT utilities snapshot 1`] = `
"// @generated
// JWT token utilities

import jwt from 'jsonwebtoken'

const JWT_SECRET = process.env.JWT_SECRET || 'change-this-secret-in-production'
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d'

export interface JWTPayload {
  userId: number
  email: string
  name?: string
  iat?: number
  exp?: number
}

/**
 * Generate JWT token
 */
export function generateToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
  return jwt.sign(payload, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN
  })
}

/**
 * Verify JWT token
 */
export function verifyToken(token: string): JWTPayload {
  try {
    return jwt.verify(token, JWT_SECRET) as JWTPayload
  } catch (error) {
    throw new Error('Invalid or expired token')
  }
}

/**
 * Decode token without verification (for debugging)
 */
export function decodeToken(token: string): JWTPayload | null {
  try {
    return jwt.decode(token) as JWTPayload
  } catch (error) {
    return null
  }
}
"
`;

exports[`Plugin Output Snapshots > Google Auth Plugin > should match OAuth routes snapshot 1`] = `
"// @generated
// Authentication routes

import { Router } from 'express'
import passport from 'passport'
import { authService } from '../services/auth.service.js'
import { rateLimit } from 'express-rate-limit'
import { generateToken } from '../utils/jwt.util.js'

export const authRouter = Router()

/**
 * Rate limiter for auth routes (prevent brute force)
 */
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // 10 attempts per window
  message: 'Too many authentication attempts, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
})

/**
 * GET /auth/google
 * Initiate Google OAuth flow
 */
authRouter.get('/google',
  authLimiter,
  passport.authenticate('google', { 
    scope: ['profile', 'email'],
    session: false
  })
)

/**
 * GET /auth/google/callback
 * Google OAuth callback
 */
authRouter.get('/google/callback',
  authLimiter,
  passport.authenticate('google', { 
    session: false, failureRedirect: '/login?error=auth_failed'
  }),
  async (req, res) => {
    try {
      const user = req.user as any
      
      
      // Generate JWT token
      const token = generateToken({
        userId: user.id,
        email: user.email,
        name: user.name
      })
      
      // SECURITY FIX: Return token via secure HTML page with postMessage
      // This prevents token from appearing in URLs (logged, cached, leaked via Referer header)
      res.send(\`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Authentication Success</title>
          <meta charset="utf-8">
        </head>
        <body>
          <script>
            // Send token to parent window (if opened from popup)
            if (window.opener) {
              window.opener.postMessage({ type: 'AUTH_SUCCESS', token: '\${token}' }, window.location.origin);
              window.close();
            } else {
              // Store token in secure cookie or localStorage and redirect
              localStorage.setItem('auth_token', '\${token}');
              window.location.href = '/dashboard';
            }
          </script>
          <p>Authenticated successfully! Redirecting...</p>
        </body>
        </html>
      \`)
      
    } catch (error) {
      console.error('OAuth callback error:', error)
      res.redirect('/login?error=callback_failed')
    }
  }
)

/**
 * POST /auth/logout
 * Logout user
 */
authRouter.post('/logout', (req, res) => {
  
  // JWT-based - just clear client-side token
  res.json({ message: 'Logged out successfully' })
  
})

/**
 * GET /auth/me
 * Get current user
 */
authRouter.get('/me', (req, res) => {
  
  // JWT - user extracted by middleware
  res.json({ user: req.user })
  
})


"
`;

exports[`Plugin Output Snapshots > Google Auth Plugin > should match auth middleware snapshot 1`] = `
"// @generated
// JWT-based authentication middleware

import { verifyToken } from '../utils/jwt.util.js'
import { authService } from '../services/auth.service.js'
import type { Request, Response, NextFunction } from 'express'

/**
 * Require authentication (JWT)
 */
export async function requireAuth(req: Request, res: Response, next: NextFunction) {
  try {
    const token = extractToken(req)
    
    if (!token) {
      return res.status(401).json({ error: 'Authentication required' })
    }
    
    const payload = verifyToken(token)
    
    // Attach user to request
    const user = await authService.findUserById(payload.userId)
    if (!user) {
      return res.status(401).json({ error: 'User not found' })
    }
    
    req.user = user
    next()
  } catch (error) {
    res.status(401).json({ error: 'Invalid or expired token' })
  }
}

/**
 * Optional authentication
 */
export async function optionalAuth(req: Request, res: Response, next: NextFunction) {
  try {
    const token = extractToken(req)
    if (token) {
      const payload = verifyToken(token)
      const user = await authService.findUserById(payload.userId)
      req.user = user
    }
  } catch (error) {
    // Ignore auth errors for optional auth
  }
  next()
}

/**
 * Extract JWT token from Authorization header
 */
function extractToken(req: Request): string | null {
  const auth = req.headers.authorization
  if (!auth) return null
  
  const parts = auth.split(' ')
  if (parts.length !== 2 || parts[0] !== 'Bearer') {
    return null
  }
  
  return parts[1]
}
"
`;

exports[`Plugin Output Snapshots > OpenAI Plugin > should match OpenAI dependencies snapshot 1`] = `
{
  "dependencies": {
    "openai": "^4.77.0",
  },
  "devDependencies": {},
}
`;

exports[`Plugin Output Snapshots > OpenAI Plugin > should match OpenAI env vars snapshot 1`] = `
{
  "OPENAI_API_KEY": "sk-your-openai-api-key-here",
  "OPENAI_BASE_URL": "https://api.openai.com/v1",
  "OPENAI_ORG_ID": "optional-org-id",
}
`;

exports[`Plugin Output Snapshots > OpenAI Plugin > should match OpenAI service file snapshot 1`] = `
"// @generated
// OpenAI Service - High-level API for common tasks

import { openaiProvider } from '../providers/openai.provider.js'
import type { ChatMessage, ChatOptions } from '../types/ai.types.js'

export const openaiService = {
  /**
   * Simple chat completion
   * 
   * @example
   * const response = await openaiService.chat('What is TypeScript?')
   * console.log(response)
   */
  async chat(
    prompt: string,
    options: ChatOptions = {}
  ): Promise<string> {
    const messages: ChatMessage[] = [
      { role: 'user', content: prompt }
    ]
    
    const response = await openaiProvider.chat(messages, options)
    return response.content
  },
  
  /**
   * Chat with conversation history
   * 
   * @example
   * const messages = [
   *   { role: 'system', content: 'You are a helpful assistant' },
   *   { role: 'user', content: 'Hello!' }
   * ]
   * const response = await openaiService.chatWithHistory(messages)
   */
  async chatWithHistory(
    messages: ChatMessage[],
    options: ChatOptions = {}
  ): Promise<ChatResponse> {
    return openaiProvider.chat(messages, options)
  },
  
  /**
   * Generate embeddings for text
   * 
   * @example
   * const embedding = await openaiService.embed('Hello world')
   * // Returns: [0.123, -0.456, ...]
   */
  async embed(text: string): Promise<number[]> {
    const embeddings = await openaiProvider.embed(text)
    return embeddings[0]
  },
  
  /**
   * Generate embeddings for multiple texts
   * 
   * @example
   * const embeddings = await openaiService.embedBatch(['Text 1', 'Text 2'])
   */
  async embedBatch(texts: string[]): Promise<number[][]> {
    return openaiProvider.embed(texts)
  },
  
  /**
   * Classify text into categories
   * 
   * @example
   * const category = await openaiService.classify(
   *   'This movie was amazing!',
   *   ['positive', 'negative', 'neutral']
   * )
   * // Returns: 'positive'
   */
  async classify(text: string, categories: string[]): Promise<string> {
    const prompt = \`Classify the following text into one of these categories: \${categories.join(', ')}

Text: \${text}

Category:\`

    const response = await this.chat(prompt, {
      temperature: 0,
      maxTokens: 10
    })
    
    return response.trim().toLowerCase()
  },
  
  /**
   * Extract structured data from text
   * 
   * @example
   * const data = await openaiService.extract(
   *   'Email me at john@example.com',
   *   { email: 'string', name: 'string' }
   * )
   * // Returns: { email: 'john@example.com', name: 'john' }
   */
  async extract<T extends Record<string, string>>(
    text: string,
    schema: T
  ): Promise<Partial<Record<keyof T, string>>> {
    const schemaDesc = Object.entries(schema)
      .map(([key, type]) => \`- \${key}: \${type}\`)
      .join('\\n')
    
    const prompt = \`Extract the following information from the text:

\${schemaDesc}

Text: \${text}

Return as JSON:\`

    const response = await this.chat(prompt, {
      temperature: 0,
      maxTokens: 200
    })
    
    try {
      return JSON.parse(response)
    } catch {
      return {}
    }
  },
  
  /**
   * Summarize text
   * 
   * @example
   * const summary = await openaiService.summarize(longText, 50)
   * // Returns: "Summary in ~50 words..."
   */
  async summarize(text: string, maxWords: number = 100): Promise<string> {
    const prompt = \`Summarize the following text in approximately \${maxWords} words:

\${text}\`

    return this.chat(prompt, {
      temperature: 0.3,
      maxTokens: maxWords * 2  // ~2 tokens per word
    })
  },
  
  /**
   * Translate text
   * 
   * @example
   * const translated = await openaiService.translate('Hello', 'Spanish')
   * // Returns: "Hola"
   */
  async translate(text: string, targetLanguage: string): Promise<string> {
    const prompt = \`Translate the following text to \${targetLanguage}:

\${text}\`

    return this.chat(prompt, {
      temperature: 0,
      maxTokens: text.length * 2
    })
  },
  
  /**
   * Check content moderation
   * 
   * @example
   * const result = await openaiService.moderate('Some text to check')
   * if (result.flagged) {
   *   console.log('Content flagged:', result.categories)
   * }
   */
  async moderate(text: string): Promise<{
    flagged: boolean
    categories: string[]
    scores: Record<string, number>
  }> {
    const response = await openai.moderations.create({ input: text })
    const result = response.results[0]
    
    const flaggedCategories = Object.entries(result.categories)
      .filter(([_, flagged]) => flagged)
      .map(([category]) => category)
    
    return {
      flagged: result.flagged,
      categories: flaggedCategories,
      scores: result.category_scores as Record<string, number>
    }
  }
}

// Re-export provider for direct access
export { openaiProvider } from '../providers/openai.provider.js'
"
`;

exports[`Plugin Output Snapshots > S3 Plugin > should match S3 file structure snapshot > s3-files 1`] = `
[
  "storage/providers/s3.provider.ts",
  "storage/s3.ts",
]
`;

exports[`Plugin Output Snapshots > SendGrid Plugin > should match SendGrid file structure snapshot > sendgrid-files 1`] = `
[
  "email/providers/sendgrid.provider.ts",
  "email/sendgrid.ts",
]
`;

exports[`Plugin Output Snapshots > Stripe Plugin > should generate consistent file structure > stripe-files 1`] = `
[
  "payments/providers/stripe.provider.ts",
  "payments/stripe.ts",
]
`;

exports[`Plugin Output Snapshots > Stripe Plugin > should match Stripe provider snapshot 1`] = `
"// @generated
import Stripe from 'stripe'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: '2024-11-20.acacia' })

export const stripeProvider = {
  async createPaymentIntent(amount: number, currency = 'usd') {
    return stripe.paymentIntents.create({ amount, currency })
  },
  
  async createCustomer(email: string, name?: string) {
    return stripe.customers.create({ email, name })
  },
  
  async createSubscription(customerId: string, priceId: string) {
    return stripe.subscriptions.create({ customer: customerId, items: [{ price: priceId }] })
  },
  
  async cancelSubscription(subscriptionId: string) {
    return stripe.subscriptions.cancel(subscriptionId)
  }
}

export { stripe }
"
`;
