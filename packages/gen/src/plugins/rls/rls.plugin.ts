/**
 * RLS Plugin - Row-Level Security
 * 
 * Converts policy-engine definitions into generated middleware code.
 */

import type {
  FeaturePlugin,
  PluginContext,
  PluginOutput,
  PluginRequirements,
  ValidationResult,
  HealthCheckSection
} from '../plugin.interface.js'

export interface RlsPluginConfig {
  /** Enable owner-based security (default: true) */
  enableOwnerSecurity?: boolean
  
  /** Owner field name (default: 'uploadedBy', 'createdBy', 'userId') */
  ownerFields?: string[]
  
  /** Public filter field (default: 'isPublic') */
  publicField?: string
  
  /** Enable field-level permissions (default: true) */
  enableFieldPermissions?: boolean
  
  /** Admin role name (default: 'admin') */
  adminRole?: string
}

export class RlsPlugin implements FeaturePlugin {
  name = 'rls'
  version = '1.0.0'
  description = 'Row-level security and field-level permissions middleware'
  enabled = true
  
  private config: Required<RlsPluginConfig>
  
  constructor(config: RlsPluginConfig = {}) {
    this.config = {
      enableOwnerSecurity: true,
      ownerFields: ['uploadedBy', 'createdBy', 'userId', 'ownerId'],
      publicField: 'isPublic',
      enableFieldPermissions: true,
      adminRole: 'admin',
      ...config
    }
  }
  
  requirements: PluginRequirements = {
    models: {
      required: [],
      optional: ['User']  // Recommended for auth context
    },
    envVars: {
      required: [],
      optional: ['RLS_ADMIN_ROLE']
    },
    dependencies: {
      runtime: {
        '@ssot-ui/expressions': 'workspace:*'  // For policy expressions
      }
    }
  }
  
  validate(context: PluginContext): ValidationResult {
    const errors: string[] = []
    const warnings: string[] = []
    const suggestions: string[] = []
    
    // Check for User model (recommended)
    const hasUserModel = context.schema.models.some(m => m.name === 'User')
    if (!hasUserModel) {
      warnings.push('No User model found - RLS will work but authentication context may be limited')
      suggestions.push('Add a User model for full authentication support')
    }
    
    // Check for owner fields in models
    const modelsWithOwnerFields = context.schema.models.filter(model => 
      model.fields.some(field => this.config.ownerFields.includes(field.name))
    )
    
    if (modelsWithOwnerFields.length === 0) {
      warnings.push(`No models have owner fields (${this.config.ownerFields.join(', ')})`)
      suggestions.push('Add uploadedBy, createdBy, or ownerId fields to enable owner-based security')
    }
    
    // Check for public field
    const modelsWithPublicField = context.schema.models.filter(model =>
      model.fields.some(field => field.name === this.config.publicField)
    )
    
    if (modelsWithPublicField.length > 0) {
      suggestions.push(`Found ${modelsWithPublicField.length} models with ${this.config.publicField} field - public filtering will be enabled`)
    }
    
    return {
      valid: errors.length === 0,
      errors,
      warnings,
      suggestions
    }
  }
  
  generate(context: PluginContext): PluginOutput {
    const files = new Map<string, string>()
    
    // Generate RLS middleware
    files.set('middleware/rls.ts', this.generateRlsMiddleware(context))
    
    // Generate permission middleware
    if (this.config.enableFieldPermissions) {
      files.set('middleware/permissions.ts', this.generatePermissionsMiddleware(context))
    }
    
    // Generate default policies configuration
    files.set('config/policies.json', this.generateDefaultPolicies(context))
    
    // Generate types
    files.set('types/rls.types.ts', this.generateTypes())
    
    return {
      files,
      routes: [],
      middleware: [
        {
          name: 'rlsFilter',
          importPath: '@/middleware/rls',
          global: false  // Applied per-route in controllers
        }
      ],
      envVars: {
        RLS_ADMIN_ROLE: this.config.adminRole
      },
      packageJson: {
        dependencies: {
          '@ssot-ui/expressions': 'workspace:*'
        }
      }
    }
  }
  
  private generateRlsMiddleware(context: PluginContext): string {
    return `// @generated by RLS Plugin
// Row-Level Security Middleware

import type { User } from '@/types/auth'

export interface RlsContext {
  user?: User
  model: string
  action: 'read' | 'create' | 'update' | 'delete'
  where?: Record<string, any>
}

export interface RlsResult {
  allowed: boolean
  where: Record<string, any>
  reason?: string
}

/**
 * Apply RLS filters to a query
 * 
 * Conventions:
 * - Admin users bypass all filters
 * - Models with ${this.config.ownerFields.map(f => `"${f}"`).join('/')} enforce owner-only access
 * - Models with "${this.config.publicField}" allow public read access
 * - Unauthenticated requests see only public data
 */
export function applyRLS(context: RlsContext): RlsResult {
  const { user, model, action, where = {} } = context
  
  // Admin bypass
  if (user?.role === '${this.config.adminRole}') {
    return { allowed: true, where }
  }
  
  // Check if model has owner field
  const ownerField = findOwnerField(model)
  const hasPublicField = modelHasPublicField(model)
  
  // Unauthenticated users
  if (!user?.id) {
    // Allow read if public field exists
    if (action === 'read' && hasPublicField) {
      return {
        allowed: true,
        where: { ...where, ${this.config.publicField}: true }
      }
    }
    
    // Block all other actions
    return {
      allowed: false,
      where,
      reason: 'Authentication required'
    }
  }
  
  // Authenticated users
  if (ownerField) {
    // Owner-based access
    if (action === 'read' && hasPublicField) {
      // Can read own or public records
      return {
        allowed: true,
        where: {
          ...where,
          OR: [
            { [ownerField]: user.id },
            { ${this.config.publicField}: true }
          ]
        }
      }
    } else {
      // Can only access own records
      return {
        allowed: true,
        where: { ...where, [ownerField]: user.id }
      }
    }
  }
  
  // No owner field - allow all authenticated access
  return { allowed: true, where }
}

/**
 * Find owner field in model
 */
function findOwnerField(model: string): string | null {
  const ownerFields = ${JSON.stringify(this.config.ownerFields)}
  const modelFields = getModelFields(model)
  
  for (const field of ownerFields) {
    if (modelFields.includes(field)) {
      return field
    }
  }
  
  return null
}

/**
 * Check if model has public field
 */
function modelHasPublicField(model: string): boolean {
  const modelFields = getModelFields(model)
  return modelFields.includes('${this.config.publicField}')
}

/**
 * Get model fields (generated based on schema)
 */
function getModelFields(model: string): string[] {
  const modelFieldMap: Record<string, string[]> = ${JSON.stringify(
    Object.fromEntries(
      context.schema.models.map(m => [
        m.name,
        m.fields.map(f => f.name)
      ])
    ),
    null,
    2
  )}
  
  return modelFieldMap[model] || []
}
`
  }
  
  private generatePermissionsMiddleware(context: PluginContext): string {
    return `// @generated by RLS Plugin
// Field-Level Permissions Middleware

import type { User } from '@/types/auth'

export interface PermissionContext {
  user?: User
  model: string
  field: string
  action: 'read' | 'write'
}

export interface PermissionResult {
  allowed: boolean
  reason?: string
}

/**
 * Check field-level permissions
 * 
 * Conventions:
 * - Admin users can access all fields
 * - Users cannot modify their own role or id
 * - Sensitive fields (password, secret, key) are read-protected
 */
export function checkFieldPermission(context: PermissionContext): PermissionResult {
  const { user, model, field, action } = context
  
  // Admin bypass
  if (user?.role === '${this.config.adminRole}') {
    return { allowed: true }
  }
  
  // Deny list for sensitive fields
  const sensitivFields = ['password', 'secret', 'apiKey', 'privateKey', 'salt', 'hash']
  if (action === 'read' && sensitivFields.some(sf => field.toLowerCase().includes(sf.toLowerCase()))) {
    return {
      allowed: false,
      reason: 'Sensitive field not readable'
    }
  }
  
  // Protected fields for write
  const protectedFields = ['id', 'role', 'createdAt', 'updatedAt']
  if (action === 'write' && protectedFields.includes(field)) {
    return {
      allowed: false,
      reason: 'Protected field not writable'
    }
  }
  
  // Default allow
  return { allowed: true }
}

/**
 * Filter allowed fields for read/write
 */
export function getAllowedFields(
  model: string,
  action: 'read' | 'write',
  user?: User
): string[] {
  const allFields = getModelFields(model)
  
  return allFields.filter(field => {
    const result = checkFieldPermission({ user, model, field, action })
    return result.allowed
  })
}

/**
 * Get model fields
 */
function getModelFields(model: string): string[] {
  const modelFieldMap: Record<string, string[]> = ${JSON.stringify(
    Object.fromEntries(
      context.schema.models.map(m => [
        m.name,
        m.fields.map(f => f.name)
      ])
    ),
    null,
    2
  )}
  
  return modelFieldMap[model] || []
}
`
  }
  
  private generateDefaultPolicies(context: PluginContext): string {
    const policies = {
      version: '1.0',
      description: 'Default RLS policies',
      policies: context.schema.models.map(model => {
        const ownerField = model.fields.find(f => 
          this.config.ownerFields.includes(f.name)
        )
        const hasPublicField = model.fields.some(f => 
          f.name === this.config.publicField
        )
        
        return {
          model: model.name,
          description: `Security policy for ${model.name}`,
          rules: [
            {
              action: 'read',
              allow: hasPublicField 
                ? { op: 'or', args: [
                    { op: 'isOwner', field: ownerField?.name },
                    { op: 'eq', args: [{ op: 'field', field: this.config.publicField }, true] }
                  ]}
                : ownerField
                  ? { op: 'isOwner', field: ownerField.name }
                  : { op: 'isAuthenticated' }
            },
            {
              action: 'create',
              allow: { op: 'isAuthenticated' }
            },
            {
              action: 'update',
              allow: ownerField 
                ? { op: 'or', args: [
                    { op: 'isOwner', field: ownerField.name },
                    { op: 'hasRole', role: this.config.adminRole }
                  ]}
                : { op: 'isAuthenticated' }
            },
            {
              action: 'delete',
              allow: ownerField
                ? { op: 'or', args: [
                    { op: 'isOwner', field: ownerField.name },
                    { op: 'hasRole', role: this.config.adminRole }
                  ]}
                : { op: 'hasRole', role: this.config.adminRole }
            }
          ]
        }
      })
    }
    
    return JSON.stringify(policies, null, 2)
  }
  
  private generateTypes(): string {
    return `// @generated by RLS Plugin
// RLS Types

export interface User {
  id: string
  role?: string
  email?: string
}

export type RlsAction = 'read' | 'create' | 'update' | 'delete'

export interface RlsFilter {
  model: string
  action: RlsAction
  where?: Record<string, any>
}
`
  }
  
  healthCheck(context: PluginContext): HealthCheckSection {
    return {
      id: 'rls',
      title: 'Row-Level Security',
      icon: 'ðŸ”’',
      checks: [
        {
          id: 'rls-middleware',
          name: 'RLS Middleware Generated',
          description: 'Row-level security middleware is in place'
        },
        {
          id: 'permission-checks',
          name: 'Permission Checks',
          description: 'Field-level permission checks are configured'
        },
        {
          id: 'owner-security',
          name: 'Owner-Based Security',
          description: 'Models with owner fields are protected'
        }
      ]
    }
  }
}

