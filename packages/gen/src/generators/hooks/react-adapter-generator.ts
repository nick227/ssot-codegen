/**
 * React Adapter Generator
 * 
 * Generates React hooks that wrap core queries with React Query
 */

import type { ParsedModel, ParsedSchema } from '../../dmmf-parser.js'
import { analyzeModel } from '@/utils/relationship-analyzer.js'

/**
 * Generate React hooks for a model
 */
export function generateReactHooks(
  model: ParsedModel,
  schema: ParsedSchema
): string {
  const analysis = analyzeModel(model, schema)
  const modelName = model.name
  const modelLower = model.name.toLowerCase()
  const modelPlural = modelLower + 's'
  const idType = model.idField?.type === 'String' ? 'string' : 'number'
  
  const helperHooks = generateReactHelperHooks(model, analysis, idType)
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import { useQuery, useMutation, useInfiniteQuery } from '@tanstack/react-query'
import type { 
  UseQueryOptions, 
  UseMutationOptions, 
  UseInfiniteQueryOptions 
} from '@tanstack/react-query'
import { 
  ${modelLower}Queries, 
  ${modelLower}Mutations,
  ${modelLower}Infinite
} from '../../core/queries/${modelLower}-queries'
import type { 
  ${modelName}, 
  ${modelName}Create, 
  ${modelName}Update, 
  ${modelName}Query,
  ListResponse 
} from '../../types'

// ============================================
// QUERY HOOKS - Read operations
// ============================================

/**
 * Get single ${modelName} by ID
 * 
 * @example
 * \`\`\`typescript
 * const { data: ${modelLower}, isPending, isError } = use${modelName}(123)
 * 
 * if (isPending) return <Spinner />
 * return <div>{${modelLower}?.title}</div>
 * \`\`\`
 */
export function use${modelName}(
  id: ${idType},
  options?: UseQueryOptions<${modelName} | null, Error>
) {
  return useQuery({
    ...${modelLower}Queries.all.get(id),
    ...options
  })
}

/**
 * List ${modelName} records
 * 
 * @example
 * \`\`\`typescript
 * const { data, isPending } = use${modelName}s({ take: 20 })
 * 
 * return data?.data.map(item => <Card key={item.id} item={item} />)
 * \`\`\`
 */
export function use${modelName}s(
  query?: ${modelName}Query,
  options?: UseQueryOptions<ListResponse<${modelName}>, Error>
) {
  return useQuery({
    ...${modelLower}Queries.all.list(query),
    ...options
  })
}

/**
 * Infinite scroll ${modelName} records
 * 
 * @example
 * \`\`\`typescript
 * const { data, fetchNextPage, hasNextPage } = useInfinite${modelName}s()
 * 
 * return (
 *   <>
 *     {data?.pages.flatMap(page => page.data).map(item => <Card item={item} />)}
 *     {hasNextPage && <button onClick={() => fetchNextPage()}>Load More</button>}
 *   </>
 * )
 * \`\`\`
 */
export function useInfinite${modelName}s(
  query?: Omit<${modelName}Query, 'skip'>,
  options?: UseInfiniteQueryOptions<ListResponse<${modelName}>, Error>
) {
  return useInfiniteQuery({
    ...${modelLower}Infinite.list(query),
    ...options
  })
}

// ============================================
// MUTATION HOOKS - Write operations
// ============================================

/**
 * Create ${modelName} mutation
 * 
 * @example
 * \`\`\`typescript
 * const { mutate, isPending } = useCreate${modelName}({
 *   onSuccess: (${modelLower}) => toast.success('Created!'),
 *   onError: (error) => toast.error(error.message)
 * })
 * 
 * mutate({ title: 'New ${modelName}', ... })
 * \`\`\`
 */
export function useCreate${modelName}(
  options?: UseMutationOptions<${modelName}, Error, ${modelName}Create>
) {
  return useMutation({
    ...${modelLower}Mutations.create(),
    ...options
  })
}

/**
 * Update ${modelName} mutation
 * 
 * @example
 * \`\`\`typescript
 * const { mutate } = useUpdate${modelName}({
 *   onSuccess: () => toast.success('Updated!')
 * })
 * 
 * mutate({ id: 123, data: { title: 'New Title' } })
 * \`\`\`
 */
export function useUpdate${modelName}(
  options?: UseMutationOptions<${modelName} | null, Error, { id: ${idType}; data: ${modelName}Update }>
) {
  return useMutation({
    ...${modelLower}Mutations.update(),
    ...options
  })
}

/**
 * Delete ${modelName} mutation
 * 
 * @example
 * \`\`\`typescript
 * const { mutate } = useDelete${modelName}({
 *   onSuccess: () => navigate('/list')
 * })
 * 
 * mutate(123)
 * \`\`\`
 */
export function useDelete${modelName}(
  options?: UseMutationOptions<boolean, Error, ${idType}>
) {
  return useMutation({
    ...${modelLower}Mutations.delete(),
    ...options
  })
}
${helperHooks}
`
}

/**
 * Generate React hooks for helper methods
 */
function generateReactHelperHooks(
  model: ParsedModel,
  analysis: ReturnType<typeof analyzeModel>,
  idType: string
): string {
  const hooks: string[] = []
  const modelName = model.name
  const modelLower = model.name.toLowerCase()
  
  // Check if we have any helpers
  const hasHelperQueries = analysis.specialFields.slug || 
                          analysis.specialFields.published || 
                          analysis.specialFields.approved
  
  const hasHelperMutations = analysis.specialFields.published || 
                             analysis.specialFields.approved
  
  if (!hasHelperQueries && !hasHelperMutations) {
    return ''
  }
  
  hooks.push(`
// ============================================
// HELPER HOOKS - Domain-specific shortcuts
// ============================================`)
  
  // Slug lookup
  if (analysis.specialFields.slug) {
    hooks.push(`
/**
 * Get ${modelName} by slug
 * 
 * @example use${modelName}BySlug('hello-world')
 */
export function use${modelName}BySlug(
  slug: string,
  options?: UseQueryOptions<${modelName} | null, Error>
) {
  return useQuery({
    ...${modelLower}Queries.helpers.bySlug(slug),
    ...options
  })
}`)
  }
  
  // Published list
  if (analysis.specialFields.published) {
    hooks.push(`
/**
 * List published ${modelName} records
 * 
 * @example usePublished${modelName}s({ take: 10 })
 */
export function usePublished${modelName}s(
  query?: Omit<${modelName}Query, 'where'>,
  options?: UseQueryOptions<ListResponse<${modelName}>, Error>
) {
  return useQuery({
    ...${modelLower}Queries.helpers.published(query),
    ...options
  })
}`)
    
    hooks.push(`
/**
 * Publish ${modelName} mutation
 * 
 * @example usePublish${modelName}()
 */
export function usePublish${modelName}(
  options?: UseMutationOptions<${modelName} | null, Error, ${idType}>
) {
  return useMutation({
    ...${modelLower}Mutations.publish(),
    ...options
  })
}`)
    
    hooks.push(`
/**
 * Unpublish ${modelName} mutation
 * 
 * @example useUnpublish${modelName}()
 */
export function useUnpublish${modelName}(
  options?: UseMutationOptions<${modelName} | null, Error, ${idType}>
) {
  return useMutation({
    ...${modelLower}Mutations.unpublish(),
    ...options
  })
}`)
  }
  
  // Approve/reject
  if (analysis.specialFields.approved) {
    hooks.push(`
/**
 * List pending ${modelName} records
 * 
 * @example usePending${modelName}s()
 */
export function usePending${modelName}s(
  query?: Omit<${modelName}Query, 'where'>,
  options?: UseQueryOptions<ListResponse<${modelName}>, Error>
) {
  return useQuery({
    ...${modelLower}Queries.helpers.pending(query),
    ...options
  })
}`)
    
    hooks.push(`
/**
 * Approve ${modelName} mutation
 * 
 * @example useApprove${modelName}()
 */
export function useApprove${modelName}(
  options?: UseMutationOptions<${modelName} | null, Error, ${idType}>
) {
  return useMutation({
    ...${modelLower}Mutations.approve(),
    ...options
  })
}`)
    
    hooks.push(`
/**
 * Reject ${modelName} mutation
 * 
 * @example useReject${modelName}()
 */
export function useReject${modelName}(
  options?: UseMutationOptions<${modelName} | null, Error, ${idType}>
) {
  return useMutation({
    ...${modelLower}Mutations.reject(),
    ...options
  })
}`)
  }
  
  return hooks.join('\n')
}

/**
 * Generate React hooks index barrel
 */
export function generateReactHooksIndex(models: ParsedModel[], schema: ParsedSchema): string {
  const nonJunctionModels = models.filter(m => {
    const analysis = analyzeModel(m, schema)
    return !analysis.isJunctionTable
  })
  
  const exports = nonJunctionModels.map(m => {
    const modelLower = m.name.toLowerCase()
    return `export * from './models/use-${modelLower}'`
  }).join('\n')
  
  return `// @generated
// React hooks barrel export

${exports}

// Re-export provider, SDK context, and React Query utilities
export { SDKProvider, useSDK, defaultQueryClient } from './provider'
export { QueryClient, QueryClientProvider, useQueryClient } from '@tanstack/react-query'
`
}

/**
 * Generate React provider wrapper
 */
export function generateReactProvider(): string {
  return `// @generated
// React Query + SDK Context provider

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { createContext, useContext, useMemo } from 'react'
import type { ReactNode } from 'react'
import { createSDK, type SDKConfig, type SDK } from '../index'

/**
 * Default QueryClient configuration
 * Configurable via SDKProvider props
 */
export const defaultQueryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,  // 5 minutes
      retry: 1,
    },
  },
})

/**
 * SDK Context - Provides configured SDK instance to hooks
 */
const SDKContext = createContext<SDK | null>(null)

/**
 * useSDK hook - Access the configured SDK instance
 * 
 * @example
 * \`\`\`typescript
 * import { useSDK } from './gen/sdk/react'
 * 
 * function MyComponent() {
 *   const api = useSDK()
 *   
 *   const handleClick = () => {
 *     api.post.create({ title: 'Hello' })
 *   }
 *   
 *   return <button onClick={handleClick}>Create</button>
 * }
 * \`\`\`
 */
export function useSDK(): SDK {
  const context = useContext(SDKContext)
  if (!context) {
    throw new Error('useSDK must be used within SDKProvider')
  }
  return context
}

export interface SDKProviderProps {
  children: ReactNode
  /** SDK configuration - baseUrl, auth, headers, etc. */
  config: SDKConfig
  /** Custom QueryClient (optional) */
  queryClient?: QueryClient
  /** Query client default options (optional, overrides defaults) */
  queryConfig?: {
    staleTime?: number
    retry?: number | boolean
    refetchOnWindowFocus?: boolean
  }
  /** Show React Query DevTools (default: development only) */
  showDevtools?: boolean
}

/**
 * SDK Provider - Wraps app with React Query + SDK Context
 * 
 * Provides both React Query client and configured SDK instance to all hooks.
 * 
 * @example Basic
 * \`\`\`typescript
 * import { SDKProvider } from './gen/sdk/react'
 * 
 * function App() {
 *   return (
 *     <SDKProvider config={{ baseUrl: 'http://localhost:3000' }}>
 *       <YourApp />
 *     </SDKProvider>
 *   )
 * }
 * \`\`\`
 * 
 * @example With Auth
 * \`\`\`typescript
 * <SDKProvider 
 *   config={{ 
 *     baseUrl: import.meta.env.VITE_API_URL,
 *     auth: {
 *       token: () => localStorage.getItem('token'),
 *       onRefresh: (token) => localStorage.setItem('token', token)
 *     }
 *   }}
 * >
 *   <YourApp />
 * </SDKProvider>
 * \`\`\`
 * 
 * @example Custom Query Settings
 * \`\`\`typescript
 * <SDKProvider 
 *   config={{ baseUrl: 'http://localhost:3000' }}
 *   queryConfig={{
 *     staleTime: 1000 * 60 * 10,  // 10 minutes
 *     retry: 3,
 *     refetchOnWindowFocus: false
 *   }}
 * >
 *   <YourApp />
 * </SDKProvider>
 * \`\`\`
 */
export function SDKProvider({ 
  children,
  config,
  queryClient,
  queryConfig,
  showDevtools = process.env.NODE_ENV === 'development'
}: SDKProviderProps) {
  // Create SDK instance (memoized by config)
  const sdk = useMemo(() => createSDK(config), [
    config.baseUrl,
    config.timeout,
    config.retries,
    config.auth
  ])
  
  // Create or use provided QueryClient
  const client = useMemo(() => {
    if (queryClient) return queryClient
    
    return new QueryClient({
      defaultOptions: {
        queries: {
          staleTime: queryConfig?.staleTime ?? 1000 * 60 * 5,
          retry: queryConfig?.retry ?? 1,
          refetchOnWindowFocus: queryConfig?.refetchOnWindowFocus ?? true,
        },
      },
    })
  }, [queryClient, queryConfig])
  
  return (
    <SDKContext.Provider value={sdk}>
      <QueryClientProvider client={client}>
        {children}
        {showDevtools && <ReactQueryDevtools initialIsOpen={false} />}
      </QueryClientProvider>
    </SDKContext.Provider>
  )
}
`
}

/**
 * Generate React hooks README
 */
export function generateReactHooksReadme(models: ParsedModel[], schema: ParsedSchema): string {
  const nonJunctionModels = models.filter(m => {
    const analysis = analyzeModel(m, schema)
    return !analysis.isJunctionTable
  })
  
  const hookList = nonJunctionModels.map(m => {
    const modelName = m.name
    return `- \`use${modelName}(id)\` - Get one ${modelName.toLowerCase()}
- \`use${modelName}s(query?)\` - List ${modelName.toLowerCase()}s
- \`useCreate${modelName}()\` - Create ${modelName.toLowerCase()}
- \`useUpdate${modelName}()\` - Update ${modelName.toLowerCase()}
- \`useDelete${modelName}()\` - Delete ${modelName.toLowerCase()}
- \`useInfinite${modelName}s()\` - Infinite scroll`
  }).join('\n')
  
  return `# React Hooks

React Query hooks for type-safe data fetching.

## âš¡ Quick Start

### 1. Install React Query

\`\`\`bash
npm install @tanstack/react-query
\`\`\`

### 2. Wrap Your App

\`\`\`typescript
import { SDKProvider } from './gen/sdk/react'

function App() {
  return (
    <SDKProvider>
      <YourApp />
    </SDKProvider>
  )
}
\`\`\`

### 3. Use Hooks

\`\`\`typescript
import { usePosts } from './gen/sdk/react'

function PostList() {
  const { data, isPending } = usePosts({ take: 20 })
  
  if (isPending) return <div>Loading...</div>
  
  return data?.data.map(post => (
    <div key={post.id}>{post.title}</div>
  ))
}
\`\`\`

---

## ðŸ“š Available Hooks

${hookList}

---

## ðŸ’¡ Common Patterns

### Get Single Record
\`\`\`typescript
const { data: post, isPending, isError, error } = usePost(123)
\`\`\`

### List with Filtering
\`\`\`typescript
const { data } = usePosts({
  where: { published: true },
  orderBy: { createdAt: 'desc' },
  take: 20
})
\`\`\`

### Create Mutation
\`\`\`typescript
const { mutate, isPending } = useCreatePost({
  onSuccess: (post) => toast.success('Created!'),
  onError: (error) => toast.error(error.message)
})

mutate({ title: 'Hello', slug: 'hello', content: '...', authorId: 1 })
\`\`\`

### Update Mutation
\`\`\`typescript
const { mutate } = useUpdatePost({
  onSuccess: () => toast.success('Updated!')
})

mutate({ id: 123, data: { title: 'New Title' } })
\`\`\`

### Infinite Scroll
\`\`\`typescript
const { 
  data, 
  fetchNextPage, 
  hasNextPage, 
  isFetchingNextPage 
} = useInfinitePosts({ pageSize: 20 })

return (
  <>
    {data?.pages.flatMap(page => page.data).map(post => 
      <PostCard key={post.id} post={post} />
    )}
    {hasNextPage && (
      <button 
        onClick={() => fetchNextPage()}
        disabled={isFetchingNextPage}
      >
        Load More
      </button>
    )}
  </>
)
\`\`\`

---

## ðŸ”§ Advanced Patterns

### Dependent Queries
\`\`\`typescript
const { data: post } = usePost(postId)
const { data: author } = useAuthor(post?.authorId ?? 0, {
  enabled: !!post  // Only fetch when post is loaded
})
\`\`\`

### Manual Refetch
\`\`\`typescript
const { data, refetch } = usePosts()

return <button onClick={() => refetch()}>Refresh</button>
\`\`\`

### Cache Invalidation
\`\`\`typescript
import { useQueryClient } from '@tanstack/react-query'

const queryClient = useQueryClient()
const { mutate } = useCreatePost({
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['posts'] })
  }
})
\`\`\`

---

## ðŸŽ¨ Extend with Custom Hooks

All hooks are just React Query wrappers - compose them!

\`\`\`typescript
function usePublishedPostsByAuthor(authorId: number) {
  return usePosts({
    where: { published: true, authorId },
    orderBy: { createdAt: 'desc' }
  })
}

function usePostEditor(postId: number) {
  const { data: post } = usePost(postId)
  const { mutate: update } = useUpdatePost()
  const { mutate: publish } = usePublishPost()
  
  return { post, update, publish }
}
\`\`\`

---

## ðŸ“– Full React Query Documentation

All React Query features are available:
https://tanstack.com/query/latest/docs/framework/react/overview

Our hooks are thin wrappers - everything works!
`
}


