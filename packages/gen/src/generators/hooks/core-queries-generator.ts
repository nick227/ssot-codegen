/**
 * Core Queries Generator - Framework Agnostic
 * 
 * Generates pure query/mutation definitions that ANY framework can use
 */

import type { ParsedModel, ParsedSchema } from '../../dmmf-parser.js'
import type { ModelAnalysis } from '../../utils/relationship-analyzer.js'
import { analyzeModel } from '../../utils/relationship-analyzer.js'

/**
 * Generate core queries for a model (framework-agnostic)
 * OPTIMIZED: Accepts pre-computed analysis from cache
 */
export function generateCoreQueries(
  model: ParsedModel,
  schema: ParsedSchema,
  analysis: ModelAnalysis  // â­ Accept cached analysis
): string {
  // Remove: const analysis = analyzeModel(model, schema)
  const modelName = model.name
  const modelLower = model.nameLower  // Use cached lowercase name
  const idType = model.idField?.type === 'String' ? 'string' : 'number'
  
  const helperQueries = generateHelperQueries(model, analysis)
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import type { 
  ${modelName}, 
  ${modelName}Create, 
  ${modelName}Update, 
  ${modelName}Query,
  ListResponse 
} from '../../types'
import { createSDK } from '../../index'

// Create SDK instance for queries (developers can configure this)
const api = createSDK({ baseUrl: typeof window !== 'undefined' ? window.location.origin : 'http://localhost:3000' })

/**
 * ${modelName} query definitions (framework-agnostic)
 * 
 * These are pure data structures that define WHAT to fetch.
 * Framework adapters (React, Vue, etc.) wrap these with their patterns.
 */
export const ${modelLower}Queries = {
  /**
   * Core queries - Standard CRUD operations
   */
  all: {
    /**
     * Get single ${modelName} by ID
     */
    get: (id: ${idType}) => ({
      queryKey: ['${modelLower}', id] as const,
      queryFn: async (): Promise<${modelName} | null> => api.${modelLower}.get(id)
    }),
    
    /**
     * List ${modelName} records
     */
    list: (query?: ${modelName}Query) => ({
      queryKey: ['${modelLower}s', query] as const,
      queryFn: async (): Promise<ListResponse<${modelName}>> => api.${modelLower}.list(query)
    }),
    
    /**
     * Find ${modelName} by any field
     */
    findOne: (where: Partial<${modelName}>) => ({
      queryKey: ['${modelLower}', 'query', where] as const,
      queryFn: async (): Promise<${modelName} | null> => api.${modelLower}.findOne(where)
    }),
    
    /**
     * Count ${modelName} records
     */
    count: (query?: Pick<${modelName}Query, 'where'>) => ({
      queryKey: ['${modelLower}s', 'count', query] as const,
      queryFn: async (): Promise<number> => api.${modelLower}.count(query)
    })
  }${helperQueries}
}

/**
 * ${modelName} mutation definitions (framework-agnostic)
 */
export const ${modelLower}Mutations = {
  /**
   * Create ${modelName}
   */
  create: () => ({
    mutationKey: ['${modelLower}', 'create'] as const,
    mutationFn: async (data: ${modelName}Create): Promise<${modelName}> => 
      api.${modelLower}.create(data)
  }),
  
  /**
   * Update ${modelName}
   */
  update: () => ({
    mutationKey: ['${modelLower}', 'update'] as const,
    mutationFn: async ({ id, data }: { id: ${idType}; data: ${modelName}Update }): Promise<${modelName} | null> => 
      api.${modelLower}.update(id, data)
  }),
  
  /**
   * Delete ${modelName}
   */
  delete: () => ({
    mutationKey: ['${modelLower}', 'delete'] as const,
    mutationFn: async (id: ${idType}): Promise<boolean> => 
      api.${modelLower}.delete(id)
  })${generateHelperMutations(model, analysis)}
}

/**
 * ${modelName} infinite query definition
 */
export const ${modelLower}Infinite = {
  /**
   * Infinite scroll ${modelName} list
   */
  list: (query?: Omit<${modelName}Query, 'skip'>) => {
    const pageSize = query?.take || 20
    
    return {
      queryKey: ['${modelLower}s', 'infinite', query] as const,
      queryFn: async (context: { pageParam: number }) => {
        const page = context.pageParam || 0
        return api.${modelLower}.list({
          ...query,
          skip: page * pageSize,
          take: pageSize
        })
      },
      getNextPageParam: (lastPage: ListResponse<${modelName}>, allPages: any[]) =>
        lastPage.meta.hasMore ? allPages.length : undefined,
      initialPageParam: 0
    }
  }
}
`
}

/**
 * Generate helper queries from model analysis
 */
function generateHelperQueries(
  model: ParsedModel,
  analysis: ModelAnalysis
): string {
  const helpers: string[] = []
  const modelName = model.name
  const modelLower = model.name.toLowerCase()
  
  // Slug lookup
  if (analysis.specialFields.slug) {
    helpers.push(`    /**
     * Find ${modelName} by slug
     */
    bySlug: (slug: string) => ({
      queryKey: ['${modelLower}', 'slug', slug] as const,
      queryFn: async (): Promise<${modelName} | null> => 
        api.${modelLower}.helpers.findBySlug(slug)
    })`)
  }
  
  // Published filtering
  if (analysis.specialFields.published) {
    helpers.push(`    /**
     * List published ${modelName} records
     */
    published: (query?: Omit<${modelName}Query, 'where'>) => ({
      queryKey: ['${modelLower}s', 'published', query] as const,
      queryFn: async (): Promise<ListResponse<${modelName}>> => 
        api.${modelLower}.helpers.listPublished(query)
    })`)
  }
  
  // Approved/pending filtering
  if (analysis.specialFields.approved) {
    helpers.push(`    /**
     * List pending ${modelName} records
     */
    pending: (query?: Omit<${modelName}Query, 'where'>) => ({
      queryKey: ['${modelLower}s', 'pending', query] as const,
      queryFn: async (): Promise<ListResponse<${modelName}>> => 
        api.${modelLower}.helpers.listPending(query)
    })`)
  }
  
  if (helpers.length === 0) {
    return ''
  }
  
  return `,
  
  /**
   * Helper queries - Domain-specific operations
   */
  helpers: {
${helpers.join(',\n\n')}
  }`
}

/**
 * Generate helper mutations from model analysis
 */
function generateHelperMutations(
  model: ParsedModel,
  analysis: ModelAnalysis
): string {
  const helpers: string[] = []
  const modelName = model.name
  const modelLower = model.name.toLowerCase()
  const idType = model.idField?.type === 'String' ? 'string' : 'number'
  
  // Publish/unpublish
  if (analysis.specialFields.published) {
    helpers.push(`  /**
   * Publish ${modelName}
   */
  publish: () => ({
    mutationKey: ['${modelLower}', 'publish'] as const,
    mutationFn: async (id: ${idType}): Promise<${modelName} | null> => 
      api.${modelLower}.helpers.publish(id)
  })`)
  
    helpers.push(`  /**
   * Unpublish ${modelName}
   */
  unpublish: () => ({
    mutationKey: ['${modelLower}', 'unpublish'] as const,
    mutationFn: async (id: ${idType}): Promise<${modelName} | null> => 
      api.${modelLower}.helpers.unpublish(id)
  })`)
  }
  
  // Approve/reject
  if (analysis.specialFields.approved) {
    helpers.push(`  /**
   * Approve ${modelName}
   */
  approve: () => ({
    mutationKey: ['${modelLower}', 'approve'] as const,
    mutationFn: async (id: ${idType}): Promise<${modelName} | null> => 
      api.${modelLower}.helpers.approve(id)
  })`)
  
    helpers.push(`  /**
   * Reject ${modelName}
   */
  reject: () => ({
    mutationKey: ['${modelLower}', 'reject'] as const,
    mutationFn: async (id: ${idType}): Promise<${modelName} | null> => 
      api.${modelLower}.helpers.reject(id)
  })`)
  }
  
  if (helpers.length === 0) {
    return ''
  }
  
  return `,\n  \n  // Helper mutations\n${helpers.join(',\n  \n')}`
}

/**
 * Generate core queries index barrel
 */
export function generateCoreQueriesIndex(models: ParsedModel[], schema: ParsedSchema): string {
  // Filter out junction tables (analyzeModel needed for this helper function)
  const nonJunctionModels = models.filter(m => {
    const analysis = analyzeModel(m, schema)
    return !analysis.isJunctionTable
  })
  
  const exports = nonJunctionModels.map(m => {
    const modelLower = m.name.toLowerCase()
    return `export * from './${modelLower}-queries'`
  }).join('\n')
  
  return `// @generated
// Core queries barrel export

${exports}
`
}


