/**
 * Core Queries Generator - Framework Agnostic
 * 
 * Generates pure query/mutation definitions that ANY framework can use
 */

import type { ParsedModel, ParsedSchema } from '../../dmmf-parser.js'
import type { ModelAnalysis } from '@/utils/relationship-analyzer.js'
import { analyzeModel } from '@/utils/relationship-analyzer.js'

/**
 * Generate core queries for a model (framework-agnostic)
 * OPTIMIZED: Accepts pre-computed analysis from cache
 */
export function generateCoreQueries(
  model: ParsedModel,
  schema: ParsedSchema,
  analysis: ModelAnalysis  // â­ Accept cached analysis
): string {
  // Remove: const analysis = analyzeModel(model, schema)
  const modelName = model.name
  const modelLower = model.nameLower  // Use cached lowercase name
  const idType = model.idField?.type === 'String' ? 'string' : 'number'
  
  const helperQueries = generateHelperQueries(model, analysis)
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import type { 
  ${modelName}, 
  ${modelName}Create, 
  ${modelName}Update, 
  ${modelName}Query,
  ListResponse 
} from '../../types'
import type { SDK } from '../../index'
import { stableKey } from './shared/query-helpers'

/**
 * ${modelName} query factory - accepts API client for flexibility
 * 
 * These are pure query definitions that work with ANY SDK instance.
 * Inject your configured client via factory pattern.
 */
export function create${modelName}Queries(api: SDK) {
  return {
    /**
     * Core queries - Standard CRUD operations
     */
    all: {
      /**
       * Get single ${modelName} by ID
       */
      get: (id: ${idType}) => ({
        queryKey: stableKey('${modelLower}', id),
        queryFn: async (): Promise<${modelName} | null> => {
          const result = await api.${modelLower}.get(id)
          return result || null
        }
      }),
      
      /**
       * List ${modelName} records
       */
      list: (query?: ${modelName}Query) => ({
        queryKey: stableKey('${modelLower}s', query),
        queryFn: async (): Promise<ListResponse<${modelName}>> => {
          const result = await api.${modelLower}.list(query)
          return result || { data: [], meta: { total: 0, skip: 0, take: 20, hasMore: false } }
        }
      }),
      
      /**
       * Find ${modelName} by any field
       */
      findOne: (where: Partial<${modelName}>) => ({
        queryKey: ['${modelLower}', 'query', JSON.stringify(where)],
        queryFn: async (): Promise<${modelName} | null> => {
          const result = await api.${modelLower}.findOne(where)
          return result || null
        }
      }),
      
      /**
       * Count ${modelName} records
       */
      count: (query?: Pick<${modelName}Query, 'where'>) => ({
        queryKey: stableKey('${modelLower}s:count', query),
        queryFn: async (): Promise<number> => {
          const result = await api.${modelLower}.count(query as Partial<${modelName}Query>)
          return result || 0
        }
      })
    }${helperQueries}
  }
}

/**
 * ${modelName} mutation factory - accepts API client
 */
export function create${modelName}Mutations(api: SDK) {
  return {
    /**
     * Create ${modelName}
     */
    create: () => ({
      mutationKey: ['${modelLower}', 'create'] as const,
      mutationFn: async (data: ${modelName}Create): Promise<${modelName}> => 
        api.${modelLower}.create(data)
    }),
    
    /**
     * Update ${modelName}
     */
    update: () => ({
      mutationKey: ['${modelLower}', 'update'] as const,
      mutationFn: async ({ id, data }: { id: ${idType}; data: ${modelName}Update }): Promise<${modelName} | null> => 
        api.${modelLower}.update(id, data)
    }),
    
    /**
     * Delete ${modelName}
     */
    delete: () => ({
      mutationKey: ['${modelLower}', 'delete'] as const,
      mutationFn: async (id: ${idType}): Promise<boolean> => 
        api.${modelLower}.delete(id)
    })${generateHelperMutations(model, analysis)}
  }
}

/**
 * ${modelName} infinite query factory - accepts API client
 */
export function create${modelName}Infinite(api: SDK) {
  return {
    /**
     * Infinite scroll ${modelName} list
     */
    list: (query?: Omit<${modelName}Query, 'skip'>) => {
      const pageSize = query?.take || 20
      
      return {
        queryKey: stableKey('${modelLower}s:infinite', query),
        queryFn: async (context: { pageParam: number }) => {
          const page = context.pageParam || 0
          return api.${modelLower}.list({
            ...query,
            skip: page * pageSize,
            take: pageSize
          })
        },
        getNextPageParam: (lastPage: ListResponse<${modelName}>, allPages: any[]) =>
          lastPage.meta.hasMore ? allPages.length : undefined,
        initialPageParam: 0
      }
    }
  }
}
`
}

/**
 * Generate helper queries from model analysis
 */
function generateHelperQueries(
  model: ParsedModel,
  analysis: ModelAnalysis
): string {
  const helpers: string[] = []
  const modelName = model.name
  const modelLower = model.name.toLowerCase()
  
  // Slug lookup
  if (analysis.specialFields.slug) {
    helpers.push(`    /**
     * Find ${modelName} by slug
     */
    bySlug: (slug: string) => ({
      queryKey: ['${modelLower}', 'slug', slug],
      queryFn: async (): Promise<${modelName} | null> => 
        api.${modelLower}.helpers?.findBySlug(slug)
    })`)
  }
  
  // Published filtering
  if (analysis.specialFields.published) {
    helpers.push(`    /**
     * List published ${modelName} records
     */
    published: (query?: Omit<${modelName}Query, 'where'>) => ({
      queryKey: stableKey('${modelLower}s:published', query),
      queryFn: async (): Promise<ListResponse<${modelName}>> => 
        api.${modelLower}.helpers?.listPublished(query)
    })`)
  }
  
  // Approved/pending filtering
  if (analysis.specialFields.approved) {
    helpers.push(`    /**
     * List pending ${modelName} records
     */
    pending: (query?: Omit<${modelName}Query, 'where'>) => ({
      queryKey: stableKey('${modelLower}s:pending', query),
      queryFn: async (): Promise<ListResponse<${modelName}>> => 
        api.${modelLower}.helpers?.listPending(query)
    })`)
  }
  
  if (helpers.length === 0) {
    return ''
  }
  
  return `,
  
  /**
   * Helper queries - Domain-specific operations
   */
  helpers: {
${helpers.join(',\n\n')}
  }`
}

/**
 * Generate helper mutations from model analysis
 */
function generateHelperMutations(
  model: ParsedModel,
  analysis: ModelAnalysis
): string {
  const helpers: string[] = []
  const modelName = model.name
  const modelLower = model.name.toLowerCase()
  const idType = model.idField?.type === 'String' ? 'string' : 'number'
  
  // Publish/unpublish
  if (analysis.specialFields.published) {
    helpers.push(`  /**
   * Publish ${modelName}
   */
  publish: () => ({
    mutationKey: ['${modelLower}', 'publish'] as const,
    mutationFn: async (id: ${idType}): Promise<${modelName} | null> => 
      api.${modelLower}.helpers?.publish(id)
  })`)
  
    helpers.push(`  /**
   * Unpublish ${modelName}
   */
  unpublish: () => ({
    mutationKey: ['${modelLower}', 'unpublish'] as const,
    mutationFn: async (id: ${idType}): Promise<${modelName} | null> => 
      api.${modelLower}.helpers?.unpublish(id)
  })`)
  }
  
  // Approve/reject
  if (analysis.specialFields.approved) {
    helpers.push(`  /**
   * Approve ${modelName}
   */
  approve: () => ({
    mutationKey: ['${modelLower}', 'approve'] as const,
    mutationFn: async (id: ${idType}): Promise<${modelName} | null> => 
      api.${modelLower}.helpers?.approve(id)
  })`)
  
    helpers.push(`  /**
   * Reject ${modelName}
   */
  reject: () => ({
    mutationKey: ['${modelLower}', 'reject'] as const,
    mutationFn: async (id: ${idType}): Promise<${modelName} | null> => 
      api.${modelLower}.helpers?.reject(id)
  })`)
  }
  
  if (helpers.length === 0) {
    return ''
  }
  
  return `,\n  \n  // Helper mutations\n${helpers.join(',\n  \n')}`
}

/**
 * Generate core queries index barrel
 */
export function generateCoreQueriesIndex(models: readonly ParsedModel[], schema: ParsedSchema): string {
  // Filter out junction tables (analyzeModel needed for this helper function)
  const nonJunctionModels = models.filter(m => {
    const analysis = analyzeModel(m, schema)
    return !analysis.isJunctionTable
  })
  
  const exports = nonJunctionModels.map(m => {
    const modelLower = m.name.toLowerCase()
    return `export * from './${modelLower}-queries'`
  }).join('\n')
  
  return `// @generated
// Core queries barrel export

${exports}
`
}

/**
 * Generate shared query helpers file
 */
export function generateQueryHelpers(): string {
  return `// @generated
// This file is automatically generated. Do not edit manually.

/**
 * Stable cache key generator
 * Serializes objects to ensure React Query cache keys are stable
 * 
 * @example
 * stableKey('users', { take: 20 }) // ['users', '{"take":20}']
 * stableKey('user', '123') // ['user', '123']
 * stableKey('users') // ['users']
 */
export function stableKey(key: string, data?: any): any[] {
  if (data === undefined || data === null) return [key]
  if (typeof data === 'object') return [key, JSON.stringify(data)]
  return [key, data]
}
`
}


