/**
 * SDK Generator - Generates type-safe client SDK for frontend
 */

import type { ParsedModel, ParsedSchema } from '../dmmf-parser.js'
import { analyzeModel } from '../utils/relationship-analyzer.js'

/**
 * Generate SDK client for a single model
 */
export function generateModelSDK(
  model: ParsedModel,
  schema: ParsedSchema
): string {
  const analysis = analyzeModel(model, schema)
  const modelLower = model.name.toLowerCase()
  const idType = model.idField?.type === 'String' ? 'string' : 'number'
  
  const domainMethods = generateSDKDomainMethods(model, analysis, idType)
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import type {
  ${model.name}CreateDTO,
  ${model.name}UpdateDTO,
  ${model.name}ReadDTO,
  ${model.name}QueryDTO
} from '@gen/contracts/${modelLower}'
import { BaseModelClient, type ListResponse } from '@ssot-codegen/sdk-runtime'
import type { BaseAPIClient, QueryOptions } from '@ssot-codegen/sdk-runtime'

/**
 * ${model.name} SDK Client
 * Type-safe client for ${model.name} operations
 */
export class ${model.name}Client extends BaseModelClient<
  ${model.name}ReadDTO,
  ${model.name}CreateDTO,
  ${model.name}UpdateDTO,
  ${model.name}QueryDTO
> {
  constructor(client: BaseAPIClient) {
    super(client, '/api/${modelLower}s')
  }
${domainMethods}
}
`
}

/**
 * Generate domain-specific SDK methods
 */
function generateSDKDomainMethods(
  model: ParsedModel,
  analysis: ReturnType<typeof analyzeModel>,
  idType: string
): string {
  const methods: string[] = []
  const modelLower = model.name.toLowerCase()

  // Slug lookup
  if (analysis.specialFields.slug) {
    methods.push(`
  /**
   * Find ${model.name} by slug
   */
  async findBySlug(slug: string, options?: QueryOptions): Promise<${model.name}ReadDTO | null> {
    try {
      const response = await this.client.get<${model.name}ReadDTO>(
        \`\${this.basePath}/slug/\${slug}\`,
        { signal: options?.signal }
      )
      return response.data
    } catch (error) {
      if (error instanceof Error && 'status' in error && (error as any).status === 404) {
        return null
      }
      throw error
    }
  }`)
  }

  // Published filtering
  if (analysis.specialFields.published) {
    methods.push(`
  /**
   * List published ${model.name} records
   */
  async listPublished(query?: ${model.name}QueryDTO, options?: QueryOptions): Promise<ListResponse<${model.name}ReadDTO>> {
    return this.list({ ...query, where: { ...query?.where, published: true } as any }, options)
  }

  /**
   * Publish ${model.name}
   */
  async publish(id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> {
    try {
      const response = await this.client.post<${model.name}ReadDTO>(
        \`\${this.basePath}/\${id}/publish\`,
        undefined,
        { signal: options?.signal }
      )
      return response.data
    } catch (error) {
      if (error instanceof Error && 'status' in error && (error as any).status === 404) {
        return null
      }
      throw error
    }
  }

  /**
   * Unpublish ${model.name}
   */
  async unpublish(id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> {
    try {
      const response = await this.client.post<${model.name}ReadDTO>(
        \`\${this.basePath}/\${id}/unpublish\`,
        undefined,
        { signal: options?.signal }
      )
      return response.data
    } catch (error) {
      if (error instanceof Error && 'status' in error && (error as any).status === 404) {
        return null
      }
      throw error
    }
  }`)
  }

  // View counter
  if (analysis.specialFields.views) {
    methods.push(`
  /**
   * Increment ${model.name} views
   */
  async incrementViews(id: ${idType}, options?: QueryOptions): Promise<void> {
    await this.client.post<void>(
      \`\${this.basePath}/\${id}/views\`,
      undefined,
      { signal: options?.signal }
    )
  }`)
  }

  // Approval workflow
  if (analysis.specialFields.approved) {
    methods.push(`
  /**
   * Approve ${model.name}
   */
  async approve(id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> {
    try {
      const response = await this.client.post<${model.name}ReadDTO>(
        \`\${this.basePath}/\${id}/approve\`,
        undefined,
        { signal: options?.signal }
      )
      return response.data
    } catch (error) {
      if (error instanceof Error && 'status' in error && (error as any).status === 404) {
        return null
      }
      throw error
    }
  }

  /**
   * Reject ${model.name}
   */
  async reject(id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> {
    try {
      const response = await this.client.post<${model.name}ReadDTO>(
        \`\${this.basePath}/\${id}/reject\`,
        undefined,
        { signal: options?.signal }
      )
      return response.data
    } catch (error) {
      if (error instanceof Error && 'status' in error && (error as any).status === 404) {
        return null
      }
      throw error
    }
  }`)
  }

  // Soft delete
  if (analysis.specialFields.deletedAt) {
    methods.push(`
  /**
   * Soft delete ${model.name}
   */
  async softDelete(id: ${idType}, options?: QueryOptions): Promise<void> {
    await this.client.post<void>(
      \`\${this.basePath}/\${id}/soft-delete\`,
      undefined,
      { signal: options?.signal }
    )
  }

  /**
   * Restore soft-deleted ${model.name}
   */
  async restore(id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> {
    try {
      const response = await this.client.post<${model.name}ReadDTO>(
        \`\${this.basePath}/\${id}/restore\`,
        undefined,
        { signal: options?.signal }
      )
      return response.data
    } catch (error) {
      if (error instanceof Error && 'status' in error && (error as any).status === 404) {
        return null
      }
      throw error
    }
  }`)
  }

  // Threading
  if (analysis.specialFields.parentId) {
    methods.push(`
  /**
   * Get ${model.name} thread (with replies)
   */
  async getThread(id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> {
    try {
      const response = await this.client.get<${model.name}ReadDTO>(
        \`\${this.basePath}/\${id}/thread\`,
        { signal: options?.signal }
      )
      return response.data
    } catch (error) {
      if (error instanceof Error && 'status' in error && (error as any).status === 404) {
        return null
      }
      throw error
    }
  }`)
  }

  return methods.length > 0 ? methods.join('\n') : ''
}

/**
 * Generate main SDK factory
 */
export function generateMainSDK(models: ParsedModel[], schema: ParsedSchema): string {
  // Filter out junction tables
  const nonJunctionModels = models.filter(m => {
    const analysis = analyzeModel(m, schema)
    return !analysis.isJunctionTable
  })
  
  const imports = nonJunctionModels.map(m =>
    `import { ${m.name}Client } from './models/${m.name.toLowerCase()}.client.js'`
  ).join('\n')

  const properties = nonJunctionModels.map(m => {
    const lower = m.name.toLowerCase()
    return `    ${lower}: new ${m.name}Client(client)`
  }).join(',\n')

  const exportTypes = nonJunctionModels.map(m => {
    const lower = m.name.toLowerCase()
    return `  ${lower}: ${m.name}Client`
  }).join('\n')

  return `// @generated
// This file is automatically generated. Do not edit manually.

import { BaseAPIClient, createAuthInterceptor, type RequestConfig } from '@ssot-codegen/sdk-runtime'
${imports}

export interface SDKConfig {
  baseUrl: string
  auth?: {
    token?: string | (() => string | Promise<string>)
    refreshToken?: string | (() => string | Promise<string>)
    onRefresh?: (newToken: string) => void | Promise<void>
    header?: string
    scheme?: string
  }
  timeout?: number
  retries?: number
  headers?: Record<string, string>
  onRequest?: (init: RequestInit) => Promise<RequestInit> | RequestInit
  onResponse?: (response: Response) => Promise<Response> | Response
  onError?: (error: any) => Promise<void> | void
}

/**
 * Create type-safe SDK client
 * 
 * @example
 * \`\`\`typescript
 * const api = createSDK({
 *   baseUrl: 'http://localhost:3000',
 *   auth: { token: () => localStorage.getItem('jwt') }
 * })
 * 
 * const posts = await api.posts.list({ skip: 0, take: 20 })
 * const post = await api.posts.get(123)
 * \`\`\`
 */
export function createSDK(config: SDKConfig) {
  // Create base client
  const client = new BaseAPIClient({
    baseUrl: config.baseUrl,
    timeout: config.timeout,
    retries: config.retries,
    headers: config.headers,
    onRequest: config.auth
      ? createAuthInterceptor(config.auth)
      : config.onRequest,
    onResponse: config.onResponse,
    onError: config.onError
  })

  // Return model clients
  return {
${properties}
  }
}

/**
 * SDK type (for type annotations)
 */
export interface SDK {
${exportTypes}
}

// Export for convenience
export type { SDKConfig }
`
}

/**
 * Generate SDK version file with manifest hash
 */
export function generateSDKVersion(schemaHash: string, toolVersion: string): string {
  return `// @generated
// This file is automatically generated. Do not edit manually.

/**
 * Schema hash for version checking
 * Regenerate SDK if backend schema hash differs
 */
export const SCHEMA_HASH = '${schemaHash}'

/**
 * Generator tool version
 */
export const TOOL_VERSION = '${toolVersion}'

/**
 * Check if SDK version matches backend
 */
export function checkVersion(backendHash: string): {
  compatible: boolean
  message?: string
} {
  if (backendHash === SCHEMA_HASH) {
    return { compatible: true }
  }
  
  return {
    compatible: false,
    message: \`SDK version mismatch. SDK: \${SCHEMA_HASH.slice(0, 8)}, Backend: \${backendHash.slice(0, 8)}. Please regenerate SDK.\`
  }
}
`
}

