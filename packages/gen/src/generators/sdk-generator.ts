/**
 * SDK Generator - Generates type-safe client SDK for frontend
 */

import type { ParsedModel, ParsedSchema } from '../dmmf-parser.js'
import { analyzeModel } from '@/utils/relationship-analyzer.js'
import { getModelRoutePath, getDefaultBaseUrl } from '@/utils/integration-helpers.js'

/**
 * Generate SDK client for a single model - THIN FACADE PATTERN
 */
export function generateModelSDK(
  model: ParsedModel,
  schema: ParsedSchema
): string {
  const analysis = analyzeModel(model, schema)
  const modelLower = model.name.toLowerCase()
  const idType = model.idField?.type === 'String' ? 'string' : 'number'
  
  const helpers = generateSDKHelpers(model, analysis, idType)
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import type {
  ${model.name}CreateDTO,
  ${model.name}UpdateDTO,
  ${model.name}ReadDTO,
  ${model.name}QueryDTO
} from '@/contracts/${modelLower}/index.js'
import { BaseModelClient, type ListResponse } from '@ssot-codegen/sdk-runtime'
import type { BaseAPIClient, QueryOptions } from '@ssot-codegen/sdk-runtime'

/**
 * ${model.name} SDK Client - Thin Facade Pattern
 * 
 * Core CRUD Methods (work on ALL models):
 * - list(query?)              Get multiple records with filtering/pagination
 * - get(id)                   Get one by ID
 * - create(data)              Create new record
 * - update(id, data)          Update existing record
 * - delete(id)                Remove record
 * - findOne(where)            Find by any field
 * - count(query?)             Count records with optional filter
 * 
 * Bulk Operations:
 * - createMany(data[])        Create multiple records at once
 * - updateMany(where, data)   Update all matching records
 * - deleteMany(where)         Delete all matching records
 * 
 * File Operations:
 * - upload(formData)          Upload single file with metadata
 * - uploadMany(formData)      Upload multiple files
 * 
 * Plus optional domain shortcuts in .helpers namespace
 * 
 * @example Basic Usage
 * \`\`\`typescript
 * const posts = await api.post.list({ take: 20, orderBy: { createdAt: 'desc' } })
 * const post = await api.post.get(123)
 * const bySlug = await api.post.findOne({ slug: 'hello' })
 * \`\`\`
 * 
 * @example Complex Queries
 * \`\`\`typescript
 * // Arrays and operators
 * const posts = await api.post.list({
 *   where: {
 *     status: { in: ['PUBLISHED', 'FEATURED'] },
 *     title: { contains: 'TypeScript' }
 *   }
 * })
 * 
 * // Multiple orderBy
 * const sorted = await api.post.list({
 *   orderBy: { createdAt: 'desc', title: 'asc' }
 * })
 * \`\`\`
 * 
 * @example Bulk Operations
 * \`\`\`typescript
 * // Create many
 * const posts = await api.post.createMany([
 *   { title: 'Post 1', content: '...' },
 *   { title: 'Post 2', content: '...' }
 * ])
 * 
 * // Update many
 * const result = await api.post.updateMany(
 *   { status: 'DRAFT' },
 *   { status: 'PUBLISHED' }
 * )
 * console.log(\`Updated \${result.count} posts\`)
 * \`\`\`
 * 
 * @example File Upload
 * \`\`\`typescript
 * const formData = new FormData()
 * formData.append('file', fileBlob, 'image.jpg')
 * formData.append('title', 'My Image')
 * const uploaded = await api.image.upload(formData)
 * \`\`\`
 */
export class ${model.name}Client extends BaseModelClient<
  ${model.name}ReadDTO,
  ${model.name}CreateDTO,
  ${model.name}UpdateDTO,
  ${model.name}QueryDTO
> {
  constructor(client: BaseAPIClient) {
    super(client, '${getModelRoutePath(model.name)}')
  }

  // ============================================
  // All methods inherited from BaseModelClient
  // See class documentation above for full list
  // ============================================
${helpers}
}
`
}

/**
 * Generate SDK helpers namespace - THIN FACADE PATTERN
 * 
 * Helpers are optional domain shortcuts that use core methods
 */
function generateSDKHelpers(
  model: ParsedModel,
  analysis: ReturnType<typeof analyzeModel>,
  idType: string
): string {
  const methods: string[] = []
  const modelLower = model.name.toLowerCase()

  // Slug lookup helper
  if (analysis.specialFields.slug) {
    methods.push(`    /**
     * Find ${model.name} by slug (sugar over findOne)
     * 
     * @example api.${modelLower}.helpers.findBySlug('hello-world')
     */
    findBySlug: async (slug: string, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.findOne({ slug } as Partial<${model.name}ReadDTO>, options)
    }`)
  }

  // Published filtering helpers
  if (analysis.specialFields.published) {
    methods.push(`    /**
     * List published ${model.name} records (sugar over list with where filter)
     * 
     * @example api.${modelLower}.helpers.listPublished({ take: 10 })
     */
    listPublished: async (query?: Omit<${model.name}QueryDTO, 'where'>, options?: QueryOptions): Promise<ListResponse<${model.name}ReadDTO>> => {
      return this.list({ ...query, where: { published: true } } as ${model.name}QueryDTO, options)
    }`)

    methods.push(`    /**
     * Publish ${model.name} (sugar over update)
     * 
     * @example api.${modelLower}.helpers.publish(123)
     */
    publish: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.update(id, { published: true } as Partial<${model.name}UpdateDTO>, options)
    }`)

    methods.push(`    /**
     * Unpublish ${model.name} (sugar over update)
     * 
     * @example api.${modelLower}.helpers.unpublish(123)
     */
    unpublish: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.update(id, { published: false } as Partial<${model.name}UpdateDTO>, options)
    }`)
  }

  // View counter helper
  if (analysis.specialFields.views) {
    methods.push(`    /**
     * Increment ${model.name} views (custom endpoint)
     * 
     * @example api.${modelLower}.helpers.incrementViews(123)
     */
    incrementViews: async (id: ${idType}, options?: QueryOptions): Promise<void> => {
      await this.client.post<void>(
        \`\${this.basePath}/\${id}/views\`,
        undefined,
        { signal: options?.signal }
      )
    }`)
  }

  // Approval workflow helpers
  if (analysis.specialFields.approved) {
    methods.push(`    /**
     * Approve ${model.name} (sugar over update)
     * 
     * @example api.${modelLower}.helpers.approve(456)
     */
    approve: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.update(id, { approved: true } as Partial<${model.name}UpdateDTO>, options)
    }`)

    methods.push(`    /**
     * Reject ${model.name} (sugar over update)
     * 
     * @example api.${modelLower}.helpers.reject(456)
     */
    reject: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.update(id, { approved: false } as Partial<${model.name}UpdateDTO>, options)
    }`)
    
    methods.push(`    /**
     * List pending ${model.name} records (sugar over list with where filter)
     * 
     * @example api.${modelLower}.helpers.listPending()
     */
    listPending: async (query?: Omit<${model.name}QueryDTO, 'where'>, options?: QueryOptions): Promise<ListResponse<${model.name}ReadDTO>> => {
      return this.list({ ...query, where: { approved: false } } as ${model.name}QueryDTO, options)
    }`)
  }

  // Soft delete helpers
  if (analysis.specialFields.deletedAt) {
    methods.push(`    /**
     * Soft delete ${model.name} (sugar over update)
     * 
     * @example api.${modelLower}.helpers.softDelete(123)
     */
    softDelete: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.update(id, { deletedAt: new Date() } as Partial<${model.name}UpdateDTO>, options)
    }`)

    methods.push(`    /**
     * Restore soft-deleted ${model.name} (sugar over update)
     * 
     * @example api.${modelLower}.helpers.restore(123)
     */
    restore: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.update(id, { deletedAt: null } as Partial<${model.name}UpdateDTO>, options)
    }`)
  }

  // Threading helper
  if (analysis.specialFields.parentId) {
    methods.push(`    /**
     * Get ${model.name} thread with replies (custom endpoint)
     * 
     * @example api.${modelLower}.helpers.getThread(456)
     */
    getThread: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      try {
        const response = await this.client.get<${model.name}ReadDTO>(
          \`\${this.basePath}/\${id}/thread\`,
          { signal: options?.signal }
        )
        return response.data
      } catch (error) {
        // APIException from sdk-runtime has status property
        if (error && typeof error === 'object' && 'status' in error && (error as { status: number }).status === 404) {
          return null
        }
        throw error
      }
    }`)
  }

  // If no helpers, return empty string
  if (methods.length === 0) {
    return ''
  }

  // Return helpers namespace
  return `
  /**
   * Domain-specific helper methods
   * These are optional shortcuts over core methods
   */
  helpers = {
${methods.join(',\n\n')}
  }`
}

/**
 * Generate main SDK factory
 */
export function generateMainSDK(models: readonly ParsedModel[], schema: ParsedSchema): string {
  // Filter out junction tables
  const nonJunctionModels = models.filter(m => {
    const analysis = analyzeModel(m, schema)
    return !analysis.isJunctionTable
  })
  
  const imports = nonJunctionModels.map(m =>
    `import { ${m.name}Client } from './models/${m.name.toLowerCase()}.client.js'`
  ).join('\n')

  const properties = nonJunctionModels.map(m => {
    const lower = m.name.toLowerCase()
    return `    ${lower}: new ${m.name}Client(client)`
  }).join(',\n')

  const exportTypes = nonJunctionModels.map(m => {
    const lower = m.name.toLowerCase()
    return `  ${lower}: ${m.name}Client`
  }).join('\n')

  return `// @generated
// This file is automatically generated. Do not edit manually.

import { BaseAPIClient, createAuthInterceptor, type RequestConfig, type APIError } from '@ssot-codegen/sdk-runtime'
${imports}

/**
 * Get environment-aware default base URL
 * 
 * Automatically detects:
 * - Browser: Uses window.location.origin
 * - Node.js: Checks environment variables
 * - Fallback: localhost:3000
 */
function getDefaultBaseUrl(): string {
  // Browser environment - check for window object
  // @ts-ignore - window is not defined in Node.js but exists in browser
  if (typeof window !== 'undefined' && window?.location) {
    // @ts-ignore
    return window.location.origin
  }
  
  // Node.js environment - check common env vars
  if (typeof process !== 'undefined' && process.env) {
    return process.env.API_URL || 
           process.env.VITE_API_URL || 
           process.env.NEXT_PUBLIC_API_URL ||
           process.env.REACT_APP_API_URL ||
           'http://localhost:3000'
  }
  
  // Fallback
  return 'http://localhost:3000'
}

export interface SDKConfig {
  baseUrl?: string
  auth?: {
    token?: string | (() => string | Promise<string>)
    refreshToken?: string | (() => string | Promise<string>)
    onRefresh?: (newToken: string) => void | Promise<void>
    header?: string
    scheme?: string
  }
  timeout?: number
  retries?: number
  headers?: Record<string, string>
  onRequest?: (init: RequestInit) => Promise<RequestInit> | RequestInit
  onResponse?: (response: Response) => Promise<Response> | Response
  onError?: (error: APIError) => Promise<void> | void
}

/**
 * Create type-safe SDK client
 * 
 * @example
 * \`\`\`typescript
 * const api = createSDK({
 *   baseUrl: 'http://localhost:3000',
 *   auth: { token: () => localStorage.getItem('jwt') }
 * })
 * 
 * const posts = await api.posts.list({ skip: 0, take: 20 })
 * const post = await api.posts.get(123)
 * \`\`\`
 */
export function createSDK(config: SDKConfig) {
  // Create base client with environment-aware defaults
  const client = new BaseAPIClient({
    baseUrl: config.baseUrl || getDefaultBaseUrl(),
    timeout: config.timeout,
    retries: config.retries,
    headers: config.headers,
    onRequest: config.auth
      ? createAuthInterceptor(config.auth)
      : config.onRequest,
    onResponse: config.onResponse,
    onError: config.onError
  })

  // Return model clients
  return {
${properties}
  }
}

/**
 * SDK type (for type annotations)
 */
export interface SDK {
${exportTypes}
}

// Re-export convenience modules
export * from './quick-start.js'
export * from './types.js'
`
}

/**
 * Generate SDK version file with manifest hash
 */
export function generateSDKVersion(schemaHash: string, toolVersion: string): string {
  return `// @generated
// This file is automatically generated. Do not edit manually.

/**
 * Schema hash for version checking
 * Regenerate SDK if backend schema hash differs
 */
export const SCHEMA_HASH = '${schemaHash}'

/**
 * Generator tool version
 */
export const TOOL_VERSION = '${toolVersion}'

/**
 * Check if SDK version matches backend
 */
export function checkVersion(backendHash: string): {
  compatible: boolean
  message?: string
} {
  if (backendHash === SCHEMA_HASH) {
    return { compatible: true }
  }
  
  return {
    compatible: false,
    message: \`SDK version mismatch. SDK: \${SCHEMA_HASH.slice(0, 8)}, Backend: \${backendHash.slice(0, 8)}. Please regenerate SDK.\`
  }
}
`
}


