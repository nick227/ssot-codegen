/**
 * SDK Generator - Generates type-safe client SDK for frontend
 */

import type { ParsedModel, ParsedSchema } from '../dmmf-parser.js'
import { analyzeModel } from '../utils/relationship-analyzer.js'

/**
 * Generate SDK client for a single model - THIN FACADE PATTERN
 */
export function generateModelSDK(
  model: ParsedModel,
  schema: ParsedSchema
): string {
  const analysis = analyzeModel(model, schema)
  const modelLower = model.name.toLowerCase()
  const idType = model.idField?.type === 'String' ? 'string' : 'number'
  
  const helpers = generateSDKHelpers(model, analysis, idType)
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import type {
  ${model.name}CreateDTO,
  ${model.name}UpdateDTO,
  ${model.name}ReadDTO,
  ${model.name}QueryDTO
} from '@gen/contracts/${modelLower}'
import { BaseModelClient, type ListResponse } from '@ssot-codegen/sdk-runtime'
import type { BaseAPIClient, QueryOptions } from '@ssot-codegen/sdk-runtime'

/**
 * ${model.name} SDK Client - Thin Facade Pattern
 * 
 * Provides consistent 7-method interface:
 * - list(query?)         Get multiple records
 * - get(id)              Get one by ID
 * - create(data)         Create new
 * - update(id, data)     Update existing
 * - delete(id)           Remove
 * - findOne(where)       Find by any field
 * - count(query?)        Count records
 * 
 * Plus optional domain shortcuts in .helpers namespace
 * 
 * @example
 * \`\`\`typescript
 * // Core methods (work on ALL models)
 * const posts = await api.post.list({ take: 20 })
 * const post = await api.post.get(123)
 * const bySlug = await api.post.findOne({ slug: 'hello' })
 * 
 * // Helpers (optional shortcuts)
 * const bySlug = await api.post.helpers.findBySlug('hello')
 * await api.post.helpers.publish(123)
 * \`\`\`
 */
export class ${model.name}Client extends BaseModelClient<
  ${model.name}ReadDTO,
  ${model.name}CreateDTO,
  ${model.name}UpdateDTO,
  ${model.name}QueryDTO
> {
  constructor(client: BaseAPIClient) {
    super(client, '/api/${modelLower}s')
  }

  // ============================================
  // Core methods inherited from BaseModelClient:
  // - list(query?)
  // - get(id)
  // - create(data)
  // - update(id, data)
  // - delete(id)
  // - findOne(where)
  // - count(query?)
  // ============================================
${helpers}
}
`
}

/**
 * Generate SDK helpers namespace - THIN FACADE PATTERN
 * 
 * Helpers are optional domain shortcuts that use core methods
 */
function generateSDKHelpers(
  model: ParsedModel,
  analysis: ReturnType<typeof analyzeModel>,
  idType: string
): string {
  const methods: string[] = []
  const modelLower = model.name.toLowerCase()

  // Slug lookup helper
  if (analysis.specialFields.slug) {
    methods.push(`    /**
     * Find ${model.name} by slug (sugar over findOne)
     * 
     * @example api.${modelLower}.helpers.findBySlug('hello-world')
     */
    findBySlug: async (slug: string, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.findOne({ slug } as any, options)
    }`)
  }

  // Published filtering helpers
  if (analysis.specialFields.published) {
    methods.push(`    /**
     * List published ${model.name} records (sugar over list with where filter)
     * 
     * @example api.${modelLower}.helpers.listPublished({ take: 10 })
     */
    listPublished: async (query?: Omit<${model.name}QueryDTO, 'where'>, options?: QueryOptions): Promise<ListResponse<${model.name}ReadDTO>> => {
      return this.list({ ...query, where: { published: true } as any } as ${model.name}QueryDTO, options)
    }`)

    methods.push(`    /**
     * Publish ${model.name} (sugar over update)
     * 
     * @example api.${modelLower}.helpers.publish(123)
     */
    publish: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.update(id, { published: true } as any, options)
    }`)

    methods.push(`    /**
     * Unpublish ${model.name} (sugar over update)
     * 
     * @example api.${modelLower}.helpers.unpublish(123)
     */
    unpublish: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.update(id, { published: false } as any, options)
    }`)
  }

  // View counter helper
  if (analysis.specialFields.views) {
    methods.push(`    /**
     * Increment ${model.name} views (custom endpoint)
     * 
     * @example api.${modelLower}.helpers.incrementViews(123)
     */
    incrementViews: async (id: ${idType}, options?: QueryOptions): Promise<void> => {
      await this.client.post<void>(
        \`\${this.basePath}/\${id}/views\`,
        undefined,
        { signal: options?.signal }
      )
    }`)
  }

  // Approval workflow helpers
  if (analysis.specialFields.approved) {
    methods.push(`    /**
     * Approve ${model.name} (sugar over update)
     * 
     * @example api.${modelLower}.helpers.approve(456)
     */
    approve: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.update(id, { approved: true } as any, options)
    }`)

    methods.push(`    /**
     * Reject ${model.name} (sugar over update)
     * 
     * @example api.${modelLower}.helpers.reject(456)
     */
    reject: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.update(id, { approved: false } as any, options)
    }`)
    
    methods.push(`    /**
     * List pending ${model.name} records (sugar over list with where filter)
     * 
     * @example api.${modelLower}.helpers.listPending()
     */
    listPending: async (query?: Omit<${model.name}QueryDTO, 'where'>, options?: QueryOptions): Promise<ListResponse<${model.name}ReadDTO>> => {
      return this.list({ ...query, where: { approved: false } as any } as ${model.name}QueryDTO, options)
    }`)
  }

  // Soft delete helpers
  if (analysis.specialFields.deletedAt) {
    methods.push(`    /**
     * Soft delete ${model.name} (sugar over update)
     * 
     * @example api.${modelLower}.helpers.softDelete(123)
     */
    softDelete: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.update(id, { deletedAt: new Date() } as any, options)
    }`)

    methods.push(`    /**
     * Restore soft-deleted ${model.name} (sugar over update)
     * 
     * @example api.${modelLower}.helpers.restore(123)
     */
    restore: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      return this.update(id, { deletedAt: null } as any, options)
    }`)
  }

  // Threading helper
  if (analysis.specialFields.parentId) {
    methods.push(`    /**
     * Get ${model.name} thread with replies (custom endpoint)
     * 
     * @example api.${modelLower}.helpers.getThread(456)
     */
    getThread: async (id: ${idType}, options?: QueryOptions): Promise<${model.name}ReadDTO | null> => {
      try {
        const response = await this.client.get<${model.name}ReadDTO>(
          \`\${this.basePath}/\${id}/thread\`,
          { signal: options?.signal }
        )
        return response.data
      } catch (error) {
        if (error instanceof Error && 'status' in error && (error as any).status === 404) {
          return null
        }
        throw error
      }
    }`)
  }

  // If no helpers, return empty string
  if (methods.length === 0) {
    return ''
  }

  // Return helpers namespace
  return `
  /**
   * Domain-specific helper methods
   * These are optional shortcuts over core methods
   */
  helpers = {
${methods.join(',\n\n')}
  }`
}

/**
 * Generate main SDK factory
 */
export function generateMainSDK(models: ParsedModel[], schema: ParsedSchema): string {
  // Filter out junction tables
  const nonJunctionModels = models.filter(m => {
    const analysis = analyzeModel(m, schema)
    return !analysis.isJunctionTable
  })
  
  const imports = nonJunctionModels.map(m =>
    `import { ${m.name}Client } from './models/${m.name.toLowerCase()}.client.js'`
  ).join('\n')

  const properties = nonJunctionModels.map(m => {
    const lower = m.name.toLowerCase()
    return `    ${lower}: new ${m.name}Client(client)`
  }).join(',\n')

  const exportTypes = nonJunctionModels.map(m => {
    const lower = m.name.toLowerCase()
    return `  ${lower}: ${m.name}Client`
  }).join('\n')

  return `// @generated
// This file is automatically generated. Do not edit manually.

import { BaseAPIClient, createAuthInterceptor, type RequestConfig } from '@ssot-codegen/sdk-runtime'
${imports}

export interface SDKConfig {
  baseUrl: string
  auth?: {
    token?: string | (() => string | Promise<string>)
    refreshToken?: string | (() => string | Promise<string>)
    onRefresh?: (newToken: string) => void | Promise<void>
    header?: string
    scheme?: string
  }
  timeout?: number
  retries?: number
  headers?: Record<string, string>
  onRequest?: (init: RequestInit) => Promise<RequestInit> | RequestInit
  onResponse?: (response: Response) => Promise<Response> | Response
  onError?: (error: any) => Promise<void> | void
}

/**
 * Create type-safe SDK client
 * 
 * @example
 * \`\`\`typescript
 * const api = createSDK({
 *   baseUrl: 'http://localhost:3000',
 *   auth: { token: () => localStorage.getItem('jwt') }
 * })
 * 
 * const posts = await api.posts.list({ skip: 0, take: 20 })
 * const post = await api.posts.get(123)
 * \`\`\`
 */
export function createSDK(config: SDKConfig) {
  // Create base client
  const client = new BaseAPIClient({
    baseUrl: config.baseUrl,
    timeout: config.timeout,
    retries: config.retries,
    headers: config.headers,
    onRequest: config.auth
      ? createAuthInterceptor(config.auth)
      : config.onRequest,
    onResponse: config.onResponse,
    onError: config.onError
  })

  // Return model clients
  return {
${properties}
  }
}

/**
 * SDK type (for type annotations)
 */
export interface SDK {
${exportTypes}
}

// Re-export convenience modules
export * from './quick-start.js'
export * from './types.js'
`
}

/**
 * Generate SDK version file with manifest hash
 */
export function generateSDKVersion(schemaHash: string, toolVersion: string): string {
  return `// @generated
// This file is automatically generated. Do not edit manually.

/**
 * Schema hash for version checking
 * Regenerate SDK if backend schema hash differs
 */
export const SCHEMA_HASH = '${schemaHash}'

/**
 * Generator tool version
 */
export const TOOL_VERSION = '${toolVersion}'

/**
 * Check if SDK version matches backend
 */
export function checkVersion(backendHash: string): {
  compatible: boolean
  message?: string
} {
  if (backendHash === SCHEMA_HASH) {
    return { compatible: true }
  }
  
  return {
    compatible: false,
    message: \`SDK version mismatch. SDK: \${SCHEMA_HASH.slice(0, 8)}, Backend: \${backendHash.slice(0, 8)}. Please regenerate SDK.\`
  }
}
`
}

