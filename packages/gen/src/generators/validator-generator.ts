/**
 * Validator Generator - Generates Zod validation schemas
 * 
 * Generates:
 * - CreateSchema: Validates POST request bodies
 * - UpdateSchema: Validates PATCH request bodies (partial)
 * - QuerySchema: Validates query parameters (filtering, pagination, sorting)
 */

import type { ParsedModel, ParsedField } from '../dmmf-parser.js'
import { mapPrismaToZod } from '../type-mapper.js'
import { toKebabCase } from '@/utils/naming.js'

export { generateValidatorsBarrel } from './barrel-generator.js'

/**
 * Validate model has required properties for validator generation
 * @throws Error if model is invalid
 */
function validateModel(model: ParsedModel, context: string): void {
  if (!model || typeof model !== 'object') {
    throw new Error(`${context}: Invalid model (not an object)`)
  }
  
  if (!model.name || typeof model.name !== 'string') {
    throw new Error(`${context}: Model missing 'name' property`)
  }
  
  if (!model.fields || !Array.isArray(model.fields)) {
    throw new Error(`${context}: Model ${model.name} missing 'fields' array`)
  }
}

/**
 * Validate model has required field arrays
 */
function validateFieldArrays(model: ParsedModel, arrayName: keyof ParsedModel): void {
  const fields = model[arrayName]
  
  if (!fields || !Array.isArray(fields)) {
    throw new Error(`Model ${model.name} missing '${arrayName}' array`)
  }
}

/**
 * Generate Create validator
 */
export function generateCreateValidator(model: ParsedModel): string {
  validateModel(model, 'generateCreateValidator')
  validateFieldArrays(model, 'createFields')
  
  try {
    const fields = model.createFields.map(field => {
      if (!field || !field.name) {
        throw new Error(`Invalid field in model ${model.name}`)
      }
      
      const zodSchema = mapPrismaToZod(field)
      
      if (!zodSchema) {
        throw new Error(`Failed to map Zod schema for field ${field.name}`)
      }
      
      return `  ${field.name}: ${zodSchema}`
    }).join(',\n')
    
    // Detect enum fields and generate imports
    const enumFields = model.createFields.filter(f => f.kind === 'enum')
    const enumImports = enumFields.length > 0
      ? `import { ${[...new Set(enumFields.map(f => f.type))].join(', ')} } from '@prisma/client'\n`
      : ''
    
    return `// @generated
// This file is automatically generated. Do not edit manually.

import { z } from 'zod'
${enumImports}
export const ${model.name}CreateSchema = z.object({
${fields}
})

export type ${model.name}CreateInput = z.infer<typeof ${model.name}CreateSchema>
`
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    throw new Error(`Failed to generate CreateValidator for ${model.name}: ${message}`)
  }
}

/**
 * Generate Update validator (partial of create)
 */
export function generateUpdateValidator(model: ParsedModel): string {
  validateModel(model, 'generateUpdateValidator')
  
  try {
    const modelKebab = toKebabCase(model.name)
    
    return `// @generated
// This file is automatically generated. Do not edit manually.

import { z } from 'zod'
import { ${model.name}CreateSchema } from './${modelKebab}.create.zod.js'

export const ${model.name}UpdateSchema = ${model.name}CreateSchema.partial()

export type ${model.name}UpdateInput = z.infer<typeof ${model.name}UpdateSchema>
`
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    throw new Error(`Failed to generate UpdateValidator for ${model.name}: ${message}`)
  }
}

/**
 * Generate Query validator
 */
export function generateQueryValidator(model: ParsedModel): string {
  validateModel(model, 'generateQueryValidator')
  validateFieldArrays(model, 'scalarFields')
  
  try {
    const sortableFields = model.scalarFields.map(f => f.name)
    
    // Generate where clause fields
    const whereFields = model.scalarFields
      .filter(f => !f.isUpdatedAt) // Exclude updatedAt from filtering
      .map(f => {
        if (!f || !f.name) {
          throw new Error(`Invalid field in model ${model.name}`)
        }
        return generateWhereField(f)
      })
      .filter(Boolean)
      .join(',\n')
  
  // Detect enum fields for import
  const enumFields = model.scalarFields.filter(f => f.kind === 'enum')
  const enumImports = enumFields.length > 0
    ? `import { ${[...new Set(enumFields.map(f => f.type))].join(', ')} } from '@prisma/client'\n`
    : ''
  
  // Build orderBy schema
  const scalarOrderFields = model.scalarFields
    .map(f => `    ${f.name}: z.enum(['asc', 'desc']).optional()`)
  const relationOrderFields = model.relationFields
    .map(f => `    ${f.name}: z.record(z.enum(['asc', 'desc'])).optional()`)
  const orderByFields = [...scalarOrderFields, ...relationOrderFields]
  const orderBySchema = orderByFields.length > 0
    ? `z.object({\n${orderByFields.join(',\n')}\n  }).optional()`
    : 'z.record(z.enum([\'asc\', \'desc\'])).optional()'
  
  // Build include schema
  const includeFields = model.relationFields
    .map(f => `    ${f.name}: z.boolean().optional()`)
  const includeSchema = includeFields.length > 0
    ? `z.object({\n${includeFields.join(',\n')}\n  }).optional()`
    : 'z.record(z.boolean()).optional()'
  
  // Build select schema
  const selectFields = model.fields
    .map(f => `    ${f.name}: z.boolean().optional()`)
  const selectSchema = `z.object({\n${selectFields.join(',\n')}\n  }).optional()`
  
    return `// @generated
// This file is automatically generated. Do not edit manually.

import { z } from 'zod'
${enumImports}
export const ${model.name}QuerySchema = z.object({
  skip: z.coerce.number().min(0).optional(),
  take: z.coerce.number().min(1).max(100).optional().default(20),
  orderBy: ${orderBySchema},
  where: z.object({
${whereFields}
  }).optional(),
  include: ${includeSchema},
  select: ${selectSchema}
})

export type ${model.name}QueryInput = z.infer<typeof ${model.name}QuerySchema>
`
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    throw new Error(`Failed to generate QueryValidator for ${model.name}: ${message}`)
  }
}

/**
 * Generate where clause field for a given field type
 */
function generateWhereField(field: ParsedField): string | null {
  const fieldName = field.name
  const isNullable = !field.isRequired
  const nullCheck = isNullable ? ',\n      isNull: z.boolean().optional()' : ''
  
  switch (field.type) {
    case 'String':
      return `    ${fieldName}: z.object({
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      equals: z.string().optional()${nullCheck}
    }).optional()`
    
    case 'Int':
    case 'BigInt':
    case 'Float':
    case 'Decimal':
      return `    ${fieldName}: z.object({
      equals: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      lt: z.number().optional(),
      lte: z.number().optional()${nullCheck}
    }).optional()`
    
    case 'Boolean':
      return `    ${fieldName}: z.boolean().optional()`
    
    case 'DateTime':
      return `    ${fieldName}: z.object({
      equals: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional()${nullCheck}
    }).optional()`
    
    default:
      if (field.kind === 'enum') {
        const enumFilter = `    ${fieldName}: z.nativeEnum(${field.type}).optional()`
        return isNullable ? `    ${fieldName}: z.union([
      z.nativeEnum(${field.type}),
      z.object({ isNull: z.boolean() })
    ]).optional()` : enumFilter
      }
      // Skip other types (Json, Bytes, etc.)
      return null
  }
}

/**
 * Generate all validators for a model
 * 
 * @param model - Parsed Prisma model
 * @returns Object containing all three validator types
 * @throws Error if model is invalid or validator generation fails
 */
export function generateAllValidators(model: ParsedModel): {
  create: string
  update: string
  query: string
} {
  // Validate model upfront before generating any validators
  validateModel(model, 'generateAllValidators')
  
  try {
    return {
      create: generateCreateValidator(model),
      update: generateUpdateValidator(model),
      query: generateQueryValidator(model)
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    throw new Error(`Failed to generate validators for ${model.name}: ${message}`)
  }
}

