/**
 * Validator Generator - Generates Zod validation schemas
 */

import type { ParsedModel, ParsedField } from '../dmmf-parser.js'
import { mapPrismaToZod } from '../type-mapper.js'
import { toKebabCase } from '@/utils/naming.js'

export { generateValidatorsBarrel } from './barrel-generator.js'

/**
 * Generate Create validator
 */
export function generateCreateValidator(model: ParsedModel): string {
  const fields = model.createFields.map(field => {
    const zodSchema = mapPrismaToZod(field)
    return `  ${field.name}: ${zodSchema}`
  }).join(',\n')
  
  // Detect enum fields and generate imports
  const enumFields = model.createFields.filter(f => f.kind === 'enum')
  const enumImports = enumFields.length > 0
    ? `import { ${[...new Set(enumFields.map(f => f.type))].join(', ')} } from '@prisma/client'\n`
    : ''
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import { z } from 'zod'
${enumImports}
export const ${model.name}CreateSchema = z.object({
${fields}
})

export type ${model.name}CreateInput = z.infer<typeof ${model.name}CreateSchema>
`
}

/**
 * Generate Update validator (partial of create)
 */
export function generateUpdateValidator(model: ParsedModel): string {
  const modelKebab = toKebabCase(model.name)
  return `// @generated
// This file is automatically generated. Do not edit manually.

import { z } from 'zod'
import { ${model.name}CreateSchema } from './${modelKebab}.create.zod.js'

export const ${model.name}UpdateSchema = ${model.name}CreateSchema.partial()

export type ${model.name}UpdateInput = z.infer<typeof ${model.name}UpdateSchema>
`
}

/**
 * Generate Query validator
 */
export function generateQueryValidator(model: ParsedModel): string {
  const sortableFields = model.scalarFields.map(f => f.name)
  
  // Generate where clause fields
  const whereFields = model.scalarFields
    .filter(f => !f.isUpdatedAt) // Exclude updatedAt from filtering
    .map(f => generateWhereField(f))
    .filter(Boolean)
    .join(',\n')
  
  // Detect enum fields for import
  const enumFields = model.scalarFields.filter(f => f.kind === 'enum')
  const enumImports = enumFields.length > 0
    ? `import { ${[...new Set(enumFields.map(f => f.type))].join(', ')} } from '@prisma/client'\n`
    : ''
  
  // Build orderBy schema
  const scalarOrderFields = model.scalarFields
    .map(f => `    ${f.name}: z.enum(['asc', 'desc']).optional()`)
  const relationOrderFields = model.relationFields
    .map(f => `    ${f.name}: z.record(z.enum(['asc', 'desc'])).optional()`)
  const orderByFields = [...scalarOrderFields, ...relationOrderFields]
  const orderBySchema = orderByFields.length > 0
    ? `z.object({\n${orderByFields.join(',\n')}\n  }).optional()`
    : 'z.record(z.enum([\'asc\', \'desc\'])).optional()'
  
  // Build include schema
  const includeFields = model.relationFields
    .map(f => `    ${f.name}: z.boolean().optional()`)
  const includeSchema = includeFields.length > 0
    ? `z.object({\n${includeFields.join(',\n')}\n  }).optional()`
    : 'z.record(z.boolean()).optional()'
  
  // Build select schema
  const selectFields = model.fields
    .map(f => `    ${f.name}: z.boolean().optional()`)
  const selectSchema = `z.object({\n${selectFields.join(',\n')}\n  }).optional()`
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import { z } from 'zod'
${enumImports}
export const ${model.name}QuerySchema = z.object({
  skip: z.coerce.number().min(0).optional(),
  take: z.coerce.number().min(1).max(100).optional().default(20),
  orderBy: ${orderBySchema},
  where: z.object({
${whereFields}
  }).optional(),
  include: ${includeSchema},
  select: ${selectSchema}
})

export type ${model.name}QueryInput = z.infer<typeof ${model.name}QuerySchema>
`
}

/**
 * Generate where clause field for a given field type
 */
function generateWhereField(field: ParsedField): string | null {
  const fieldName = field.name
  const isNullable = !field.isRequired
  const nullCheck = isNullable ? ',\n      isNull: z.boolean().optional()' : ''
  
  switch (field.type) {
    case 'String':
      return `    ${fieldName}: z.object({
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      equals: z.string().optional()${nullCheck}
    }).optional()`
    
    case 'Int':
    case 'BigInt':
    case 'Float':
    case 'Decimal':
      return `    ${fieldName}: z.object({
      equals: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      lt: z.number().optional(),
      lte: z.number().optional()${nullCheck}
    }).optional()`
    
    case 'Boolean':
      return `    ${fieldName}: z.boolean().optional()`
    
    case 'DateTime':
      return `    ${fieldName}: z.object({
      equals: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional()${nullCheck}
    }).optional()`
    
    default:
      if (field.kind === 'enum') {
        const enumFilter = `    ${fieldName}: z.nativeEnum(${field.type}).optional()`
        return isNullable ? `    ${fieldName}: z.union([
      z.nativeEnum(${field.type}),
      z.object({ isNull: z.boolean() })
    ]).optional()` : enumFilter
      }
      // Skip other types (Json, Bytes, etc.)
      return null
  }
}

/**
 * Generate all validators for a model
 */
export function generateAllValidators(model: ParsedModel): {
  create: string
  update: string
  query: string
} {
  return {
    create: generateCreateValidator(model),
    update: generateUpdateValidator(model),
    query: generateQueryValidator(model)
  }
}

