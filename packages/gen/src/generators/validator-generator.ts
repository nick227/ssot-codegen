/**
 * Validator Generator - Generates Zod validation schemas
 */

import type { ParsedModel, ParsedField } from '../dmmf-parser.js'
import { mapPrismaToZod } from '../type-mapper.js'

/**
 * Generate Create validator
 */
export function generateCreateValidator(model: ParsedModel): string {
  const fields = model.createFields.map(field => {
    const zodSchema = mapPrismaToZod(field)
    return `  ${field.name}: ${zodSchema}`
  }).join(',\n')
  
  // Detect enum fields and generate imports
  const enumFields = model.createFields.filter(f => f.kind === 'enum')
  const enumImports = enumFields.length > 0
    ? `import { ${[...new Set(enumFields.map(f => f.type))].join(', ')} } from '@prisma/client'\n`
    : ''
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import { z } from 'zod'
${enumImports}
export const ${model.name}CreateSchema = z.object({
${fields}
})

export type ${model.name}CreateInput = z.infer<typeof ${model.name}CreateSchema>
`
}

/**
 * Generate Update validator (partial of create)
 */
export function generateUpdateValidator(model: ParsedModel): string {
  return `// @generated
// This file is automatically generated. Do not edit manually.

import { z } from 'zod'
import { ${model.name}CreateSchema } from './${model.name.toLowerCase()}.create.zod.js'

export const ${model.name}UpdateSchema = ${model.name}CreateSchema.partial()

export type ${model.name}UpdateInput = z.infer<typeof ${model.name}UpdateSchema>
`
}

/**
 * Generate Query validator
 */
export function generateQueryValidator(model: ParsedModel): string {
  const sortableFields = model.scalarFields.map(f => f.name)
  
  // Generate where clause fields
  const whereFields = model.scalarFields
    .filter(f => !f.isUpdatedAt) // Exclude updatedAt from filtering
    .map(f => generateWhereField(f))
    .filter(Boolean)
    .join(',\n')
  
  // Detect enum fields for import
  const enumFields = model.scalarFields.filter(f => f.kind === 'enum')
  const enumImports = enumFields.length > 0
    ? `import { ${[...new Set(enumFields.map(f => f.type))].join(', ')} } from '@prisma/client'\n`
    : ''
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import { z } from 'zod'
${enumImports}
/**
 * OrderBy accepts field name with optional '-' prefix for descending
 * Examples: 'createdAt' = asc, '-createdAt' = desc
 */
const orderByTransform = z.string()
  .regex(/^-?(${sortableFields.join('|')})$/, 'Invalid orderBy field')
  .transform((val) => {
    const desc = val.startsWith('-')
    const field = desc ? val.slice(1) : val
    return { [field]: desc ? 'desc' : 'asc' } as any
  })

export const ${model.name}QuerySchema = z.object({
  skip: z.coerce.number().min(0).optional(),
  take: z.coerce.number().min(1).max(100).optional().default(20),
  orderBy: orderByTransform.optional(),
  where: z.object({
${whereFields}
  }).optional()
})

export type ${model.name}QueryInput = z.infer<typeof ${model.name}QuerySchema>
`
}

/**
 * Generate where clause field for a given field type
 */
function generateWhereField(field: ParsedField): string | null {
  const fieldName = field.name
  const isNullable = !field.isRequired
  const nullCheck = isNullable ? ',\n      isNull: z.boolean().optional()' : ''
  
  switch (field.type) {
    case 'String':
      return `    ${fieldName}: z.object({
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      equals: z.string().optional()${nullCheck}
    }).optional()`
    
    case 'Int':
    case 'BigInt':
    case 'Float':
    case 'Decimal':
      return `    ${fieldName}: z.object({
      equals: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      lt: z.number().optional(),
      lte: z.number().optional()${nullCheck}
    }).optional()`
    
    case 'Boolean':
      return `    ${fieldName}: z.boolean().optional()`
    
    case 'DateTime':
      return `    ${fieldName}: z.object({
      equals: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional()${nullCheck}
    }).optional()`
    
    default:
      if (field.kind === 'enum') {
        const enumFilter = `    ${fieldName}: z.nativeEnum(${field.type}).optional()`
        return isNullable ? `    ${fieldName}: z.union([
      z.nativeEnum(${field.type}),
      z.object({ isNull: z.boolean() })
    ]).optional()` : enumFilter
      }
      // Skip other types (Json, Bytes, etc.)
      return null
  }
}

/**
 * Generate all validators for a model
 */
export function generateAllValidators(model: ParsedModel): {
  create: string
  update: string
  query: string
} {
  return {
    create: generateCreateValidator(model),
    update: generateUpdateValidator(model),
    query: generateQueryValidator(model)
  }
}

/**
 * Generate barrel export for validators
 */
export function generateValidatorsBarrel(model: ParsedModel): string {
  return `// @generated barrel
export * from './${model.name.toLowerCase()}.create.zod.js'
export * from './${model.name.toLowerCase()}.update.zod.js'
export * from './${model.name.toLowerCase()}.query.zod.js'
`
}

