/**
 * Enhanced Route Generator - Generates routes with domain-specific endpoints
 */

import type { ParsedModel, ParsedSchema } from '../dmmf-parser.js'
import type { ModelAnalysis } from '../utils/relationship-analyzer.js'

// Helper function
function toCamelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1)
}

/**
 * Generate enhanced routes with domain methods
 * Returns null if this model should not have routes generated (e.g., junction tables)
 * OPTIMIZED: Accepts pre-computed analysis from cache
 */
export function generateEnhancedRoutes(
  model: ParsedModel,
  schema: ParsedSchema,
  framework: 'express' | 'fastify' = 'express',
  analysis: ModelAnalysis  // â­ Accept cached analysis
): string | null {
  // Remove: const analysis = analyzeModel(model, schema)
  
  // Skip junction tables
  if (analysis.isJunctionTable) {
    return null
  }
  
  const modelLower = model.nameLower  // Use cached lowercase name
  
  if (framework === 'express') {
    return generateExpressRoutes(model, analysis, modelLower)
  } else {
    return generateFastifyRoutes(model, analysis, modelLower)
  }
}

/**
 * Generate Express routes with enhanced endpoints
 */
function generateExpressRoutes(
  model: ParsedModel,
  analysis: ModelAnalysis,
  modelLower: string
): string {
  const baseRoutes = generateExpressBaseRoutes(model, modelLower)
  const domainRoutes = generateExpressDomainRoutes(model, analysis, modelLower)
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import { Router, type Router as RouterType } from 'express'
import * as ${modelLower}Controller from '@/controllers/${modelLower}/index.js'

export const ${modelLower}Router: RouterType = Router()

${baseRoutes}${domainRoutes}
`
}

/**
 * Generate base CRUD routes
 */
function generateExpressBaseRoutes(model: ParsedModel, modelLower: string): string {
  return `// List all ${model.name} records
${modelLower}Router.get('/', ${modelLower}Controller.list${model.name}s)

// Get ${model.name} by ID
${modelLower}Router.get('/:id', ${modelLower}Controller.get${model.name})

// Create ${model.name}
${modelLower}Router.post('/', ${modelLower}Controller.create${model.name})

// Update ${model.name}
${modelLower}Router.put('/:id', ${modelLower}Controller.update${model.name})
${modelLower}Router.patch('/:id', ${modelLower}Controller.update${model.name})

// Delete ${model.name}
${modelLower}Router.delete('/:id', ${modelLower}Controller.delete${model.name})

// Count ${model.name} records
${modelLower}Router.get('/meta/count', ${modelLower}Controller.count${model.name}s)
`
}

/**
 * Generate domain-specific routes
 */
function generateExpressDomainRoutes(
  model: ParsedModel,
  analysis: ModelAnalysis,
  modelLower: string
): string {
  const routes: string[] = []
  
  // Slug lookup route (must come before /:id to avoid conflicts)
  if (analysis.hasSlugField) {
    routes.push(`// Get ${model.name} by slug
${modelLower}Router.get('/slug/:slug', ${modelLower}Controller.get${model.name}BySlug)
`)
  }
  
  // Published filtering
  if (analysis.hasPublishedField) {
    routes.push(`// List published ${model.name} records
${modelLower}Router.get('/published', ${modelLower}Controller.listPublished${model.name}s)

// Publish/unpublish ${model.name}
${modelLower}Router.post('/:id/publish', ${modelLower}Controller.publish${model.name})
${modelLower}Router.post('/:id/unpublish', ${modelLower}Controller.unpublish${model.name})
`)
  }
  
  // View counter
  if (analysis.specialFields.views) {
    routes.push(`// Increment ${model.name} views
${modelLower}Router.post('/:id/views', ${modelLower}Controller.increment${model.name}Views)
`)
  }
  
  // Approval workflow
  if (analysis.specialFields.approved) {
    routes.push(`// List pending ${model.name} records
${modelLower}Router.get('/pending', ${modelLower}Controller.listPending${model.name}s)

// Approve ${model.name}
${modelLower}Router.post('/:id/approve', ${modelLower}Controller.approve${model.name})
`)
  }
  
  return routes.length > 0 ? '\n' + routes.join('\n') : ''
}

/**
 * Generate Fastify routes (similar pattern)
 */
function generateFastifyRoutes(
  model: ParsedModel,
  analysis: ModelAnalysis,
  modelLower: string
): string {
  return `// @generated
// Fastify routes - TBD
import type { FastifyInstance } from 'fastify'
import * as ${modelLower}Controller from '@/controllers/${modelLower}'

export async function ${modelLower}Routes(fastify: FastifyInstance) {
  // TODO: Generate Fastify routes
}
`
}

/**
 * Determine if a model should have routes generated
 */
export function shouldGenerateRoutes(model: ParsedModel, schema: ParsedSchema, analysis: ModelAnalysis): boolean {
  return !analysis.isJunctionTable
}


