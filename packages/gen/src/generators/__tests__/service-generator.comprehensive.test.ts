/**
 * Service Generator - Comprehensive Tests
 * Uses new test utilities for better coverage
 * 
 * TODO: Migrate to test production service-generator.ts (functional API)
 * These tests were for the experimental v2 class-based API (removed in consolidation)
 */

import { describe, it, expect, beforeEach } from 'vitest'
// import { ServiceGenerator } from '../service-generator-v2.js' // REMOVED: v2 generators consolidated
import {
  models,
  field,
  ModelBuilder,
  FieldBuilder,
  assertIncludes,
  assertExcludes,
  assertValidTypeScript,
  extractImports,
  extractExports,
  normalizeGenerated,
  minimalSnapshot
} from '../../__tests__/index.js'
import { createMockModel } from './fixtures.js'

describe.skip('ServiceGenerator - Comprehensive Tests (V2 API - DEPRECATED)', () => {
  // TODO: Rewrite tests for functional API (generateService from service-generator.ts)
  describe('Basic Service Generation', () => {
    let generator: ServiceGenerator

    beforeEach(() => {
      generator = new ServiceGenerator({ model: models.todo() })
    })

    it('should generate service file', () => {
      const output = generator.generate()

      expect(output.files.size).toBe(1)
      expect(output.files.has('todo.service.ts')).toBe(true)
    })

    it('should generate valid TypeScript', () => {
      const output = generator.generate()

      output.files.forEach((content) => {
        assertValidTypeScript(content)
      })
    })

    it('should include generation markers', () => {
      const output = generator.generate()

      output.files.forEach((content) => {
        expect(content).toContain('// @generated')
        expect(content).toContain('// This file is automatically generated')
      })
    })

    it('should export service object', () => {
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('export const todoService = {')
    })

    it('should have all CRUD methods', () => {
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'async list(',
        'async findById(',
        'async create(',
        'async update(',
        'async delete(',
        'async count(',
        'async exists('
      ])
    })
  })

  describe('List Method', () => {
    it('should generate list method with pagination', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'async list(query: TodoQueryDTO)',
        'const { skip = 0, take = 20, orderBy, where, include, select } = query',
        'prisma.todo.findMany({',
        'skip,',
        'take,',
        'orderBy:',
        'where:',
        'include:',
        'select:'
      ])
    })

    it('should return paginated response', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'return {',
        'data: items,',
        'meta: {',
        'total,',
        'skip,',
        'take,',
        'hasMore: skip + take < total'
      ])
    })

    it('should use Promise.all for parallel queries', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('await Promise.all([')
      expect(content).toContain('prisma.todo.findMany({')
      expect(content).toContain('prisma.todo.count({')
    })

    it('should cast query types to Prisma types', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'orderBy: orderBy as Prisma.TodoOrderByWithRelationInput',
        'where: where as Prisma.TodoWhereInput',
        'include: include as Prisma.TodoInclude',
        'select: select as Prisma.TodoSelect'
      ])
    })

    it('should include JSDoc comment', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        '/**',
        '* List Todo records with pagination',
        '*/'
      ])
    })
  })

  describe('FindById Method', () => {
    it('should generate findById with Int ID', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'async findById(id: number)',
        'prisma.todo.findUnique({',
        'where: { id }'
      ])
    })

    it('should generate findById with String ID', () => {
      const model = models.user() // Has String ID
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('user.service.ts')!

      assertIncludes(content, [
        'async findById(id: string)',
        'prisma.user.findUnique({',
        'where: { id }'
      ])
    })

    it('should return single record or null', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toMatch(/findById.*\n.*return.*prisma/)
    })

    it('should include JSDoc comment', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        '/**',
        '* Find Todo by ID',
        '*/'
      ])
    })
  })

  describe('Create Method', () => {
    it('should generate create method', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'async create(data: TodoCreateDTO)',
        'prisma.todo.create({',
        'data'
      ])
    })

    it('should return created record', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toMatch(/create\(data.*\n.*return.*prisma\.todo\.create/)
    })

    it('should include JSDoc comment', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        '/**',
        '* Create Todo',
        '*/'
      ])
    })
  })

  describe('Update Method', () => {
    it('should generate update method with Int ID', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'async update(id: number, data: TodoUpdateDTO)',
        'prisma.todo.update({',
        'where: { id },',
        'data'
      ])
    })

    it('should generate update method with String ID', () => {
      const model = models.user()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('user.service.ts')!

      assertIncludes(content, [
        'async update(id: string, data: UserUpdateDTO)',
        'where: { id }'
      ])
    })

    it('should handle P2025 error (record not found)', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'try {',
        'prisma.todo.update({',
        'catch (error: any) {',
        "if (error.code === 'P2025') {",
        'return null'
      ])
    })

    it('should rethrow non-P2025 errors', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('throw error')
    })

    it('should include JSDoc comment', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        '/**',
        '* Update Todo',
        '*/'
      ])
    })
  })

  describe('Delete Method', () => {
    it('should generate delete method with Int ID', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'async delete(id: number)',
        'prisma.todo.delete({',
        'where: { id }'
      ])
    })

    it('should generate delete method with String ID', () => {
      const model = models.user()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('user.service.ts')!

      assertIncludes(content, [
        'async delete(id: string)',
        'where: { id }'
      ])
    })

    it('should return true on success', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('return true')
    })

    it('should return false on P2025 error', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'try {',
        'await prisma.todo.delete({',
        'catch (error: any) {',
        "if (error.code === 'P2025') {",
        'return false'
      ])
    })

    it('should rethrow non-P2025 errors', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('throw error')
    })

    it('should include JSDoc comment', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        '/**',
        '* Delete Todo',
        '*/'
      ])
    })
  })

  describe('Count Method', () => {
    it('should generate count method', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'async count(where?: Prisma.TodoWhereInput)',
        'return prisma.todo.count({ where })'
      ])
    })

    it('should have optional where parameter', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      // where parameter should be optional
      expect(content).toMatch(/count\(where\?:/)
    })

    it('should use Prisma WhereInput type', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('where?: Prisma.TodoWhereInput')
    })

    it('should include JSDoc comment', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        '/**',
        '* Count Todo records',
        '*/'
      ])
    })
  })

  describe('Exists Method', () => {
    it('should generate exists method with Int ID', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'async exists(id: number)',
        'const count = await prisma.todo.count({',
        'where: { id }',
        'return count > 0'
      ])
    })

    it('should generate exists method with String ID', () => {
      const model = models.user()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('user.service.ts')!

      assertIncludes(content, [
        'async exists(id: string)',
        'where: { id }'
      ])
    })

    it('should return boolean', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('return count > 0')
    })

    it('should include JSDoc comment', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        '/**',
        '* Check if Todo exists',
        '*/'
      ])
    })
  })

  describe('Imports', () => {
    it('should import Prisma client', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain("import prisma from '@/db'")
    })

    it('should import DTOs from contracts', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        "import type { TodoCreateDTO, TodoUpdateDTO, TodoQueryDTO } from",
        "@/contracts/todo'"
      ])
    })

    it('should import Prisma namespace for types', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain("import type { Prisma } from '@prisma/client'")
    })
  })

  describe('Exports', () => {
    it('should export service object', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('export const todoService = {')
    })

    it('should export all CRUD methods', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      // Service object should contain all methods
      assertIncludes(content, [
        'export const todoService = {',
        'async list(',
        'async findById(',
        'async create(',
        'async update(',
        'async delete('
      ])
    })

    it('should have correct export list', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const exports = generator.getExports()

      expect(exports).toContain('todoService')
    })
  })

  describe('Service Object Structure', () => {
    it('should export methods in correct order', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      // Find positions of methods
      const listPos = content.indexOf('async list(')
      const findByIdPos = content.indexOf('async findById(')
      const createPos = content.indexOf('async create(')
      const updatePos = content.indexOf('async update(')
      const deletePos = content.indexOf('async delete(')
      const countPos = content.indexOf('async count(')
      const existsPos = content.indexOf('async exists(')

      // Verify order
      expect(listPos).toBeLessThan(findByIdPos)
      expect(findByIdPos).toBeLessThan(createPos)
      expect(createPos).toBeLessThan(updatePos)
      expect(updatePos).toBeLessThan(deletePos)
      expect(deletePos).toBeLessThan(countPos)
      expect(countPos).toBeLessThan(existsPos)
    })

    it('should use lowercase model name for service', () => {
      const model = new ModelBuilder()
        .name('BlogPost')
        .withIntId()
        .addField(field.string('title'))
        .build()

      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('blogpost.service.ts')!

      expect(content).toContain('export const blogpostService = {')
      expect(content).toContain('prisma.blogpost.')
    })
  })

  describe('Edge Cases', () => {
    it('should handle model with only ID field', () => {
      const model = new ModelBuilder()
        .name('MinimalModel')
        .withIntId()
        .build()

      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('minimalmodel.service.ts')!

      expect(content).toContain('export const minimalmodelService = {')
      assertValidTypeScript(content)
    })

    it('should handle UUID ID type', () => {
      const model = models.user() // Has String ID
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('user.service.ts')!

      // All ID parameters should be string
      expect(content).toContain('async findById(id: string)')
      expect(content).toContain('async update(id: string,')
      expect(content).toContain('async delete(id: string)')
      expect(content).toContain('async exists(id: string)')
    })

    it('should handle model with relations', () => {
      const model = models.post()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('post.service.ts')!

      // Should include/select for relations
      expect(content).toContain('include:')
      expect(content).toContain('select:')
      assertValidTypeScript(content)
    })

    it('should handle model with no relations', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      // Should still include include/select options
      expect(content).toContain('include:')
      expect(content).toContain('select:')
    })
  })

  describe('Barrel Export', () => {
    it('should generate barrel export', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const barrel = generator.generateBarrel()

      assertIncludes(barrel, [
        '// @generated barrel',
        "export * from './todo.service.js'"
      ])

      assertValidTypeScript(barrel)
    })
  })

  describe('Error Handling', () => {
    it('should handle Prisma P2025 error in update', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'catch (error: any) {',
        "if (error.code === 'P2025') {",
        'return null',
        'throw error'
      ])
      
      // Comment may say "Not found" or similar
      expect(content).toContain('// Not found')
    })

    it('should handle Prisma P2025 error in delete', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'catch (error: any) {',
        "if (error.code === 'P2025') {",
        'return false',
        'throw error'
      ])
    })

    it('should type error as any for code access', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      // Need `any` type to access error.code
      expect(content).toContain('catch (error: any)')
    })
  })

  describe('JSDoc Comments', () => {
    it('should include JSDoc for all methods', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        '* List Todo records with pagination',
        '* Find Todo by ID',
        '* Create Todo',
        '* Update Todo',
        '* Delete Todo',
        '* Count Todo records',
        '* Check if Todo exists'
      ])
    })

    it('should use proper JSDoc format', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      // Count /** opening markers
      const docOpenings = (content.match(/\/\*\*/g) || []).length
      expect(docOpenings).toBeGreaterThanOrEqual(7) // One for each method
    })
  })

  describe('Snapshot Testing', () => {
    it('should match service snapshot', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      const normalized = normalizeGenerated(content)
      expect(normalized).toMatchSnapshot()
    })

    it('should match minimal snapshot structure', () => {
      const model = models.post()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()

      const snapshots = Array.from(output.files.entries()).map(([filename, content]) => ({
        filename,
        snapshot: minimalSnapshot(content)
      }))

      expect(snapshots).toMatchSnapshot()
    })
  })

  describe('Metadata', () => {
    it('should include file count in metadata', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()

      expect(output.metadata?.fileCount).toBe(1)
    })

    it('should include line count in metadata', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()

      expect(output.metadata?.lineCount).toBeGreaterThan(0)
    })

    it('should track total lines correctly', () => {
      const model = models.post()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()

      const content = output.files.get('post.service.ts')!
      const manualCount = content.split('\n').length

      expect(output.metadata?.lineCount).toBe(manualCount)
    })
  })

  describe('Import/Export Analysis', () => {
    it('should extract imports correctly', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      const imports = extractImports(content)
      expect(imports).toContain('@/db')
      expect(imports).toContain('@/contracts/todo')
      expect(imports).toContain('@prisma/client')
    })

    it('should extract exports correctly', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      const exports = extractExports(content)
      expect(exports).toContain('todoService')
    })
  })

  describe('Complex Models', () => {
    it('should handle blog post model', () => {
      const model = new ModelBuilder()
        .name('BlogPost')
        .withIntId()
        .addField(field.string('title'))
        .addField(field.string('slug'))
        .addField(field.string('content'))
        .addField(field.boolean('published', false))
        .addField(field.string('authorId'))
        .addField(field.relation('author', 'User'))
        .addField(field.relation('comments', 'Comment', true))
        .withTimestamps()
        .build()

      const generator = new ServiceGenerator({ model })
      const output = generator.generate()

      expect(output.files.size).toBe(1)
      const content = output.files.get('blogpost.service.ts')!
      
      assertValidTypeScript(content)
      expect(content).toContain('export const blogpostService = {')
      expect(content).toContain('prisma.blogpost.')
    })

    it('should handle e-commerce product model', () => {
      const model = new ModelBuilder()
        .name('Product')
        .withIntId()
        .addField(field.string('sku'))
        .addField(field.string('name'))
        .addField(
          new FieldBuilder()
            .name('price')
            .type('Decimal')
            .scalar()
            .required()
            .build()
        )
        .addField(field.int('stock'))
        .addField(field.boolean('isActive', true))
        .addField(field.relation('category', 'Category'))
        .withTimestamps()
        .build()

      const generator = new ServiceGenerator({ model })
      const output = generator.generate()

      expect(output.files.size).toBe(1)
      const content = output.files.get('product.service.ts')!
      
      assertValidTypeScript(content)
      assertIncludes(content, [
        'export const productService = {',
        'async list(query: ProductQueryDTO)',
        'async findById(id: number)',
        'async create(data: ProductCreateDTO)',
        'async update(id: number, data: ProductUpdateDTO)',
        'async delete(id: number)'
      ])
    })
  })

  describe('Prisma Type Casts', () => {
    it('should cast orderBy to Prisma type', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('orderBy: orderBy as Prisma.TodoOrderByWithRelationInput')
    })

    it('should cast where to Prisma type', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('where: where as Prisma.TodoWhereInput')
    })

    it('should cast include to Prisma type', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('include: include as Prisma.TodoInclude | undefined')
    })

    it('should cast select to Prisma type', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('select: select as Prisma.TodoSelect | undefined')
    })
  })

  describe('Return Types', () => {
    it('should return paged list from list method', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      assertIncludes(content, [
        'return {',
        'data: items,',
        'meta: {',
        'total,',
        'skip,',
        'take,',
        'hasMore:'
      ])
    })

    it('should return record or null from findById', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toMatch(/async findById.*\n.*return.*findUnique/)
    })

    it('should return created record from create', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toMatch(/async create.*\n.*return.*\.create/)
    })

    it('should return record or null from update', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('return null')
      expect(content).toMatch(/return.*\.update/)
    })

    it('should return boolean from delete', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('return true')
      expect(content).toContain('return false')
    })

    it('should return number from count', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('return prisma.todo.count({ where })')
    })

    it('should return boolean from exists', () => {
      const model = models.todo()
      const generator = new ServiceGenerator({ model })
      const output = generator.generate()
      const content = output.files.get('todo.service.ts')!

      expect(content).toContain('return count > 0')
    })
  })
})


