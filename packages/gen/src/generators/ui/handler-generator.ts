/**
 * Handler Generator
 * 
 * Generates centralized handler hooks (4 categories)
 */

export function generateHandlers(outputDir: string): Map<string, string> {
  const files = new Map<string, string>()
  
  // Category 1: Data handlers
  files.set(`${outputDir}/handlers/useDataHandlers.ts`, generateDataHandlers())
  
  // Category 2: Form handlers
  files.set(`${outputDir}/handlers/useFormHandlers.ts`, generateFormHandlers())
  
  // Category 3: Action handlers
  files.set(`${outputDir}/handlers/useActionHandlers.ts`, generateActionHandlers())
  
  // Category 4: Navigation handlers
  files.set(`${outputDir}/handlers/useNavigationHandlers.ts`, generateNavigationHandlers())
  
  // Index
  files.set(`${outputDir}/handlers/index.ts`, generateHandlersIndex())
  
  return files
}

function generateDataHandlers(): string {
  return `/**
 * Data Handlers
 * 
 * CATEGORY 1: Data operations (CRUD)
 * Handles: list, detail, create, update, delete
 */

'use client'

import { useState, useEffect } from 'react'

export type DataAction = 'list' | 'detail' | 'create' | 'update' | 'delete'

export interface UseDataHandlersOptions {
  autoLoad?: boolean
  onSuccess?: (data: any) => void
  onError?: (error: Error) => void
}

export function useDataHandlers<T = any>(
  model: string,
  action: DataAction,
  options: UseDataHandlersOptions = {}
) {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  const execute = async (params?: any) => {
    setLoading(true)
    setError(null)
    
    try {
      // Call SDK (generated by V2)
      const response = await fetch('/api/data', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model,
          action,
          params
        })
      })
      
      if (!response.ok) {
        throw new Error(\`HTTP \${response.status}\`)
      }
      
      const result = await response.json()
      setData(result)
      
      options.onSuccess?.(result)
      return result
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Operation failed'
      setError(errorMessage)
      options.onError?.(err as Error)
      throw err
    } finally {
      setLoading(false)
    }
  }
  
  const refresh = () => execute()
  
  // Auto-load for list/detail
  useEffect(() => {
    if (options.autoLoad && (action === 'list' || action === 'detail')) {
      execute()
    }
  }, [model, action, options.autoLoad])
  
  return { 
    data, 
    loading, 
    error, 
    execute, 
    refresh 
  }
}
`
}

function generateFormHandlers(): string {
  return `/**
 * Form Handlers
 * 
 * CATEGORY 2: Form operations (input, validation, submit)
 * Handles: field changes, validation, submission, reset
 */

'use client'

import { useState } from 'react'

export interface UseFormHandlersOptions<T> {
  initialData?: Partial<T>
  validate?: (data: T) => Record<string, string>
  onSubmit?: (data: T) => Promise<void>
}

export function useFormHandlers<T extends Record<string, any>>(
  options: UseFormHandlersOptions<T> = {}
) {
  const [formData, setFormData] = useState<Partial<T>>(options.initialData || {})
  const [errors, setErrors] = useState<Record<string, string>>({})
  const [isDirty, setIsDirty] = useState(false)
  const [isSubmitting, setIsSubmitting] = useState(false)
  
  const handleChange = <K extends keyof T>(field: K, value: T[K]) => {
    setFormData(prev => ({ ...prev, [field]: value }))
    setIsDirty(true)
    
    // Clear error for this field
    if (errors[field as string]) {
      setErrors(prev => {
        const next = { ...prev }
        delete next[field as string]
        return next
      })
    }
  }
  
  const handleSubmit = async (e?: React.FormEvent) => {
    e?.preventDefault()
    
    // Validate
    if (options.validate) {
      const validationErrors = options.validate(formData as T)
      if (Object.keys(validationErrors).length > 0) {
        setErrors(validationErrors)
        return false
      }
    }
    
    setIsSubmitting(true)
    setErrors({})
    
    try {
      if (options.onSubmit) {
        await options.onSubmit(formData as T)
      }
      setIsDirty(false)
      return true
    } catch (err) {
      setErrors({ 
        submit: err instanceof Error ? err.message : 'Submission failed' 
      })
      return false
    } finally {
      setIsSubmitting(false)
    }
  }
  
  const handleReset = () => {
    setFormData(options.initialData || {})
    setErrors({})
    setIsDirty(false)
  }
  
  const setFieldError = (field: string, error: string) => {
    setErrors(prev => ({ ...prev, [field]: error }))
  }
  
  return {
    formData,
    errors,
    isDirty,
    isSubmitting,
    handleChange,
    handleSubmit,
    handleReset,
    setFieldError,
    setFormData
  }
}
`
}

function generateActionHandlers(): string {
  return `/**
 * Action Handlers
 * 
 * CATEGORY 3: User actions (clicks, confirmations, side effects)
 * Handles: submit, cancel, delete, custom actions
 */

'use client'

import { useState } from 'react'

export type ActionType = 'submit' | 'cancel' | 'delete' | 'custom'

export interface ActionOptions {
  confirm?: string  // Confirmation message
  onComplete?: () => void
  onError?: (error: Error) => void
}

export function useActionHandlers() {
  const [isConfirming, setIsConfirming] = useState(false)
  const [isExecuting, setIsExecuting] = useState(false)
  
  const confirmAction = async (message: string): Promise<boolean> => {
    setIsConfirming(true)
    // TODO: Replace with custom modal in production
    const confirmed = window.confirm(message)
    setIsConfirming(false)
    return confirmed
  }
  
  const handleAction = async (
    action: ActionType,
    callback?: () => void | Promise<void>,
    options: ActionOptions = {}
  ) => {
    // Confirmation for destructive actions
    if (options.confirm) {
      const confirmed = await confirmAction(options.confirm)
      if (!confirmed) return false
    }
    
    setIsExecuting(true)
    
    try {
      if (callback) {
        await callback()
      }
      options.onComplete?.()
      return true
    } catch (err) {
      options.onError?.(err as Error)
      return false
    } finally {
      setIsExecuting(false)
    }
  }
  
  const handleDelete = async (
    callback: () => void | Promise<void>,
    message: string = 'Are you sure you want to delete this?'
  ) => {
    return handleAction('delete', callback, { confirm: message })
  }
  
  const handleCancel = async (
    callback?: () => void | Promise<void>,
    checkUnsaved: boolean = false,
    message: string = 'Discard unsaved changes?'
  ) => {
    return handleAction('cancel', callback, {
      confirm: checkUnsaved ? message : undefined
    })
  }
  
  return {
    handleAction,
    handleDelete,
    handleCancel,
    isConfirming,
    isExecuting
  }
}
`
}

function generateNavigationHandlers(): string {
  return `/**
 * Navigation Handlers
 * 
 * CATEGORY 4: Navigation (routing, back, external links)
 * Handles: route navigation, back button, external links
 */

'use client'

import { useRouter } from 'next/navigation'

export interface NavigateOptions {
  replace?: boolean
  scroll?: boolean
  checkUnsaved?: boolean
  confirmMessage?: string
}

export function useNavigationHandlers() {
  const router = useRouter()
  
  const navigateTo = async (
    path: string, 
    options: NavigateOptions = {}
  ) => {
    // Check for unsaved changes
    if (options.checkUnsaved && options.confirmMessage) {
      const confirmed = window.confirm(options.confirmMessage)
      if (!confirmed) return false
    }
    
    if (options.replace) {
      router.replace(path)
    } else {
      router.push(path)
    }
    
    return true
  }
  
  const navigateBack = (fallbackPath?: string) => {
    if (window.history.length > 1) {
      router.back()
    } else if (fallbackPath) {
      router.push(fallbackPath)
    }
  }
  
  const navigateExternal = (url: string, newTab: boolean = true) => {
    if (newTab) {
      window.open(url, '_blank', 'noopener,noreferrer')
    } else {
      window.location.href = url
    }
  }
  
  const refresh = () => {
    router.refresh()
  }
  
  return {
    navigateTo,
    navigateBack,
    navigateExternal,
    refresh,
    router
  }
}
`
}

function generateHandlersIndex(): string {
  return `/**
 * Centralized Handlers
 * 
 * 4 handler categories covering broad use cases
 */

export { useDataHandlers, type DataAction, type UseDataHandlersOptions } from './useDataHandlers.js'
export { useFormHandlers, type UseFormHandlersOptions } from './useFormHandlers.js'
export { useActionHandlers, type ActionType, type ActionOptions } from './useActionHandlers.js'
export { useNavigationHandlers, type NavigateOptions } from './useNavigationHandlers.js'
`
}

