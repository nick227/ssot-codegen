/**
 * DTO Generator - Generates TypeScript DTOs from Prisma models
 */

import type { ParsedModel, ParsedField } from '../dmmf-parser.js'
import { mapPrismaToTypeScript, getTypeImports } from '../type-mapper.js'
import { isOptionalForCreate, isNullable } from '../dmmf-parser.js'

/**
 * Generate Create DTO
 */
export function generateCreateDTO(model: ParsedModel): string {
  const imports = getTypeImports(model.createFields)
  const fields = model.createFields.map(field => {
    const optional = isOptionalForCreate(field) ? '?' : ''
    const type = mapPrismaToTypeScript(field)
    return `  ${field.name}${optional}: ${type}`
  }).join('\n')
  
  const importsSection = imports.length > 0 ? imports.join('\n') + '\n\n' : ''
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

${importsSection}export interface ${model.name}CreateDTO {
${fields}
}
`
}

/**
 * Generate Update DTO (all fields optional for PATCH)
 */
export function generateUpdateDTO(model: ParsedModel): string {
  const imports = getTypeImports(model.updateFields)
  const fields = model.updateFields.map(field => {
    const type = mapPrismaToTypeScript(field)
    return `  ${field.name}?: ${type}`
  }).join('\n')
  
  const importsSection = imports.length > 0 ? imports.join('\n') + '\n\n' : ''
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

${importsSection}export interface ${model.name}UpdateDTO {
${fields}
}
`
}

/**
 * Generate Read DTO (all scalar fields from DB)
 */
export function generateReadDTO(model: ParsedModel): string {
  const imports = getTypeImports(model.readFields)
  const fields = model.readFields.map(field => {
    const optional = !field.isRequired ? '?' : ''
    const type = mapPrismaToTypeScript(field)
    return `  ${field.name}${optional}: ${type}`
  }).join('\n')
  
  const importsSection = imports.length > 0 ? imports.join('\n') + '\n\n' : ''
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

${importsSection}export interface ${model.name}ReadDTO {
${fields}
}
`
}

/**
 * Generate Query DTO (for filtering, pagination, sorting)
 */
export function generateQueryDTO(model: ParsedModel): string {
  const modelLower = model.nameLower  // Use cached lowercase name
  const idField = model.idField
  const idType = idField ? mapPrismaToTypeScript(idField) : 'number'
  
  // Generate where clause type
  const filterableFields = model.scalarFields.filter(f => 
    !f.isReadOnly && !f.isUpdatedAt
  )
  
  const whereFields = filterableFields.map(field => {
    const baseType = mapPrismaToTypeScript(field)
    
    if (field.type === 'String') {
      return `    ${field.name}?: {
      equals?: ${baseType}
      contains?: ${baseType}
      startsWith?: ${baseType}
      endsWith?: ${baseType}
    }`
    } else if (field.type === 'Int' || field.type === 'Float' || field.type === 'DateTime') {
      return `    ${field.name}?: {
      equals?: ${baseType}
      gt?: ${baseType}
      gte?: ${baseType}
      lt?: ${baseType}
      lte?: ${baseType}
    }`
    } else {
      return `    ${field.name}?: ${baseType}`
    }
  }).join('\n')
  
  // Build orderBy type (single reduce pass instead of two map() + spread)
  const orderByFields = model.fields.reduce((acc, f) => {
    if (f.kind !== 'object') {
      acc.push(`    ${f.name}?: 'asc' | 'desc'`)
    } else {
      acc.push(`    ${f.name}?: { [key: string]: 'asc' | 'desc' }`)
    }
    return acc
  }, [] as string[])
  const orderByType = orderByFields.length > 0
    ? `{\n${orderByFields.join('\n')}\n  }`
    : `Record<string, 'asc' | 'desc'>`
  
  // Build include type
  const includeFields = model.relationFields
    .map(f => `    ${f.name}?: boolean`)
  const includeType = includeFields.length > 0
    ? `{\n${includeFields.join('\n')}\n  }`
    : 'Record<string, boolean>'
  
  // Build select type
  const selectFields = model.fields
    .map(f => `    ${f.name}?: boolean`)
  const selectType = `{\n${selectFields.join('\n')}\n  }`
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import type { ${model.name}ReadDTO } from './${modelLower}.read.dto.js'

export interface ${model.name}QueryDTO {
  skip?: number
  take?: number
  orderBy?: ${orderByType}
  where?: {
${whereFields}
  }
  include?: ${includeType}
  select?: ${selectType}
}

export interface ${model.name}ListResponse {
  data: ${model.name}ReadDTO[]
  meta: {
    total: number
    skip: number
    take: number
    hasMore: boolean
  }
}
`
}

/**
 * Generate all DTOs for a model
 */
export function generateAllDTOs(model: ParsedModel): {
  create: string
  update: string
  read: string
  query: string
} {
  return {
    create: generateCreateDTO(model),
    update: generateUpdateDTO(model),
    read: generateReadDTO(model),
    query: generateQueryDTO(model)
  }
}

/**
 * Generate barrel export for contracts
 */
export function generateContractsBarrel(model: ParsedModel): string {
  return `// @generated barrel
export * from './${model.name.toLowerCase()}.create.dto.js'
export * from './${model.name.toLowerCase()}.update.dto.js'
export * from './${model.name.toLowerCase()}.read.dto.js'
export * from './${model.name.toLowerCase()}.query.dto.js'
`
}


