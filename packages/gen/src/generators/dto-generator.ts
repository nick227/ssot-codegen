/**
 * DTO Generator - Generates TypeScript DTOs from Prisma models
 * 
 * Generates:
 * - CreateDTO: For POST requests (optional fields based on defaults)
 * - UpdateDTO: For PATCH requests (all fields optional)
 * - ReadDTO: For responses (all fields present)
 * - QueryDTO: For filtering, pagination, sorting
 */

import type { ParsedModel } from '../dmmf-parser.js'
import { mapPrismaToTypeScript, getTypeImports } from '../type-mapper.js'
import { isOptionalForCreate } from '../dmmf-parser.js'
import { toKebabCase } from '@/utils/naming.js'

export { generateContractsBarrel } from './barrel-generator.js'

/**
 * Validate model has required properties for DTO generation
 * @throws Error if model is invalid
 */
function validateModel(model: ParsedModel, context: string): void {
  if (!model || typeof model !== 'object') {
    throw new Error(`${context}: Invalid model (not an object)`)
  }
  
  if (!model.name || typeof model.name !== 'string') {
    throw new Error(`${context}: Model missing 'name' property`)
  }
  
  if (!model.fields || !Array.isArray(model.fields)) {
    throw new Error(`${context}: Model ${model.name} missing 'fields' array`)
  }
}

/**
 * Validate model has required field arrays
 */
function validateFieldArrays(model: ParsedModel, arrayName: keyof ParsedModel): void {
  const fields = model[arrayName]
  
  if (!fields || !Array.isArray(fields)) {
    throw new Error(`Model ${model.name} missing '${arrayName}' array`)
  }
}

/**
 * Generate Create DTO
 * Fields with defaults or nullable fields are optional (?)
 * Nullable fields also get | null from mapPrismaToTypeScript
 */
export function generateCreateDTO(model: ParsedModel): string {
  validateModel(model, 'generateCreateDTO')
  validateFieldArrays(model, 'createFields')
  
  try {
    const imports = getTypeImports(model.createFields)
    const fields = model.createFields.map(field => {
      if (!field || !field.name) {
        throw new Error(`Invalid field in model ${model.name}`)
      }
      
      const optional = isOptionalForCreate(field) ? '?' : ''
      const type = mapPrismaToTypeScript(field)
      
      if (!type) {
        throw new Error(`Failed to map type for field ${field.name}`)
      }
      
      return `  ${field.name}${optional}: ${type}`
    }).join('\n')
    
    const importsSection = imports.length > 0 ? imports.join('\n') + '\n\n' : ''
    
    return `// @generated
// This file is automatically generated. Do not edit manually.

${importsSection}export interface ${model.name}CreateDTO {
${fields}
}
`
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    throw new Error(`Failed to generate CreateDTO for ${model.name}: ${message}`)
  }
}

/**
 * Generate Update DTO (all fields optional for PATCH operations)
 * Note: This is for PATCH (partial updates). For PUT (full replacement),
 * consider using a separate DTO that includes the ID and requires all fields.
 */
export function generateUpdateDTO(model: ParsedModel): string {
  validateModel(model, 'generateUpdateDTO')
  validateFieldArrays(model, 'updateFields')
  
  try {
    const imports = getTypeImports(model.updateFields)
    const fields = model.updateFields.map(field => {
      if (!field || !field.name) {
        throw new Error(`Invalid field in model ${model.name}`)
      }
      
      const type = mapPrismaToTypeScript(field)
      
      if (!type) {
        throw new Error(`Failed to map type for field ${field.name}`)
      }
      
      return `  ${field.name}?: ${type}`
    }).join('\n')
    
    const importsSection = imports.length > 0 ? imports.join('\n') + '\n\n' : ''
    
    return `// @generated
// This file is automatically generated. Do not edit manually.

${importsSection}export interface ${model.name}UpdateDTO {
${fields}
}
`
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    throw new Error(`Failed to generate UpdateDTO for ${model.name}: ${message}`)
  }
}

/**
 * Generate Read DTO (all scalar fields from DB)
 * Read DTOs return all fields from the database response:
 * - Required fields: field: string
 * - Nullable fields: field: string | null (always present in response, value can be null)
 * Note: We don't use ? (optional) because DB queries always return all selected fields
 */
export function generateReadDTO(model: ParsedModel): string {
  validateModel(model, 'generateReadDTO')
  validateFieldArrays(model, 'readFields')
  
  try {
    const imports = getTypeImports(model.readFields)
    const fields = model.readFields.map(field => {
      if (!field || !field.name) {
        throw new Error(`Invalid field in model ${model.name}`)
      }
      
      const type = mapPrismaToTypeScript(field)
      
      if (!type) {
        throw new Error(`Failed to map type for field ${field.name}`)
      }
      
      return `  ${field.name}: ${type}`
    }).join('\n')
    
    const importsSection = imports.length > 0 ? imports.join('\n') + '\n\n' : ''
    
    return `// @generated
// This file is automatically generated. Do not edit manually.

${importsSection}export interface ${model.name}ReadDTO {
${fields}
}
`
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    throw new Error(`Failed to generate ReadDTO for ${model.name}: ${message}`)
  }
}

/**
 * Generate Query DTO (for filtering, pagination, sorting)
 */
export function generateQueryDTO(model: ParsedModel): string {
  validateModel(model, 'generateQueryDTO')
  validateFieldArrays(model, 'scalarFields')
  
  try {
    const modelKebab = toKebabCase(model.name)
    
    // Determine cursor type for pagination
    // FIXED: Better default than 'unknown' for type safety
    let cursorType = 'string'  // Safe default (most IDs are strings)
    
    if (model.idField) {
      const idType = mapPrismaToTypeScript(model.idField)
      cursorType = idType || 'string'
    } else if (model.primaryKey && model.primaryKey.fields.length > 0) {
      // For composite keys, build object type from key fields
      // FIXED: Cache field map to avoid repeated lookups (O(n²) → O(n))
      const fieldMap = new Map(model.fields.map(f => [f.name, f]))
      
      const keyFields = model.primaryKey.fields
        .map(fieldName => {
          const field = fieldMap.get(fieldName)
          if (!field) {
            console.warn(`[DTO] Primary key field '${fieldName}' not found in model ${model.name}`)
            return null
          }
          const fieldType = mapPrismaToTypeScript(field)
          if (!fieldType) {
            console.warn(`[DTO] Failed to map type for primary key field '${fieldName}' in ${model.name}`)
            return null
          }
          return `${fieldName}: ${fieldType}`
        })
        .filter((x): x is string => x !== null)
      
      if (keyFields.length > 0) {
        cursorType = `{ ${keyFields.join('; ')} }`
      }
    }
  
  // Generate where clause type
  const filterableFields = model.scalarFields.filter(f => 
    !f.isReadOnly && !f.isUpdatedAt
  )
  
  const whereFields = filterableFields.map(field => {
    const baseType = mapPrismaToTypeScript(field)
    const isNullable = !field.isRequired
    
    if (field.type === 'String') {
      const nullOps = isNullable ? '\n      isNull?: boolean' : ''
      return `    ${field.name}?: ${baseType} | {
      equals?: ${baseType}
      contains?: ${baseType}
      startsWith?: ${baseType}
      endsWith?: ${baseType}
      in?: ${baseType}[]
      notIn?: ${baseType}[]
      not?: ${baseType}
      mode?: 'default' | 'insensitive'${nullOps}
    }`
    } else if (field.type === 'Int' || field.type === 'Float') {
      const nullOps = isNullable ? '\n      isNull?: boolean' : ''
      return `    ${field.name}?: ${baseType} | {
      equals?: ${baseType}
      gt?: ${baseType}
      gte?: ${baseType}
      lt?: ${baseType}
      lte?: ${baseType}
      in?: ${baseType}[]
      notIn?: ${baseType}[]
      not?: ${baseType}${nullOps}
    }`
    } else if (field.type === 'DateTime') {
      // DateTime accepts both Date objects and ISO 8601 strings
      const dateType = 'Date | string'
      const nullOps = isNullable ? '\n      isNull?: boolean' : ''
      return `    ${field.name}?: ${dateType} | {
      equals?: ${dateType}
      gt?: ${dateType}
      gte?: ${dateType}
      lt?: ${dateType}
      lte?: ${dateType}
      in?: ${dateType}[]
      notIn?: ${dateType}[]${nullOps}
    }`
    } else if (field.type === 'Boolean') {
      // Booleans support both simple assignment and object filters
      return `    ${field.name}?: ${baseType} | {
      equals?: ${baseType}
      not?: ${baseType}
    }`
    } else if (field.kind === 'enum') {
      // Enums support both simple assignment and object filters
      const nullOps = isNullable ? '\n      isNull?: boolean' : ''
      return `    ${field.name}?: ${baseType} | {
      equals?: ${baseType}
      in?: ${baseType}[]
      notIn?: ${baseType}[]
      not?: ${baseType}${nullOps}
    }`
    } else if (field.isList) {
      // Array fields support specific operators
      return `    ${field.name}?: {
      has?: ${baseType}
      hasSome?: ${baseType}[]
      hasEvery?: ${baseType}[]
      isEmpty?: boolean
    }`
    } else {
      // Fallback for other types (Json, Bytes, etc.)
      const nullOps = isNullable ? ' | { isNull?: boolean }' : ''
      return `    ${field.name}?: ${baseType}${nullOps}`
    }
  }).join('\n')
  
  // Build orderBy type - simplified from reduce to map
  const orderByFields = model.fields.map(f => 
    f.kind !== 'object'
      ? `    ${f.name}?: 'asc' | 'desc'`
      : `    ${f.name}?: { [key: string]: 'asc' | 'desc' }`
  )
  const orderByType = orderByFields.length > 0
    ? `{\n${orderByFields.join('\n')}\n  }`
    : `Record<string, 'asc' | 'desc'>`
  
  // Build include type (supports nested includes)
  const includeFields = model.relationFields
    .map(f => `    ${f.name}?: boolean | { include?: any; select?: any }`)
  const includeType = includeFields.length > 0
    ? `{\n${includeFields.join('\n')}\n  }`
    : 'Record<string, boolean | { include?: any; select?: any }>'
  
  // Build select type (supports nested selects)
  const selectScalarFields = model.scalarFields
    .map(f => `    ${f.name}?: boolean`)
  const selectRelationFields = model.relationFields
    .map(f => `    ${f.name}?: boolean | { select?: any; include?: any }`)
  const allSelectFields = [...selectScalarFields, ...selectRelationFields]
  const selectType = allSelectFields.length > 0
    ? `{\n${allSelectFields.join('\n')}\n  }`
    : `Record<string, boolean>`
  
  // Build where type with logical operators
  let whereType: string
  if (whereFields.length > 0) {
    whereType = `{\n${whereFields}\n    AND?: ${model.name}WhereInput[]\n    OR?: ${model.name}WhereInput[]\n    NOT?: ${model.name}WhereInput[]\n  }`
  } else {
    // Empty object is valid (matches all records)
    whereType = '{}'
  }
  
  // Define recursive where type
  const whereTypeDef = `type ${model.name}WhereInput = ${whereType}`
  
  // Build distinct type from scalar field names  
  const distinctFields = model.scalarFields
    .filter(f => !f.isReadOnly && !f.isUpdatedAt)
    .map(f => `'${f.name}'`)
    .join(' | ')
  
  // Non-empty array type for distinct (prevents [])
  const distinctArrayType = distinctFields ? `[${distinctFields}, ...${distinctFields}[]]` : 'never'
  
    return `// @generated
// This file is automatically generated. Do not edit manually.

import type { ${model.name}ReadDTO } from './${modelKebab}.read.dto.js'

${whereTypeDef}

export interface ${model.name}QueryDTO {
  skip?: number  // Offset pagination (should be >= 0)
  take?: number  // Limit (should be > 0)
  cursor?: ${cursorType}  // Cursor for cursor-based pagination
  orderBy?: ${orderByType}
  where?: ${model.name}WhereInput
  include?: ${includeType}
  select?: ${selectType}${distinctFields ? `\n  distinct?: ${distinctFields} | ${distinctArrayType}` : ''}
}

export interface ${model.name}ListResponse {
  data: ${model.name}ReadDTO[]
  meta: {
    total: number
    skip: number
    take: number
    hasMore: boolean  // Calculated as: skip + take < total
  }
}
`
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    throw new Error(`Failed to generate QueryDTO for ${model.name}: ${message}`)
  }
}

/**
 * Generate all DTOs for a model
 * 
 * @param model - Parsed Prisma model
 * @returns Object containing all four DTO types
 * @throws Error if model is invalid or DTO generation fails
 */
export function generateAllDTOs(model: ParsedModel): {
  create: string
  update: string
  read: string
  query: string
} {
  // Validate model upfront before generating any DTOs
  validateModel(model, 'generateAllDTOs')
  
  try {
    return {
      create: generateCreateDTO(model),
      update: generateUpdateDTO(model),
      read: generateReadDTO(model),
      query: generateQueryDTO(model)
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    throw new Error(`Failed to generate DTOs for ${model.name}: ${message}`)
  }
}

