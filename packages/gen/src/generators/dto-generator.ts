/**
 * DTO Generator - Generates TypeScript DTOs from Prisma models
 */

import type { ParsedModel } from '../dmmf-parser.js'
import { mapPrismaToTypeScript, getTypeImports } from '../type-mapper.js'
import { isOptionalForCreate } from '../dmmf-parser.js'
import { toKebabCase } from '@/utils/naming.js'

export { generateContractsBarrel } from './barrel-generator.js'

/**
 * Generate Create DTO
 * Fields with defaults or nullable fields are optional (?)
 * Nullable fields also get | null from mapPrismaToTypeScript
 */
export function generateCreateDTO(model: ParsedModel): string {
  const imports = getTypeImports(model.createFields)
  const fields = model.createFields.map(field => {
    const optional = isOptionalForCreate(field) ? '?' : ''
    const type = mapPrismaToTypeScript(field)
    return `  ${field.name}${optional}: ${type}`
  }).join('\n')
  
  const importsSection = imports.length > 0 ? imports.join('\n') + '\n\n' : ''
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

${importsSection}export interface ${model.name}CreateDTO {
${fields}
}
`
}

/**
 * Generate Update DTO (all fields optional for PATCH operations)
 * For PUT operations requiring all fields, use CreateDTO or generate a separate DTO
 */
export function generateUpdateDTO(model: ParsedModel): string {
  const imports = getTypeImports(model.updateFields)
  const fields = model.updateFields.map(field => {
    // All fields optional for PATCH; type already includes | null for nullable fields
    const type = mapPrismaToTypeScript(field)
    return `  ${field.name}?: ${type}`
  }).join('\n')
  
  const importsSection = imports.length > 0 ? imports.join('\n') + '\n\n' : ''
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

${importsSection}export interface ${model.name}UpdateDTO {
${fields}
}
`
}

/**
 * Generate Read DTO (all scalar fields from DB)
 * Read DTOs return all fields - nullable fields use `| null`, not `?`
 */
export function generateReadDTO(model: ParsedModel): string {
  const imports = getTypeImports(model.readFields)
  const fields = model.readFields.map(field => {
    // Read DTOs always have all fields present (no ? modifier)
    // Nullability is handled by mapPrismaToTypeScript adding | null
    const type = mapPrismaToTypeScript(field)
    return `  ${field.name}: ${type}`
  }).join('\n')
  
  const importsSection = imports.length > 0 ? imports.join('\n') + '\n\n' : ''
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

${importsSection}export interface ${model.name}ReadDTO {
${fields}
}
`
}

/**
 * Generate Query DTO (for filtering, pagination, sorting)
 */
export function generateQueryDTO(model: ParsedModel): string {
  const modelKebab = toKebabCase(model.name)
  
  // Generate where clause type
  const filterableFields = model.scalarFields.filter(f => 
    !f.isReadOnly && !f.isUpdatedAt
  )
  
  const whereFields = filterableFields.map(field => {
    const baseType = mapPrismaToTypeScript(field)
    
    if (field.type === 'String') {
      return `    ${field.name}?: {
      equals?: ${baseType}
      contains?: ${baseType}
      startsWith?: ${baseType}
      endsWith?: ${baseType}
    }`
    } else if (field.type === 'Int' || field.type === 'Float' || field.type === 'DateTime') {
      return `    ${field.name}?: {
      equals?: ${baseType}
      gt?: ${baseType}
      gte?: ${baseType}
      lt?: ${baseType}
      lte?: ${baseType}
    }`
    } else {
      return `    ${field.name}?: ${baseType}`
    }
  }).join('\n')
  
  // Build orderBy type - simplified from reduce to map
  const orderByFields = model.fields.map(f => 
    f.kind !== 'object'
      ? `    ${f.name}?: 'asc' | 'desc'`
      : `    ${f.name}?: { [key: string]: 'asc' | 'desc' }`
  )
  const orderByType = orderByFields.length > 0
    ? `{\n${orderByFields.join('\n')}\n  }`
    : `Record<string, 'asc' | 'desc'>`
  
  // Build include type
  const includeFields = model.relationFields
    .map(f => `    ${f.name}?: boolean`)
  const includeType = includeFields.length > 0
    ? `{\n${includeFields.join('\n')}\n  }`
    : 'Record<string, boolean>'
  
  // Build select type
  const selectFields = model.fields
    .map(f => `    ${f.name}?: boolean`)
  const selectType = `{\n${selectFields.join('\n')}\n  }`
  
  // Build where type - handle empty case
  const whereType = whereFields.length > 0
    ? `{\n${whereFields}\n  }`
    : 'Record<string, any>'
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import type { ${model.name}ReadDTO } from './${modelKebab}.read.dto.js'

export interface ${model.name}QueryDTO {
  skip?: number
  take?: number
  orderBy?: ${orderByType}
  where?: ${whereType}
  include?: ${includeType}
  select?: ${selectType}
}

export interface ${model.name}ListResponse {
  data: ${model.name}ReadDTO[]
  meta: {
    total: number
    skip: number
    take: number
    hasMore: boolean
  }
}
`
}

/**
 * Generate all DTOs for a model
 */
export function generateAllDTOs(model: ParsedModel): {
  create: string
  update: string
  read: string
  query: string
} {
  return {
    create: generateCreateDTO(model),
    update: generateUpdateDTO(model),
    read: generateReadDTO(model),
    query: generateQueryDTO(model)
  }
}

