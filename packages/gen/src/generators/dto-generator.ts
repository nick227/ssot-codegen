/**
 * DTO Generator - Generates TypeScript DTOs from Prisma models
 */

import type { ParsedModel } from '../dmmf-parser.js'
import { mapPrismaToTypeScript, getTypeImports } from '../type-mapper.js'
import { isOptionalForCreate } from '../dmmf-parser.js'
import { toKebabCase } from '@/utils/naming.js'

export { generateContractsBarrel } from './barrel-generator.js'

/**
 * Generate Create DTO
 * Fields with defaults or nullable fields are optional (?)
 * Nullable fields also get | null from mapPrismaToTypeScript
 */
export function generateCreateDTO(model: ParsedModel): string {
  const imports = getTypeImports(model.createFields)
  const fields = model.createFields.map(field => {
    const optional = isOptionalForCreate(field) ? '?' : ''
    const type = mapPrismaToTypeScript(field)
    return `  ${field.name}${optional}: ${type}`
  }).join('\n')
  
  const importsSection = imports.length > 0 ? imports.join('\n') + '\n\n' : ''
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

${importsSection}export interface ${model.name}CreateDTO {
${fields}
}
`
}

/**
 * Generate Update DTO (all fields optional for PATCH operations)
 * Note: This is for PATCH (partial updates). For PUT (full replacement),
 * consider using a separate DTO that includes the ID and requires all fields.
 */
export function generateUpdateDTO(model: ParsedModel): string {
  const imports = getTypeImports(model.updateFields)
  const fields = model.updateFields.map(field => {
    // All fields optional for PATCH; type already includes | null for nullable fields
    const type = mapPrismaToTypeScript(field)
    return `  ${field.name}?: ${type}`
  }).join('\n')
  
  const importsSection = imports.length > 0 ? imports.join('\n') + '\n\n' : ''
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

${importsSection}export interface ${model.name}UpdateDTO {
${fields}
}
`
}

/**
 * Generate Read DTO (all scalar fields from DB)
 * Read DTOs return all fields from the database response:
 * - Required fields: field: string
 * - Nullable fields: field: string | null (always present in response, value can be null)
 * Note: We don't use ? (optional) because DB queries always return all selected fields
 */
export function generateReadDTO(model: ParsedModel): string {
  const imports = getTypeImports(model.readFields)
  const fields = model.readFields.map(field => {
    // All fields present in DB response (no ? modifier)
    // Nullable fields get | null union type from mapPrismaToTypeScript
    const type = mapPrismaToTypeScript(field)
    return `  ${field.name}: ${type}`
  }).join('\n')
  
  const importsSection = imports.length > 0 ? imports.join('\n') + '\n\n' : ''
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

${importsSection}export interface ${model.name}ReadDTO {
${fields}
}
`
}

/**
 * Generate Query DTO (for filtering, pagination, sorting)
 */
export function generateQueryDTO(model: ParsedModel): string {
  const modelKebab = toKebabCase(model.name)
  
  // Determine cursor type for pagination (use ID field if available)
  let cursorType = 'unknown'
  if (model.idField) {
    const idType = mapPrismaToTypeScript(model.idField)
    cursorType = idType || 'unknown'
  } else if (model.primaryKey && model.primaryKey.fields.length > 0) {
    // For composite keys, build object type from key fields
    const keyFields = model.primaryKey.fields
      .map(fieldName => {
        const field = model.fields.find(f => f.name === fieldName)
        if (!field) return null
        const fieldType = mapPrismaToTypeScript(field)
        return fieldType ? `${fieldName}: ${fieldType}` : null
      })
      .filter((x): x is string => x !== null)
    
    if (keyFields.length > 0) {
      cursorType = `{ ${keyFields.join('; ')} }`
    }
  }
  
  // Generate where clause type
  const filterableFields = model.scalarFields.filter(f => 
    !f.isReadOnly && !f.isUpdatedAt
  )
  
  const whereFields = filterableFields.map(field => {
    const baseType = mapPrismaToTypeScript(field)
    const isNullable = !field.isRequired
    
    if (field.type === 'String') {
      const nullOps = isNullable ? '\n      isNull?: boolean' : ''
      return `    ${field.name}?: ${baseType} | {
      equals?: ${baseType}
      contains?: ${baseType}
      startsWith?: ${baseType}
      endsWith?: ${baseType}
      in?: ${baseType}[]
      notIn?: ${baseType}[]
      not?: ${baseType}
      mode?: 'default' | 'insensitive'${nullOps}
    }`
    } else if (field.type === 'Int' || field.type === 'Float') {
      const nullOps = isNullable ? '\n      isNull?: boolean' : ''
      return `    ${field.name}?: ${baseType} | {
      equals?: ${baseType}
      gt?: ${baseType}
      gte?: ${baseType}
      lt?: ${baseType}
      lte?: ${baseType}
      in?: ${baseType}[]
      notIn?: ${baseType}[]
      not?: ${baseType}${nullOps}
    }`
    } else if (field.type === 'DateTime') {
      // DateTime accepts both Date objects and ISO 8601 strings
      const dateType = 'Date | string'
      const nullOps = isNullable ? '\n      isNull?: boolean' : ''
      return `    ${field.name}?: ${dateType} | {
      equals?: ${dateType}
      gt?: ${dateType}
      gte?: ${dateType}
      lt?: ${dateType}
      lte?: ${dateType}
      in?: ${dateType}[]
      notIn?: ${dateType}[]${nullOps}
    }`
    } else if (field.type === 'Boolean') {
      // Booleans support both simple assignment and object filters
      return `    ${field.name}?: ${baseType} | {
      equals?: ${baseType}
      not?: ${baseType}
    }`
    } else if (field.kind === 'enum') {
      // Enums support both simple assignment and object filters
      const nullOps = isNullable ? '\n      isNull?: boolean' : ''
      return `    ${field.name}?: ${baseType} | {
      equals?: ${baseType}
      in?: ${baseType}[]
      notIn?: ${baseType}[]
      not?: ${baseType}${nullOps}
    }`
    } else if (field.isList) {
      // Array fields support specific operators
      return `    ${field.name}?: {
      has?: ${baseType}
      hasSome?: ${baseType}[]
      hasEvery?: ${baseType}[]
      isEmpty?: boolean
    }`
    } else {
      // Fallback for other types (Json, Bytes, etc.)
      const nullOps = isNullable ? ' | { isNull?: boolean }' : ''
      return `    ${field.name}?: ${baseType}${nullOps}`
    }
  }).join('\n')
  
  // Build orderBy type - simplified from reduce to map
  const orderByFields = model.fields.map(f => 
    f.kind !== 'object'
      ? `    ${f.name}?: 'asc' | 'desc'`
      : `    ${f.name}?: { [key: string]: 'asc' | 'desc' }`
  )
  const orderByType = orderByFields.length > 0
    ? `{\n${orderByFields.join('\n')}\n  }`
    : `Record<string, 'asc' | 'desc'>`
  
  // Build include type (supports nested includes)
  const includeFields = model.relationFields
    .map(f => `    ${f.name}?: boolean | { include?: any; select?: any }`)
  const includeType = includeFields.length > 0
    ? `{\n${includeFields.join('\n')}\n  }`
    : 'Record<string, boolean | { include?: any; select?: any }>'
  
  // Build select type (supports nested selects)
  const selectScalarFields = model.scalarFields
    .map(f => `    ${f.name}?: boolean`)
  const selectRelationFields = model.relationFields
    .map(f => `    ${f.name}?: boolean | { select?: any; include?: any }`)
  const allSelectFields = [...selectScalarFields, ...selectRelationFields]
  const selectType = allSelectFields.length > 0
    ? `{\n${allSelectFields.join('\n')}\n  }`
    : `Record<string, boolean>`
  
  // Build where type with logical operators
  let whereType: string
  if (whereFields.length > 0) {
    whereType = `{\n${whereFields}\n    AND?: ${model.name}WhereInput[]\n    OR?: ${model.name}WhereInput[]\n    NOT?: ${model.name}WhereInput[]\n  }`
  } else {
    // Empty object is valid (matches all records)
    whereType = '{}'
  }
  
  // Define recursive where type
  const whereTypeDef = `type ${model.name}WhereInput = ${whereType}`
  
  // Build distinct type from scalar field names  
  const distinctFields = model.scalarFields
    .filter(f => !f.isReadOnly && !f.isUpdatedAt)
    .map(f => `'${f.name}'`)
    .join(' | ')
  
  // Non-empty array type for distinct (prevents [])
  const distinctArrayType = distinctFields ? `[${distinctFields}, ...${distinctFields}[]]` : 'never'
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import type { ${model.name}ReadDTO } from './${modelKebab}.read.dto.js'

${whereTypeDef}

export interface ${model.name}QueryDTO {
  skip?: number  // Offset pagination (should be >= 0)
  take?: number  // Limit (should be > 0)
  cursor?: ${cursorType}  // Cursor for cursor-based pagination
  orderBy?: ${orderByType}
  where?: ${model.name}WhereInput
  include?: ${includeType}
  select?: ${selectType}${distinctFields ? `\n  distinct?: ${distinctFields} | ${distinctArrayType}` : ''}
}

export interface ${model.name}ListResponse {
  data: ${model.name}ReadDTO[]
  meta: {
    total: number
    skip: number
    take: number
    hasMore: boolean  // Calculated as: skip + take < total
  }
}
`
}

/**
 * Generate all DTOs for a model
 */
export function generateAllDTOs(model: ParsedModel): {
  create: string
  update: string
  read: string
  query: string
} {
  return {
    create: generateCreateDTO(model),
    update: generateUpdateDTO(model),
    read: generateReadDTO(model),
    query: generateQueryDTO(model)
  }
}

