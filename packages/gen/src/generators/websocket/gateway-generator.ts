/**
 * WebSocket Gateway Generator
 * Generates server-side WebSocket gateway for real-time updates
 */

import type { ParsedModel } from '../../types/schema.js'
import type { WebSocketConfig } from './types.js'

export function generateWebSocketGateway(
  models: ParsedModel[],
  config: WebSocketConfig
): Map<string, string> {
  const files = new Map<string, string>()
  
  files.set('gateway.ts', generateGatewayClass(config))
  files.set('channels.ts', generateChannelRouter(models, config))
  files.set('auth.ts', generateAuthMiddleware())
  files.set('index.ts', generateIndex())
  
  return files
}

function generateGatewayClass(config: WebSocketConfig): string {
  const batchingEnabled = config.batching?.enabled ?? true
  const flushInterval = config.batching?.flushInterval ?? 100
  
  return `/**
 * WebSocket Gateway - Real-time event broadcasting
 * Generated by SSOT CodeGen
 */

import { WebSocketServer, WebSocket } from 'ws'
import type { Server } from 'http'
import { parse } from 'url'
import { authenticateToken } from './auth.js'
import { canSubscribe } from './channels.js'

export interface WebSocketClient {
  id: string
  ws: WebSocket
  user: any
  subscriptions: Set<string>
}

export class WebSocketGateway {
  private wss: WebSocketServer
  private clients = new Map<string, WebSocketClient>()
  private clientIdCounter = 0
  ${batchingEnabled ? `private updateBuffer: any[] = []
  private flushTimer?: NodeJS.Timeout` : ''}

  constructor(private server: Server) {
    this.wss = new WebSocketServer({
      server,
      path: '${config.path ?? '/ws'}'
    })

    this.wss.on('connection', this.handleConnection.bind(this))
  }

  private async handleConnection(ws: WebSocket, req: any): Promise<void> {
    const clientId = \`client-\${++this.clientIdCounter}\`
    
    const { query } = parse(req.url ?? '', true)
    const token = query.token as string
    const user = token ? await authenticateToken(token) : null
    
    if (!user) {
      ws.close(4401, 'Unauthorized')
      return
    }

    const client: WebSocketClient = {
      id: clientId,
      ws,
      user,
      subscriptions: new Set()
    }

    this.clients.set(clientId, client)

    ws.on('message', (data) => this.handleMessage(client, data))
    ws.on('close', () => this.handleDisconnect(client))
  }

  private async handleMessage(client: WebSocketClient, data: Buffer): Promise<void> {
    try {
      const message = JSON.parse(data.toString())
      
      switch (message.type) {
        case 'subscribe':
          await this.handleSubscribe(client, message.channel)
          break
        case 'unsubscribe':
          this.handleUnsubscribe(client, message.channel)
          break
        case 'request':
          await this.handleRequest(client, message)
          break
      }
    } catch (error) {
      this.send(client, {
        type: 'error',
        error: error instanceof Error ? error.message : 'Internal error'
      })
    }
  }

  private async handleSubscribe(client: WebSocketClient, channel: string): Promise<void> {
    if (!await canSubscribe(client.user, channel)) {
      this.send(client, {
        type: 'error',
        channel,
        error: 'Unauthorized'
      })
      return
    }

    client.subscriptions.add(channel)
    
    this.send(client, {
      type: 'subscribed',
      channel
    })
  }

  private handleUnsubscribe(client: WebSocketClient, channel: string): void {
    client.subscriptions.delete(channel)
    
    this.send(client, {
      type: 'unsubscribed',
      channel
    })
  }

  private async handleRequest(client: WebSocketClient, message: any): Promise<void> {
    const { requestId, model, action, params } = message
    
    try {
      const result = await this.processRequest(client.user, model, action, params)
      
      this.send(client, {
        type: 'response',
        requestId,
        data: result
      })
    } catch (error) {
      this.send(client, {
        type: 'response',
        requestId,
        error: error instanceof Error ? error.message : 'Request failed'
      })
    }
  }

  private handleDisconnect(client: WebSocketClient): void {
    this.clients.delete(client.id)
  }

  broadcast(channel: string, update: any): void {
    ${batchingEnabled ? `this.enqueueUpdate({ channel, update })` : `this.broadcastNow(channel, update)`}
  }
${batchingEnabled ? `
  private enqueueUpdate(item: any): void {
    this.updateBuffer.push(item)
    
    if (!this.flushTimer) {
      this.flushTimer = setTimeout(() => {
        this.flushUpdates()
      }, ${flushInterval})
    }
  }

  private flushUpdates(): void {
    const updates = this.updateBuffer
    this.updateBuffer = []
    this.flushTimer = undefined
    
    for (const { channel, update } of updates) {
      this.broadcastNow(channel, update)
    }
  }
` : ''}
  private broadcastNow(channel: string, update: any): void {
    for (const client of this.clients.values()) {
      if (client.subscriptions.has(channel)) {
        this.send(client, {
          type: 'update',
          channel,
          data: update
        })
      }
    }
  }

  private send(client: WebSocketClient, data: any): void {
    if (client.ws.readyState === WebSocket.OPEN) {
      client.ws.send(JSON.stringify(data))
    }
  }

  private async processRequest(user: any, model: string, action: string, params: any): Promise<any> {
    // TODO: Route to appropriate model client
    return null
  }

  close(): void {
    this.wss.close()
  }
}
`
}

function generateChannelRouter(models: ParsedModel[], config: WebSocketConfig): string {
  const channelConfigs = Object.entries(config.pubsub.models)
    .map(([modelName, cfg]) => {
      return `  '${modelName}': {
    subscribe: ${JSON.stringify(cfg.subscribe)},
    broadcast: ${JSON.stringify(cfg.broadcast)},
    permissions: {
      list: ${typeof cfg.permissions.list === 'string' ? `'${cfg.permissions.list}'` : 'undefined'},
      item: ${typeof cfg.permissions.item === 'string' ? `'${cfg.permissions.item}'` : 'undefined'}
    }
  }`
    })
    .join(',\n')
  
  return `/**
 * Channel Router - Permission and routing logic
 * Generated by SSOT CodeGen
 * 
 * Integrates with RLS plugin for unified security
 */

import { applyRLS, checkPermissions } from '../middleware/rls.js'

const CHANNEL_CONFIG: Record<string, any> = {
${channelConfigs}
}

export function getChannelConfig(model: string): any {
  return CHANNEL_CONFIG[model] ?? null
}

/**
 * Check if user can subscribe to channel
 * Integrates with RLS policies for consistent security
 */
export async function canSubscribe(user: any, channel: string): Promise<boolean> {
  const [model, operation, id] = channel.split(':')
  const config = getChannelConfig(model)
  
  if (!config?.subscribe?.includes(operation)) {
    return false
  }
  
  const permission = config.permissions?.[operation]
  
  // Evaluate permission rule (integrates with RLS)
  return evaluatePermission(user, model, permission, id)
}

/**
 * Filter broadcast data based on RLS policies
 * Ensures users only receive data they're allowed to see
 */
export function filterBroadcastData(model: string, data: any, user: any): any | null {
  // Apply RLS read policy
  const canRead = checkPermissions(model, user, 'read', data)
  if (!canRead) {
    return null  // Don't send to this user
  }
  
  // Apply field-level permissions
  return filterFields(model, data, user, 'read')
}

/**
 * Evaluate permission rule
 */
function evaluatePermission(user: any, model: string, permission: string, id?: string): boolean {
  if (!permission || permission === 'true') {
    return true
  }
  
  if (permission === 'authenticated') {
    return !!user
  }
  
  if (permission === 'isAdmin') {
    return user?.role === 'admin' || user?.isAdmin
  }
  
  if (permission === 'isOwner' && id) {
    // Check if user owns the resource
    return checkOwnership(user, model, id)
  }
  
  // Expression-based permission (e.g., "isOwner || isAdmin")
  return evaluateExpression(permission, { user, model, id })
}

/**
 * Check resource ownership (integrates with RLS)
 */
function checkOwnership(user: any, model: string, id: string): boolean {
  // TODO: Query database to check ownership
  // This should use RLS policies
  return false
}

/**
 * Filter fields based on permissions
 */
function filterFields(model: string, data: any, user: any, operation: 'read' | 'write'): any {
  // TODO: Apply field-level permissions from RLS plugin
  // For now, return full data
  return data
}

/**
 * Evaluate permission expression
 */
function evaluateExpression(expression: string, context: any): boolean {
  // TODO: Use expression engine to evaluate
  // For now, return false (fail-closed)
  return false
}
`
}

function generateAuthMiddleware(): string {
  return `/**
 * Authentication Middleware
 * Generated by SSOT CodeGen
 */

export async function authenticateToken(token: string): Promise<any | null> {
  // TODO: Implement token validation
  // This should verify JWT or session token
  // For now, return mock user
  
  if (!token) {
    return null
  }
  
  // Example: Decode JWT token
  // const user = await verifyJWT(token)
  // return user
  
  return { id: 'test-user', role: 'user' }
}
`
}

function generateIndex(): string {
  return `/**
 * WebSocket Module - Exports
 * Generated by SSOT CodeGen
 */

export * from './gateway.js'
export * from './channels.js'
export * from './auth.js'
`
}

