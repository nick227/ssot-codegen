/**
 * Enhanced Service Generator - Generates services with relationships and domain logic
 */

import type { ParsedModel, ParsedSchema } from '../dmmf-parser.js'
import { analyzeModel, generateSummaryInclude } from '../utils/relationship-analyzer.js'
import { generateEnhancedServiceMethods } from './service-method-generator.js'

/**
 * Generate enhanced service with relationships and domain methods
 */
export function generateEnhancedService(model: ParsedModel, schema: ParsedSchema): string {
  const analysis = analyzeModel(model, schema)
  const modelLower = model.name.toLowerCase()
  const idType = model.idField?.type === 'String' ? 'string' : 'number'
  
  // Base CRUD methods
  const baseMethods = generateBaseMethods(model, analysis, modelLower, idType)
  
  // Domain-specific methods
  const domainMethods = generateDomainMethods(model, analysis, modelLower, idType)
  
  // Extract existing method names to prevent duplicates
  const existingMethods = extractMethodNames(domainMethods)
  
  // Auto-detected enhanced methods (search, findBySlug, getFeatured, etc.)
  // Skip methods already generated by domain methods to prevent duplicates
  const enhancedMethods = generateEnhancedServiceMethods(model, existingMethods)
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import prisma from '@/db'
import type { ${model.name}CreateDTO, ${model.name}UpdateDTO, ${model.name}QueryDTO } from '@/contracts/${modelLower}'
import type { Prisma } from '@prisma/client'
import { logger } from '@/logger'

export const ${modelLower}Service = {
${baseMethods}${domainMethods}${enhancedMethods}
}
`
}

/**
 * Generate base CRUD methods with relationship loading
 */
function generateBaseMethods(
  model: ParsedModel,
  analysis: ReturnType<typeof analyzeModel>,
  modelLower: string,
  idType: string
): string {
  const includeStmt = generateSummaryInclude(analysis)
  
  return `  /**
   * List ${model.name} records with pagination${analysis.autoIncludeRelations.length > 0 ? ' and relationships' : ''}
   */
  async list(query: ${model.name}QueryDTO) {
    const { skip = 0, take = 20, orderBy, where } = query
    
    const [items, total] = await Promise.all([
      prisma.${modelLower}.findMany({
        skip,
        take,
        orderBy: orderBy as Prisma.${model.name}OrderByWithRelationInput,
        where: where as Prisma.${model.name}WhereInput${includeStmt}
      }),
      prisma.${modelLower}.count({
        where: where as Prisma.${model.name}WhereInput,
      })
    ])
    
    return {
      data: items,
      meta: {
        total,
        skip,
        take,
        hasMore: skip + take < total
      }
    }
  },
  
  /**
   * Find ${model.name} by ID${analysis.autoIncludeRelations.length > 0 ? ' with relationships' : ''}
   */
  async findById(id: ${idType}) {
    return prisma.${modelLower}.findUnique({
      where: { id }${includeStmt}
    })
  },
  
  /**
   * Create ${model.name}
   */
  async create(data: ${model.name}CreateDTO) {
    try {
      const item = await prisma.${modelLower}.create({
        data${includeStmt}
      })
      logger.info({ ${modelLower}Id: item.id }, '${model.name} created')
      return item
    } catch (error) {
      logger.error({ error, data }, 'Failed to create ${model.name}')
      throw error
    }
  },
  
  /**
   * Update ${model.name}
   */
  async update(id: ${idType}, data: ${model.name}UpdateDTO) {
    try {
      const item = await prisma.${modelLower}.update({
        where: { id },
        data${includeStmt}
      })
      logger.info({ ${modelLower}Id: id }, '${model.name} updated')
      return item
    } catch (error: any) {
      if (error.code === 'P2025') {
        logger.warn({ ${modelLower}Id: id }, '${model.name} not found for update')
        return null  // Not found
      }
      logger.error({ error, ${modelLower}Id: id, data }, 'Failed to update ${model.name}')
      throw error
    }
  },
  
  /**
   * Delete ${model.name}
   */
  async delete(id: ${idType}) {
    try {
      await prisma.${modelLower}.delete({
        where: { id }
      })
      logger.info({ ${modelLower}Id: id }, '${model.name} deleted')
      return true
    } catch (error: any) {
      if (error.code === 'P2025') {
        logger.warn({ ${modelLower}Id: id }, '${model.name} not found for delete')
        return false  // Not found
      }
      logger.error({ error, ${modelLower}Id: id }, 'Failed to delete ${model.name}')
      throw error
    }
  },
  
  /**
   * Count ${model.name} records
   */
  async count(where?: Prisma.${model.name}WhereInput) {
    return prisma.${modelLower}.count({ where })
  },
  
  /**
   * Check if ${model.name} exists
   */
  async exists(id: ${idType}) {
    const count = await prisma.${modelLower}.count({
      where: { id }
    })
    return count > 0
  },
  
  /**
   * Create multiple ${model.name} records (bulk operation)
   */
  async createMany(data: ${model.name}CreateDTO[]) {
    const result = await prisma.${modelLower}.createMany({
      data,
      skipDuplicates: true
    })
    logger.info({ count: result.count }, '${model.name} bulk created')
    return result
  },
  
  /**
   * Update multiple ${model.name} records (bulk operation)
   */
  async updateMany(where: Prisma.${model.name}WhereInput, data: Partial<${model.name}UpdateDTO>) {
    const result = await prisma.${modelLower}.updateMany({
      where,
      data
    })
    logger.info({ count: result.count }, '${model.name} bulk updated')
    return result
  },
  
  /**
   * Delete multiple ${model.name} records (bulk operation)
   */
  async deleteMany(where: Prisma.${model.name}WhereInput) {
    const result = await prisma.${modelLower}.deleteMany({ where })
    logger.info({ count: result.count }, '${model.name} bulk deleted')
    return result
  }`
}

/**
 * Generate domain-specific methods based on detected fields
 */
function generateDomainMethods(
  model: ParsedModel,
  analysis: ReturnType<typeof analyzeModel>,
  modelLower: string,
  idType: string
): string {
  const methods: string[] = []
  
  // Slug lookup
  if (analysis.hasSlugField) {
    methods.push(generateSlugMethod(model, analysis, modelLower))
  }
  
  // Published filtering
  if (analysis.hasPublishedField) {
    methods.push(generatePublishedMethods(model, analysis, modelLower))
  }
  
  // View counter
  if (analysis.specialFields.views) {
    methods.push(generateViewsMethod(model, modelLower, idType))
  }
  
  // Approval workflow
  if (analysis.specialFields.approved) {
    methods.push(generateApprovalMethods(model, modelLower, idType))
  }
  
  // Soft delete
  if (analysis.specialFields.deletedAt) {
    methods.push(generateSoftDeleteMethods(model, modelLower, idType))
  }
  
  // Threading (parent-child)
  if (analysis.specialFields.parentId) {
    methods.push(generateThreadingMethod(model, analysis, modelLower, idType))
  }
  
  return methods.length > 0 ? ',\n\n' + methods.join(',\n\n') : ''
}

/**
 * Extract method names from generated code string
 * Used to prevent duplicate method generation
 */
function extractMethodNames(code: string): Set<string> {
  const methods = new Set<string>()
  const methodRegex = /async\s+(\w+)\s*\(/g
  let match
  
  while ((match = methodRegex.exec(code)) !== null) {
    methods.add(match[1])
  }
  
  return methods
}

/**
 * Generate slug lookup method
 */
function generateSlugMethod(
  model: ParsedModel,
  analysis: ReturnType<typeof analyzeModel>,
  modelLower: string
): string {
  const includeStmt = generateSummaryInclude(analysis)
  
  return `  /**
   * Find ${model.name} by slug
   */
  async findBySlug(slug: string) {
    return prisma.${modelLower}.findUnique({
      where: { slug }${includeStmt}
    })
  }`
}

/**
 * Generate published filtering methods
 */
function generatePublishedMethods(
  model: ParsedModel,
  analysis: ReturnType<typeof analyzeModel>,
  modelLower: string
): string {
  const includeStmt = generateSummaryInclude(analysis)
  
  return `  /**
   * List published ${model.name} records only
   */
  async listPublished(query: ${model.name}QueryDTO) {
    const { skip = 0, take = 20, orderBy, where } = query
    
    const publishedWhere: Prisma.${model.name}WhereInput = {
      ...where as Prisma.${model.name}WhereInput,
      published: true
    }
    
    const [items, total] = await Promise.all([
      prisma.${modelLower}.findMany({
        skip,
        take,
        orderBy: orderBy as Prisma.${model.name}OrderByWithRelationInput,
        where: publishedWhere${includeStmt}
      }),
      prisma.${modelLower}.count({
        where: publishedWhere,
      })
    ])
    
    return {
      data: items,
      meta: {
        total,
        skip,
        take,
        hasMore: skip + take < total
      }
    }
  },
  
  /**
   * Publish ${model.name}
   */
  async publish(id: ${model.idField?.type === 'String' ? 'string' : 'number'}) {
    try {
      const item = await prisma.${modelLower}.update({
        where: { id },
        data: { 
          published: true,
          publishedAt: new Date()
        }${generateSummaryInclude(analysis)}
      })
      logger.info({ ${modelLower}Id: id }, '${model.name} published')
      return item
    } catch (error: any) {
      if (error.code === 'P2025') {
        return null
      }
      logger.error({ error, ${modelLower}Id: id }, 'Failed to publish ${model.name}')
      throw error
    }
  },
  
  /**
   * Unpublish ${model.name}
   */
  async unpublish(id: ${model.idField?.type === 'String' ? 'string' : 'number'}) {
    try {
      const item = await prisma.${modelLower}.update({
        where: { id },
        data: { published: false }${generateSummaryInclude(analysis)}
      })
      logger.info({ ${modelLower}Id: id }, '${model.name} unpublished')
      return item
    } catch (error: any) {
      if (error.code === 'P2025') {
        return null
      }
      logger.error({ error, ${modelLower}Id: id }, 'Failed to unpublish ${model.name}')
      throw error
    }
  }`
}

/**
 * Generate view counter method
 */
function generateViewsMethod(model: ParsedModel, modelLower: string, idType: string): string {
  return `  /**
   * Increment ${model.name} views
   */
  async incrementViews(id: ${idType}) {
    try {
      const item = await prisma.${modelLower}.update({
        where: { id },
        data: { views: { increment: 1 } }
      })
      return item
    } catch (error: any) {
      if (error.code === 'P2025') {
        return null
      }
      logger.error({ error, ${modelLower}Id: id }, 'Failed to increment views')
      throw error
    }
  }`
}

/**
 * Generate approval workflow methods
 */
function generateApprovalMethods(model: ParsedModel, modelLower: string, idType: string): string {
  return `  /**
   * List pending ${model.name} records (not approved)
   */
  async listPending(query: ${model.name}QueryDTO) {
    const { skip = 0, take = 20, orderBy } = query
    
    const [items, total] = await Promise.all([
      prisma.${modelLower}.findMany({
        skip,
        take,
        orderBy: orderBy as Prisma.${model.name}OrderByWithRelationInput,
        where: { approved: false }
      }),
      prisma.${modelLower}.count({
        where: { approved: false },
      })
    ])
    
    return {
      data: items,
      meta: { total, skip, take, hasMore: skip + take < total }
    }
  },
  
  /**
   * Approve ${model.name}
   */
  async approve(id: ${idType}) {
    try {
      const item = await prisma.${modelLower}.update({
        where: { id },
        data: { approved: true }
      })
      logger.info({ ${modelLower}Id: id }, '${model.name} approved')
      return item
    } catch (error: any) {
      if (error.code === 'P2025') {
        return null
      }
      logger.error({ error, ${modelLower}Id: id }, 'Failed to approve ${model.name}')
      throw error
    }
  },
  
  /**
   * Reject ${model.name}
   */
  async reject(id: ${idType}) {
    try {
      const item = await prisma.${modelLower}.update({
        where: { id },
        data: { approved: false }
      })
      logger.info({ ${modelLower}Id: id }, '${model.name} rejected')
      return item
    } catch (error: any) {
      if (error.code === 'P2025') {
        return null
      }
      logger.error({ error, ${modelLower}Id: id }, 'Failed to reject ${model.name}')
      throw error
    }
  }`
}

/**
 * Generate soft delete methods
 */
function generateSoftDeleteMethods(model: ParsedModel, modelLower: string, idType: string): string {
  return `  /**
   * Soft delete ${model.name} (mark as deleted without removing)
   */
  async softDelete(id: ${idType}) {
    try {
      const item = await prisma.${modelLower}.update({
        where: { id },
        data: { deletedAt: new Date() }
      })
      logger.info({ ${modelLower}Id: id }, '${model.name} soft deleted')
      return item
    } catch (error: any) {
      if (error.code === 'P2025') {
        return null
      }
      logger.error({ error, ${modelLower}Id: id }, 'Failed to soft delete ${model.name}')
      throw error
    }
  },
  
  /**
   * Restore soft deleted ${model.name}
   */
  async restore(id: ${idType}) {
    try {
      const item = await prisma.${modelLower}.update({
        where: { id },
        data: { deletedAt: null }
      })
      logger.info({ ${modelLower}Id: id }, '${model.name} restored')
      return item
    } catch (error: any) {
      if (error.code === 'P2025') {
        return null
      }
      logger.error({ error, ${modelLower}Id: id }, 'Failed to restore ${model.name}')
      throw error
    }
  }`
}

/**
 * Generate threading method (parent-child relationships)
 */
function generateThreadingMethod(
  model: ParsedModel,
  analysis: ReturnType<typeof analyzeModel>,
  modelLower: string,
  idType: string
): string {
  const includeStmt = generateSummaryInclude(analysis)
  
  // Build includes for threading (replies + any auto-includes)
  const threadingInclude = includeStmt 
    ? includeStmt.replace(/,\s*include:\s*{/, ',').replace(/}\s*$/, '') 
    : ''
  
  return `  /**
   * Get ${model.name} with nested children (threading)
   */
  async getWithReplies(id: ${idType}) {
    return prisma.${modelLower}.findUnique({
      where: { id },
      include: {
        replies: {
          include: {
            replies: true  // One level of nesting
          }
        }${threadingInclude}
      }
    })
  },
  
  /**
   * Get top-level ${model.name} records (no parent)
   */
  async listTopLevel(query: ${model.name}QueryDTO) {
    const { skip = 0, take = 20, orderBy, where } = query
    
    const topLevelWhere: Prisma.${model.name}WhereInput = {
      ...where as Prisma.${model.name}WhereInput,
      parentId: null
    }
    
    const [items, total] = await Promise.all([
      prisma.${modelLower}.findMany({
        skip,
        take,
        orderBy: orderBy as Prisma.${model.name}OrderByWithRelationInput,
        where: topLevelWhere${includeStmt}
      }),
      prisma.${modelLower}.count({
        where: topLevelWhere,
      })
    ])
    
    return {
      data: items,
      meta: { total, skip, take, hasMore: skip + take < total }
    }
  }`
}


