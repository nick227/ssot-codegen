/**
 * Enhanced Controller Generator - Generates controllers with proper logging
 */

import type { ParsedModel, ParsedSchema } from '../dmmf-parser.js'
import { analyzeModel } from '../utils/relationship-analyzer.js'

/**
 * Generate enhanced controller with proper logging
 */
export function generateEnhancedController(
  model: ParsedModel,
  schema: ParsedSchema,
  framework: 'express' | 'fastify' = 'express'
): string {
  const analysis = analyzeModel(model, schema)
  const modelLower = model.name.toLowerCase()
  const idType = model.idField?.type === 'String' ? 'string' : 'number'
  const parseId = idType === 'number' 
    ? 'parseInt(req.params.id, 10)'
    : 'req.params.id'
  
  if (framework === 'express') {
    return generateExpressController(model, analysis, modelLower, idType, parseId)
  } else {
    return generateFastifyController(model, analysis, modelLower, idType, parseId)
  }
}

/**
 * Generate Express controller with enhanced features
 */
function generateExpressController(
  model: ParsedModel,
  analysis: ReturnType<typeof analyzeModel>,
  modelLower: string,
  idType: string,
  parseId: string
): string {
  const baseMethods = generateExpressBaseMethods(model, modelLower, idType, parseId)
  const domainMethods = generateExpressDomainMethods(model, analysis, modelLower, idType, parseId)
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import type { Request, Response } from 'express'
import { ${modelLower}Service } from '../services/${modelLower}'
import { ${model.name}CreateSchema, ${model.name}UpdateSchema, ${model.name}QuerySchema } from '../validators/${modelLower}'
import { ZodError } from 'zod'
import { logger } from '../../src/logger'

${baseMethods}${domainMethods}
`
}

/**
 * Generate base CRUD controller methods
 */
function generateExpressBaseMethods(
  model: ParsedModel,
  modelLower: string,
  idType: string,
  parseId: string
): string {
  return `/**
 * List all ${model.name} records
 */
export const list${model.name}s = async (req: Request, res: Response) => {
  try {
    const query = ${model.name}QuerySchema.parse(req.query)
    const result = await ${modelLower}Service.list(query)
    return res.json(result)
  } catch (error) {
    if (error instanceof ZodError) {
      logger.warn({ error: error.errors }, 'Validation error in list${model.name}s')
      return res.status(400).json({ error: 'Validation Error', details: error.errors })
    }
    logger.error({ error }, 'Error listing ${model.name}s')
    return res.status(500).json({ error: 'Internal Server Error' })
  }
}

/**
 * Get ${model.name} by ID
 */
export const get${model.name} = async (req: Request, res: Response) => {
  try {
    const id = ${parseId}
    ${idType === 'number' ? `
    if (isNaN(id)) {
      logger.warn({ id: req.params.id }, 'Invalid ID format')
      return res.status(400).json({ error: 'Invalid ID format' })
    }` : ''}
    
    const item = await ${modelLower}Service.findById(id)
    
    if (!item) {
      logger.debug({ ${modelLower}Id: id }, '${model.name} not found')
      return res.status(404).json({ error: '${model.name} not found' })
    }
    
    return res.json(item)
  } catch (error) {
    logger.error({ error, ${modelLower}Id: req.params.id }, 'Error getting ${model.name}')
    return res.status(500).json({ error: 'Internal Server Error' })
  }
}

/**
 * Create ${model.name}
 */
export const create${model.name} = async (req: Request, res: Response) => {
  try {
    const data = ${model.name}CreateSchema.parse(req.body)
    const item = await ${modelLower}Service.create(data)
    return res.status(201).json(item)
  } catch (error) {
    if (error instanceof ZodError) {
      logger.warn({ error: error.errors }, 'Validation error in create${model.name}')
      return res.status(400).json({ error: 'Validation Error', details: error.errors })
    }
    logger.error({ error }, 'Error creating ${model.name}')
    return res.status(500).json({ error: 'Internal Server Error' })
  }
}

/**
 * Update ${model.name}
 */
export const update${model.name} = async (req: Request, res: Response) => {
  try {
    const id = ${parseId}
    ${idType === 'number' ? `
    if (isNaN(id)) {
      logger.warn({ id: req.params.id }, 'Invalid ID format')
      return res.status(400).json({ error: 'Invalid ID format' })
    }` : ''}
    
    const data = ${model.name}UpdateSchema.parse(req.body)
    const item = await ${modelLower}Service.update(id, data)
    
    if (!item) {
      logger.debug({ ${modelLower}Id: id }, '${model.name} not found for update')
      return res.status(404).json({ error: '${model.name} not found' })
    }
    
    return res.json(item)
  } catch (error) {
    if (error instanceof ZodError) {
      logger.warn({ error: error.errors, ${modelLower}Id: req.params.id }, 'Validation error in update${model.name}')
      return res.status(400).json({ error: 'Validation Error', details: error.errors })
    }
    logger.error({ error, ${modelLower}Id: req.params.id }, 'Error updating ${model.name}')
    return res.status(500).json({ error: 'Internal Server Error' })
  }
}

/**
 * Delete ${model.name}
 */
export const delete${model.name} = async (req: Request, res: Response) => {
  try {
    const id = ${parseId}
    ${idType === 'number' ? `
    if (isNaN(id)) {
      logger.warn({ id: req.params.id }, 'Invalid ID format')
      return res.status(400).json({ error: 'Invalid ID format' })
    }` : ''}
    
    const deleted = await ${modelLower}Service.delete(id)
    
    if (!deleted) {
      logger.debug({ ${modelLower}Id: id }, '${model.name} not found for delete')
      return res.status(404).json({ error: '${model.name} not found' })
    }
    
    return res.status(204).send()
  } catch (error) {
    logger.error({ error, ${modelLower}Id: req.params.id }, 'Error deleting ${model.name}')
    return res.status(500).json({ error: 'Internal Server Error' })
  }
}

/**
 * Count ${model.name} records
 */
export const count${model.name}s = async (_req: Request, res: Response) => {
  try {
    const total = await ${modelLower}Service.count()
    return res.json({ total })
  } catch (error) {
    logger.error({ error }, 'Error counting ${model.name}s')
    return res.status(500).json({ error: 'Internal Server Error' })
  }
}
`
}

/**
 * Generate domain-specific controller methods
 */
function generateExpressDomainMethods(
  model: ParsedModel,
  analysis: ReturnType<typeof analyzeModel>,
  modelLower: string,
  idType: string,
  parseId: string
): string {
  const methods: string[] = []
  
  // Slug lookup
  if (analysis.hasSlugField) {
    methods.push(`
/**
 * Get ${model.name} by slug
 */
export const get${model.name}BySlug = async (req: Request, res: Response) => {
  try {
    const { slug } = req.params
    if (!slug) {
      logger.warn('Slug parameter missing')
      return res.status(400).json({ error: 'Slug parameter is required' })
    }
    
    const item = await ${modelLower}Service.findBySlug(slug)
    
    if (!item) {
      logger.debug({ slug }, '${model.name} not found by slug')
      return res.status(404).json({ error: '${model.name} not found' })
    }
    
    return res.json(item)
  } catch (error) {
    logger.error({ error, slug: req.params.slug }, 'Error getting ${model.name} by slug')
    return res.status(500).json({ error: 'Internal Server Error' })
  }
}`)
  }
  
  // Published filtering
  if (analysis.hasPublishedField) {
    methods.push(`
/**
 * List published ${model.name} records
 */
export const listPublished${model.name}s = async (req: Request, res: Response) => {
  try {
    const query = ${model.name}QuerySchema.parse(req.query)
    const result = await ${modelLower}Service.listPublished(query)
    return res.json(result)
  } catch (error) {
    if (error instanceof ZodError) {
      logger.warn({ error: error.errors }, 'Validation error in listPublished${model.name}s')
      return res.status(400).json({ error: 'Validation Error', details: error.errors })
    }
    logger.error({ error }, 'Error listing published ${model.name}s')
    return res.status(500).json({ error: 'Internal Server Error' })
  }
}

/**
 * Publish ${model.name}
 */
export const publish${model.name} = async (req: Request, res: Response) => {
  try {
    const id = ${parseId}
    ${idType === 'number' ? `
    if (isNaN(id)) {
      logger.warn({ id: req.params.id }, 'Invalid ID format')
      return res.status(400).json({ error: 'Invalid ID format' })
    }` : ''}
    
    const item = await ${modelLower}Service.publish(id)
    
    if (!item) {
      logger.debug({ ${modelLower}Id: id }, '${model.name} not found for publish')
      return res.status(404).json({ error: '${model.name} not found' })
    }
    
    return res.json(item)
  } catch (error) {
    logger.error({ error, ${modelLower}Id: req.params.id }, 'Error publishing ${model.name}')
    return res.status(500).json({ error: 'Internal Server Error' })
  }
}

/**
 * Unpublish ${model.name}
 */
export const unpublish${model.name} = async (req: Request, res: Response) => {
  try {
    const id = ${parseId}
    ${idType === 'number' ? `
    if (isNaN(id)) {
      logger.warn({ id: req.params.id }, 'Invalid ID format')
      return res.status(400).json({ error: 'Invalid ID format' })
    }` : ''}
    
    const item = await ${modelLower}Service.unpublish(id)
    
    if (!item) {
      logger.debug({ ${modelLower}Id: id }, '${model.name} not found for unpublish')
      return res.status(404).json({ error: '${model.name} not found' })
    }
    
    return res.json(item)
  } catch (error) {
    logger.error({ error, ${modelLower}Id: req.params.id }, 'Error unpublishing ${model.name}')
    return res.status(500).json({ error: 'Internal Server Error' })
  }
}`)
  }
  
  // View counter
  if (analysis.specialFields.views) {
    methods.push(`
/**
 * Increment ${model.name} views
 */
export const increment${model.name}Views = async (req: Request, res: Response) => {
  try {
    const id = ${parseId}
    ${idType === 'number' ? `
    if (isNaN(id)) {
      logger.warn({ id: req.params.id }, 'Invalid ID format')
      return res.status(400).json({ error: 'Invalid ID format' })
    }` : ''}
    
    await ${modelLower}Service.incrementViews(id)
    return res.status(204).send()
  } catch (error) {
    logger.error({ error, ${modelLower}Id: req.params.id }, 'Error incrementing ${model.name} views')
    return res.status(500).json({ error: 'Internal Server Error' })
  }
}`)
  }
  
  // Approval workflow
  if (analysis.specialFields.approved) {
    methods.push(`
/**
 * List pending ${model.name} records
 */
export const listPending${model.name}s = async (req: Request, res: Response) => {
  try {
    const query = ${model.name}QuerySchema.parse(req.query)
    const result = await ${modelLower}Service.listPending(query)
    return res.json(result)
  } catch (error) {
    if (error instanceof ZodError) {
      logger.warn({ error: error.errors }, 'Validation error in listPending${model.name}s')
      return res.status(400).json({ error: 'Validation Error', details: error.errors })
    }
    logger.error({ error }, 'Error listing pending ${model.name}s')
    return res.status(500).json({ error: 'Internal Server Error' })
  }
}

/**
 * Approve ${model.name}
 */
export const approve${model.name} = async (req: Request, res: Response) => {
  try {
    const id = ${parseId}
    ${idType === 'number' ? `
    if (isNaN(id)) {
      logger.warn({ id: req.params.id }, 'Invalid ID format')
      return res.status(400).json({ error: 'Invalid ID format' })
    }` : ''}
    
    const item = await ${modelLower}Service.approve(id)
    
    if (!item) {
      logger.debug({ ${modelLower}Id: id }, '${model.name} not found for approval')
      return res.status(404).json({ error: '${model.name} not found' })
    }
    
    return res.json(item)
  } catch (error) {
    logger.error({ error, ${modelLower}Id: req.params.id }, 'Error approving ${model.name}')
    return res.status(500).json({ error: 'Internal Server Error' })
  }
}`)
  }
  
  return methods.length > 0 ? '\n' + methods.join('\n') : ''
}

/**
 * Generate Fastify controller (similar pattern)
 */
function generateFastifyController(
  model: ParsedModel,
  analysis: ReturnType<typeof analyzeModel>,
  modelLower: string,
  idType: string,
  parseId: string
): string {
  // For brevity, similar structure to Express but with Fastify types
  return `// @generated
// Fastify controller - TBD
import type { FastifyRequest, FastifyReply } from 'fastify'
import { ${modelLower}Service } from '../services/${modelLower}'
import { logger } from '../../src/logger'

// TODO: Generate Fastify controller methods
`
}

