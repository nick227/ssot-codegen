/**
 * Template Builder - Fluent API for building code templates
 * 
 * Provides composable, testable template construction
 */

export class TemplateBuilder {
  private parts: string[] = []
  
  /**
   * Add generated file header
   */
  header(): this {
    this.parts.push('// @generated')
    this.parts.push('// This file is automatically generated. Do not edit manually.')
    this.parts.push('')
    return this
  }
  
  /**
   * Add import statements
   */
  imports(imports: string[]): this {
    if (imports.length > 0) {
      this.parts.push(imports.join('\n'))
      this.parts.push('')
    }
    return this
  }
  
  /**
   * Add import string directly
   */
  importString(importStr: string): this {
    if (importStr) {
      this.parts.push(importStr)
    }
    return this
  }
  
  /**
   * Add a code block
   */
  block(content: string): this {
    if (content) {
      this.parts.push(content)
      this.parts.push('')
    }
    return this
  }
  
  /**
   * Add raw line
   */
  line(content: string): this {
    this.parts.push(content)
    return this
  }
  
  /**
   * Add empty line
   */
  emptyLine(): this {
    this.parts.push('')
    return this
  }
  
  /**
   * Add JSDoc comment
   */
  comment(text: string): this {
    this.parts.push('/**')
    this.parts.push(` * ${text}`)
    this.parts.push(' */')
    return this
  }
  
  /**
   * Add code block with optional condition
   */
  blockIf(condition: boolean, content: string): this {
    if (condition) {
      this.block(content)
    }
    return this
  }
  
  /**
   * Add multiple blocks
   */
  blocks(...contents: string[]): this {
    contents.forEach(c => this.block(c))
    return this
  }
  
  /**
   * Build final template
   */
  build(): string {
    return this.parts.join('\n')
  }
  
  /**
   * Build and ensure ends with newline
   */
  buildWithNewline(): string {
    const result = this.build()
    return result.endsWith('\n') ? result : result + '\n'
  }
  
  /**
   * Get current line count
   */
  lineCount(): number {
    return this.parts.length
  }
  
  /**
   * Clear all parts
   */
  clear(): this {
    this.parts = []
    return this
  }
}

/**
 * Helper for creating interfaces
 */
export class InterfaceBuilder {
  constructor(private name: string) {}
  
  private fields: string[] = []
  
  field(name: string, type: string, optional: boolean = false): this {
    const opt = optional ? '?' : ''
    this.fields.push(`  ${name}${opt}: ${type}`)
    return this
  }
  
  build(): string {
    return `export interface ${this.name} {
${this.fields.join('\n')}
}`
  }
}

/**
 * Helper for creating objects
 */
export class ObjectBuilder {
  constructor(private name: string, private exportType: 'const' | 'let' = 'const') {}
  
  private methods: string[] = []
  
  method(content: string): this {
    this.methods.push(content)
    return this
  }
  
  build(): string {
    return `export ${this.exportType} ${this.name} = {
${this.methods.join(',\n\n')}
}`
  }
}


