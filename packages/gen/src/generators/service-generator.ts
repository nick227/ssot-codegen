/**
 * Service Generator - Generates service layer with Prisma queries
 */

import type { ParsedModel } from '../dmmf-parser.js'
import { generateEnhancedServiceMethods } from './service-method-generator.js'

/**
 * Generate service with full CRUD operations + auto-detected enhanced methods
 */
export function generateService(model: ParsedModel): string {
  const modelLower = model.name.toLowerCase()
  const idType = model.idField?.type === 'String' ? 'string' : 'number'
  
  return `// @generated
// This file is automatically generated. Do not edit manually.

import prisma from '@/db'
import type { ${model.name}CreateDTO, ${model.name}UpdateDTO, ${model.name}QueryDTO } from '@/contracts/${modelLower}'
import type { Prisma } from '@prisma/client'

export const ${modelLower}Service = {
  /**
   * List ${model.name} records with pagination
   */
  async list(query: ${model.name}QueryDTO) {
    const { skip = 0, take = 20, orderBy, where, include, select } = query
    
    const [items, total] = await Promise.all([
      prisma.${modelLower}.findMany({
        skip,
        take,
        orderBy: orderBy as Prisma.${model.name}OrderByWithRelationInput,
        where: where as Prisma.${model.name}WhereInput,
        include: include as Prisma.${model.name}Include | undefined,
        select: select as Prisma.${model.name}Select | undefined,
      }),
      prisma.${modelLower}.count({
        where: where as Prisma.${model.name}WhereInput,
      })
    ])
    
    return {
      data: items,
      meta: {
        total,
        skip,
        take,
        hasMore: skip + take < total
      }
    }
  },
  
  /**
   * Find ${model.name} by ID
   */
  async findById(id: ${idType}) {
    return prisma.${modelLower}.findUnique({
      where: { id }
    })
  },
  
  /**
   * Create ${model.name}
   */
  async create(data: ${model.name}CreateDTO) {
    return prisma.${modelLower}.create({
      data
    })
  },
  
  /**
   * Update ${model.name}
   */
  async update(id: ${idType}, data: ${model.name}UpdateDTO) {
    try {
      return await prisma.${modelLower}.update({
        where: { id },
        data
      })
    } catch (error: any) {
      if (error.code === 'P2025') {
        return null  // Not found
      }
      throw error
    }
  },
  
  /**
   * Delete ${model.name}
   */
  async delete(id: ${idType}) {
    try {
      await prisma.${modelLower}.delete({
        where: { id }
      })
      return true
    } catch (error: any) {
      if (error.code === 'P2025') {
        return false  // Not found
      }
      throw error
    }
  },
  
  /**
   * Count ${model.name} records
   */
  async count(where?: Prisma.${model.name}WhereInput) {
    return prisma.${modelLower}.count({ where })
  },
  
  /**
   * Check if ${model.name} exists
   */
  async exists(id: ${idType}) {
    const count = await prisma.${modelLower}.count({
      where: { id }
    })
    return count > 0
  }${generateEnhancedServiceMethods(model)}
}
`
}

/**
 * Generate barrel export for service
 */
export function generateServiceBarrel(model: ParsedModel): string {
  return `// @generated barrel
export * from './${model.name.toLowerCase()}.service.js'
`
}


