/**
 * Error Handling Module
 * 
 * Centralized error handling with Prisma error mapping
 * Following RFC 7807 Problem Details for HTTP APIs
 */

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client';
import { logger } from './logger.js';
import { config } from './config.js';

// RFC 7807 Problem Details interface
export interface ProblemDetails {
  type: string;
  title: string;
  status: number;
  detail: string;
  instance: string;
  [key: string]: unknown;
}

// Custom application errors
export class AppError extends Error {
  constructor(
    public status: number,
    public title: string,
    message: string,
    public type: string = 'about:blank',
    public extensions?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'AppError';
  }
}

export class ValidationError extends AppError {
  constructor(message: string, errors?: unknown) {
    super(400, 'Validation Error', message, '/errors/validation', { errors });
    this.name = 'ValidationError';
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string, id?: string | number) {
    const message = id ? `${resource} with id '${id}' not found` : `${resource} not found`;
    super(404, 'Not Found', message, '/errors/not-found', { resource, id });
    this.name = 'NotFoundError';
  }
}

export class ConflictError extends AppError {
  constructor(message: string, field?: string) {
    super(409, 'Conflict', message, '/errors/conflict', { field });
    this.name = 'ConflictError';
  }
}

// Map Prisma errors to HTTP errors
export function mapPrismaError(error: unknown): AppError {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2002': {
        // Unique constraint violation
        const target = error.meta?.target as string[] | undefined;
        const field = target?.[0] || 'field';
        return new ConflictError(
          `A record with this ${field} already exists`,
          field
        );
      }
      
      case 'P2025': {
        // Record not found
        const cause = error.meta?.cause as string | undefined;
        return new NotFoundError('Record', cause);
      }
      
      case 'P2003': {
        // Foreign key constraint violation
        const field = error.meta?.field_name as string | undefined;
        return new ConflictError(
          `Invalid reference: ${field || 'related record'} does not exist`,
          field
        );
      }
      
      case 'P2014': {
        // Required relation violation
        return new ConflictError(
          'Cannot delete record due to required relations'
        );
      }
      
      case 'P2011': {
        // Null constraint violation
        const target = error.meta?.target as string[] | undefined;
        const field = target?.[0] || 'field';
        return new ValidationError(
          `${field} cannot be null`,
          { field, constraint: 'not_null' }
        );
      }
      
      default: {
        logger.error({ prismaError: error }, 'Unhandled Prisma error');
        return new AppError(
          500,
          'Database Error',
          'An unexpected database error occurred',
          '/errors/database',
          { code: error.code }
        );
      }
    }
  }
  
  if (error instanceof Prisma.PrismaClientValidationError) {
    return new ValidationError('Invalid data provided to database');
  }
  
  // Not a Prisma error
  throw error;
}

// Convert error to Problem Details format
function toProblemDetails(error: AppError, instance: string): ProblemDetails {
  return {
    type: error.type,
    title: error.title,
    status: error.status,
    detail: error.message,
    instance,
    ...error.extensions,
  };
}

// Global error handler middleware
export function errorHandler(
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void {
  // Skip if headers already sent
  if (res.headersSent) {
    return next(error);
  }
  
  let appError: AppError;
  
  // Convert known errors to AppError
  if (error instanceof AppError) {
    appError = error;
  } else if (
    error instanceof Prisma.PrismaClientKnownRequestError ||
    error instanceof Prisma.PrismaClientValidationError
  ) {
    appError = mapPrismaError(error);
  } else {
    // Unknown error - log and return generic 500
    logger.error({ err: error, req }, 'Unhandled error');
    appError = new AppError(
      500,
      'Internal Server Error',
      config.NODE_ENV === 'production' 
        ? 'An unexpected error occurred' 
        : error.message
    );
  }
  
  // Log error with appropriate level
  if (appError.status >= 500) {
    logger.error({ err: error, req }, appError.message);
  } else if (appError.status >= 400) {
    logger.warn({ req, error: appError }, appError.message);
  }
  
  // Send Problem Details response
  const problem = toProblemDetails(appError, req.url);
  res.status(appError.status).json(problem);
}

// Async handler wrapper to catch promise rejections
export function asyncHandler(
  fn: (req: Request, res: Response, next: NextFunction) => Promise<unknown>
) {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

