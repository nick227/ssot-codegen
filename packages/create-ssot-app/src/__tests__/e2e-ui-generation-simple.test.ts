/**
 * Simplified E2E Test: UI Generation (without npm install)
 * 
 * This test verifies:
 * 1. Project generation works
 * 2. All UI files are created
 * 3. File content is correct
 * 4. Structure matches expectations
 */

import { describe, it, expect, afterAll } from 'vitest'
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import type { ProjectConfig } from '../prompts.js'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const TEST_OUTPUT_DIR = path.join(__dirname, '..', '..', 'e2e-simple-test-output')
const TEST_PROJECT_NAME = 'test-ui-simple'
const TEST_PROJECT_PATH = path.join(TEST_OUTPUT_DIR, TEST_PROJECT_NAME)

describe('E2E: UI Generation (Simple)', () => {
  afterAll(() => {
    // Cleanup
    if (fs.existsSync(TEST_OUTPUT_DIR)) {
      fs.rmSync(TEST_OUTPUT_DIR, { recursive: true, force: true })
    }
  })
  
  it('should generate complete UI structure', async () => {
    // Clean up
    if (fs.existsSync(TEST_OUTPUT_DIR)) {
      fs.rmSync(TEST_OUTPUT_DIR, { recursive: true, force: true })
    }
    fs.mkdirSync(TEST_OUTPUT_DIR, { recursive: true })
    
    // Create config
    const config: ProjectConfig = {
      projectName: TEST_PROJECT_NAME,
      framework: 'express',
      database: 'sqlite',
      includeExamples: true,
      selectedPlugins: [],
      packageManager: 'npm',
      generateUI: true,
      uiTemplate: 'data-browser'
    }
    
    // Import generators
    const { generatePackageJson } = await import('../templates/package-json.js')
    const { generatePrismaSchema } = await import('../templates/prisma-schema.js')
    const { generateEnvFile } = await import('../templates/env-file.js')
    const { generateGitignore } = await import('../templates/gitignore.js')
    const { generateTsConfig } = await import('../templates/tsconfig.js')
    const { generateReadme } = await import('../templates/readme.js')
    const { generateUI } = await import('../ui-generator.js')
    
    // Create directories
    fs.mkdirSync(TEST_PROJECT_PATH, { recursive: true })
    fs.mkdirSync(path.join(TEST_PROJECT_PATH, 'prisma'), { recursive: true })
    fs.mkdirSync(path.join(TEST_PROJECT_PATH, 'src'), { recursive: true })
    
    // Generate base files
    fs.writeFileSync(
      path.join(TEST_PROJECT_PATH, 'package.json'),
      generatePackageJson(config)
    )
    
    const schemaContent = generatePrismaSchema(config)
    fs.writeFileSync(
      path.join(TEST_PROJECT_PATH, 'prisma', 'schema.prisma'),
      schemaContent
    )
    
    fs.writeFileSync(path.join(TEST_PROJECT_PATH, '.env'), generateEnvFile(config))
    fs.writeFileSync(path.join(TEST_PROJECT_PATH, '.gitignore'), generateGitignore())
    fs.writeFileSync(path.join(TEST_PROJECT_PATH, 'tsconfig.json'), generateTsConfig())
    fs.writeFileSync(path.join(TEST_PROJECT_PATH, 'README.md'), generateReadme(config))
    
    // Parse models
    const models = parseModels(schemaContent)
    
    // Generate UI
    generateUI(TEST_PROJECT_PATH, config, models)
    
    // VERIFY: Files exist
    console.log('\nâœ… Verifying generated files...\n')
    
    const expectedFiles = [
      'app/layout.tsx',
      'app/globals.css',
      'app/admin/layout.tsx',
      'app/admin/page.tsx',
      'app/admin/users/page.tsx',
      'app/admin/users/[id]/page.tsx',
      'app/admin/posts/page.tsx',
      'app/admin/posts/[id]/page.tsx',
      'tailwind.config.js',
      'next.config.js',
      'UI_README.md'
    ]
    
    for (const file of expectedFiles) {
      const filePath = path.join(TEST_PROJECT_PATH, file)
      expect(fs.existsSync(filePath), `File should exist: ${file}`).toBe(true)
      console.log(`  âœ… ${file}`)
    }
    
    // VERIFY: File contents
    console.log('\nâœ… Verifying file contents...\n')
    
    // Check root layout
    const rootLayout = fs.readFileSync(path.join(TEST_PROJECT_PATH, 'app/layout.tsx'), 'utf-8')
    expect(rootLayout).toContain('Generated by SSOT CodeGen')
    expect(rootLayout).toContain('export default function RootLayout')
    console.log('  âœ… Root layout valid')
    
    // Check admin layout
    const adminLayout = fs.readFileSync(path.join(TEST_PROJECT_PATH, 'app/admin/layout.tsx'), 'utf-8')
    expect(adminLayout).toContain('Admin Panel')
    expect(adminLayout).toContain('/admin/users')
    expect(adminLayout).toContain('/admin/posts')
    console.log('  âœ… Admin layout valid')
    
    // Check dashboard
    const dashboard = fs.readFileSync(path.join(TEST_PROJECT_PATH, 'app/admin/page.tsx'), 'utf-8')
    expect(dashboard).toContain('Dashboard')
    expect(dashboard).toContain('Users')
    expect(dashboard).toContain('Posts')
    console.log('  âœ… Dashboard valid')
    
    // Check user list page
    const userList = fs.readFileSync(path.join(TEST_PROJECT_PATH, 'app/admin/users/page.tsx'), 'utf-8')
    expect(userList).toContain('DataTable')
    expect(userList).toContain('useUserList')
    expect(userList).toContain('@ssot-ui/data-table')
    console.log('  âœ… User list page valid')
    
    // Check post list page
    const postList = fs.readFileSync(path.join(TEST_PROJECT_PATH, 'app/admin/posts/page.tsx'), 'utf-8')
    expect(postList).toContain('DataTable')
    expect(postList).toContain('usePostList')
    console.log('  âœ… Post list page valid')
    
    // Check tailwind config
    const tailwind = fs.readFileSync(path.join(TEST_PROJECT_PATH, 'tailwind.config.js'), 'utf-8')
    expect(tailwind).toContain('@ssot-ui/tokens')
    console.log('  âœ… Tailwind config valid')
    
    // Check next config
    const nextConfig = fs.readFileSync(path.join(TEST_PROJECT_PATH, 'next.config.js'), 'utf-8')
    expect(nextConfig).toContain('transpilePackages')
    expect(nextConfig).toContain('@ssot-ui/data-table')
    console.log('  âœ… Next.js config valid')
    
    // Check UI README
    const uiReadme = fs.readFileSync(path.join(TEST_PROJECT_PATH, 'UI_README.md'), 'utf-8')
    expect(uiReadme).toContain('Generated UI - Data Browser')
    expect(uiReadme).toContain('User Pages')
    expect(uiReadme).toContain('Post Pages')
    console.log('  âœ… UI README valid')
    
    // Check package.json has UI dependencies
    const packageJson = JSON.parse(fs.readFileSync(path.join(TEST_PROJECT_PATH, 'package.json'), 'utf-8'))
    expect(packageJson.dependencies.next).toBeDefined()
    expect(packageJson.dependencies.react).toBeDefined()
    expect(packageJson.dependencies['@ssot-ui/data-table']).toBeDefined()
    expect(packageJson.scripts['dev:ui']).toBeDefined()
    console.log('  âœ… Package.json valid')
    
    console.log('\nðŸŽ‰ ALL VERIFICATIONS PASSED!\n')
    console.log(`ðŸ“Š Summary:`)
    console.log(`   Files generated: ${expectedFiles.length}`)
    console.log(`   Models: ${models.length} (User, Post)`)
    console.log(`   Pages per model: 2 (list + detail)`)
    console.log(`   Total pages: ${models.length * 2 + 1} (including dashboard)`)
    console.log(`\nâœ… UI generation works correctly!`)
  })
})

function parseModels(schema: string): Array<{
  name: string
  nameLower: string
  namePlural: string
  fields: Array<{ name: string; type: string; isRelation: boolean }>
}> {
  const models: Array<{
    name: string
    nameLower: string
    namePlural: string
    fields: Array<{ name: string; type: string; isRelation: boolean }>
  }> = []
  
  const modelRegex = /model\s+(\w+)\s*\{([^}]+)\}/g
  let modelMatch
  
  while ((modelMatch = modelRegex.exec(schema)) !== null) {
    const modelName = modelMatch[1]
    const modelBody = modelMatch[2]
    
    if (modelName.startsWith('_')) continue
    
    const fields: Array<{ name: string; type: string; isRelation: boolean }> = []
    const fieldRegex = /^\s*(\w+)\s+(\w+)/gm
    let fieldMatch
    
    while ((fieldMatch = fieldRegex.exec(modelBody)) !== null) {
      const fieldName = fieldMatch[1]
      const fieldType = fieldMatch[2]
      
      if (fieldName.startsWith('@') || fieldName === 'model') continue
      
      const isRelation = /^[A-Z]/.test(fieldType) && 
        !['String', 'Int', 'Float', 'Boolean', 'DateTime', 'Json'].includes(fieldType)
      
      fields.push({ name: fieldName, type: fieldType, isRelation })
    }
    
    models.push({
      name: modelName,
      nameLower: modelName.toLowerCase(),
      namePlural: modelName.toLowerCase() + 's',
      fields
    })
  }
  
  return models
}

