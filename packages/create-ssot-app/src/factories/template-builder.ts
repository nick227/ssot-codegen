/**
 * Template Builder Factory
 * 
 * DRY system for generating UI templates
 * Eliminates duplication across blog, chatbot, and future templates
 */

import type { ProjectConfig } from '../prompts.js'
import type { ParsedModel } from '../ui-generator.js'
import fs from 'node:fs'
import path from 'node:path'

/**
 * Schema mapping interface (shared across all templates)
 */
export interface SchemaMapping {
  models: Record<string, string>
  fields: Record<string, string>
}

/**
 * Field resolver - reusable across all templates
 */
export class FieldResolver {
  constructor(private mappings: SchemaMapping) {}
  
  /**
   * Get mapped field name or default
   */
  getField(templateField: string, defaultField: string): string {
    const mapped = this.mappings.fields[templateField]
    if (mapped) {
      const parts = mapped.split('.')
      return parts[parts.length - 1]
    }
    return defaultField
  }
  
  /**
   * Resolve all fields for a model
   */
  resolveFields(templateModel: string, fieldNames: string[]): Record<string, string> {
    const resolved: Record<string, string> = {}
    for (const field of fieldNames) {
      resolved[field] = this.getField(`${templateModel}.${field}`, field)
    }
    return resolved
  }
}

/**
 * Model resolver - reusable across all templates
 */
export class ModelResolver {
  constructor(private models: ParsedModel[], private mappings: SchemaMapping) {}
  
  /**
   * Find model by template name (case-insensitive)
   */
  findModel(templateName: string): ParsedModel | null {
    const mappedName = this.mappings.models[templateName] || templateName
    const model = this.models.find(m => m.name.toLowerCase() === mappedName.toLowerCase())
    return model || null
  }
  
  /**
   * Require model (throws if not found)
   */
  requireModel(templateName: string): ParsedModel {
    const model = this.findModel(templateName)
    if (!model) {
      throw new Error(`Required model '${templateName}' not found. Check schema mappings.`)
    }
    return model
  }
  
  /**
   * Resolve multiple models
   */
  resolveModels(templateNames: string[]): Record<string, ParsedModel | null> {
    const resolved: Record<string, ParsedModel | null> = {}
    for (const name of templateNames) {
      resolved[name] = this.findModel(name)
    }
    return resolved
  }
}

/**
 * File manager - DRY file operations
 */
export class FileManager {
  constructor(private projectPath: string) {}
  
  /**
   * Ensure directory exists
   */
  ensureDir(relativePath: string): string {
    const fullPath = path.join(this.projectPath, relativePath)
    fs.mkdirSync(fullPath, { recursive: true })
    return fullPath
  }
  
  /**
   * Write file with automatic directory creation
   */
  writeFile(relativePath: string, content: string): void {
    const fullPath = path.join(this.projectPath, relativePath)
    const dir = path.dirname(fullPath)
    fs.mkdirSync(dir, { recursive: true })
    fs.writeFileSync(fullPath, content)
  }
  
  /**
   * Write multiple files
   */
  writeFiles(files: Record<string, string>): void {
    for (const [relativePath, content] of Object.entries(files)) {
      this.writeFile(relativePath, content)
    }
  }
}

/**
 * Code builder - reusable code generation patterns
 */
export class CodeBuilder {
  /**
   * Generate file header comment
   */
  static header(template: string, description: string, editSafe = true): string {
    const safeEdit = editSafe ? '\n * \n * ✨ SAFE TO EDIT - Your changes preserved' : ''
    return `/**
 * Generated by SSOT CodeGen - ${template}
 * ${description}${safeEdit}
 */\n\n`
  }
  
  /**
   * Generate SDK hook import
   */
  static hookImport(model: ParsedModel, hooks: string[]): string {
    const hookList = hooks.map(h => `use${model.name}${h}`).join(', ')
    return `import { ${hookList} } from '@/generated/sdk/hooks/react/use-${model.nameLower}'`
  }
  
  /**
   * Generate type import
   */
  static typeImport(models: ParsedModel[]): string {
    const types = models.map(m => m.name).join(', ')
    return `import type { ${types} } from '@/generated/sdk/types'`
  }
  
  /**
   * Generate shared component import
   */
  static sharedImport(components: string[]): string {
    return `import { ${components.join(', ')} } from '@ssot-ui/shared'`
  }
  
  /**
   * Generate client directive
   */
  static clientDirective(): string {
    return `'use client'\n\n`
  }
  
  /**
   * Build complete import block
   */
  static imports(options: {
    hooks?: { model: ParsedModel; types: string[] }
    types?: ParsedModel[]
    shared?: string[]
    custom?: string[]
    useClient?: boolean
  }): string {
    let imports = ''
    
    if (options.useClient) {
      imports += this.clientDirective()
    }
    
    if (options.hooks) {
      imports += this.hookImport(options.hooks.model, options.hooks.types) + '\n'
    }
    
    if (options.types) {
      imports += this.typeImport(options.types) + '\n'
    }
    
    if (options.shared) {
      imports += this.sharedImport(options.shared) + '\n'
    }
    
    if (options.custom) {
      imports += options.custom.join('\n') + '\n'
    }
    
    return imports + '\n'
  }
}

/**
 * Page builder - generate common page patterns
 */
export class PageBuilder {
  constructor(
    private template: string,
    private models: { [key: string]: ParsedModel },
    private fields: { [key: string]: any }
  ) {}
  
  /**
   * Generate a list page (common pattern)
   */
  buildListPage(options: {
    model: ParsedModel
    title: string
    cardComponent?: string
    filters?: string[]
    sortBy?: string
    includeRelations?: string[]
  }): string {
    const { model, title, cardComponent, filters, sortBy, includeRelations } = options
    
    const filterCode = filters 
      ? `filters: [{ field: '${filters[0]}', op: 'eq', value: true }],`
      : ''
    
    const sortCode = sortBy
      ? `sort: [{ field: '${sortBy}', dir: 'desc' }],`
      : ''
    
    const includeCode = includeRelations
      ? `include: { ${includeRelations.join(': true, ')}: true }`
      : ''
    
    return `${CodeBuilder.header(this.template, `${title} page`)}${CodeBuilder.imports({
      useClient: true,
      hooks: { model, types: ['List'] },
      custom: cardComponent ? [`import { ${cardComponent} } from '@/components/${cardComponent}'`] : []
    })}export default function ${title.replace(/\s/g, '')}Page() {
  const { data: items, isLoading } = use${model.name}List({
    ${filterCode}
    ${sortCode}
    ${includeCode}
  })
  
  return (
    <div className="container mx-auto px-4 py-12">
      <h1 className="text-4xl font-bold mb-8">${title}</h1>
      
      {isLoading ? (
        <div>Loading...</div>
      ) : items && items.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {items.map((item) => (
            ${cardComponent ? `<${cardComponent} key={item.id} ${model.nameLower}={item} />` : `<div key={item.id}>{JSON.stringify(item)}</div>`}
          ))}
        </div>
      ) : (
        <div className="text-center py-12">
          <p className="text-neutral-600">No items found.</p>
        </div>
      )}
    </div>
  )
}
`
  }
  
  /**
   * Generate a detail page (common pattern)
   */
  buildDetailPage(options: {
    model: ParsedModel
    title: string
    displayFields: Array<{ field: string; label: string; format?: 'date' | 'text' | 'html' }>
    includeRelations?: string[]
    backLink?: string
  }): string {
    const { model, title, displayFields, includeRelations, backLink } = options
    
    const includeCode = includeRelations
      ? `include: { ${includeRelations.join(': true, ')}: true }`
      : ''
    
    return `${CodeBuilder.header(this.template, `${title} detail page`)}${CodeBuilder.imports({
      useClient: true,
      hooks: { model, types: [''] },
      custom: backLink ? ["import Link from 'next/link'"] : []
    })}export default function ${title.replace(/\s/g, '')}DetailPage({
  params
}: {
  params: { id: string }
}) {
  const { data: item, isLoading } = use${model.name}(Number(params.id), {
    ${includeCode}
  })
  
  if (isLoading) return <div>Loading...</div>
  if (!item) return <div>Not found</div>
  
  return (
    <div className="container mx-auto px-4 py-12">
      ${backLink ? `<Link href="${backLink}" className="text-primary-600 hover:underline mb-6 inline-block">← Back</Link>` : ''}
      
      <h1 className="text-4xl font-bold mb-8">${title}</h1>
      
      <div className="bg-white rounded-lg border p-6">
        <dl className="space-y-4">
          ${displayFields.map(f => `
          <div>
            <dt className="font-medium text-neutral-700">${f.label}</dt>
            <dd className="text-neutral-900">
              {${f.format === 'date' ? `new Date(item.${f.field}).toLocaleDateString()` : f.format === 'html' ? `<div dangerouslySetInnerHTML={{ __html: item.${f.field} }} />` : `item.${f.field}`}}
            </dd>
          </div>`).join('')}
        </dl>
      </div>
    </div>
  )
}
`
  }
  
  /**
   * Generate a form page (create/edit pattern)
   */
  buildFormPage(options: {
    model: ParsedModel
    mode: 'create' | 'edit'
    fields: Array<{ name: string; label: string; type: 'text' | 'textarea' | 'checkbox' }>
    backLink?: string
  }): string {
    const { model, mode, fields: formFields, backLink } = options
    const isEdit = mode === 'edit'
    
    const hookType = isEdit ? 'Update' : 'Create'
    const formDataInit = formFields.map(f => 
      `${f.name}: ${f.type === 'checkbox' ? 'false' : "''"}`
    ).join(',\n    ')
    
    return `${CodeBuilder.header(this.template, `${mode} ${model.name} page`)}${CodeBuilder.imports({
      useClient: true,
      hooks: { model, types: [isEdit ? ', useUpdate' : 'Create'] },
      custom: ["import { useState } from 'react'", backLink ? "import Link from 'next/link'" : null].filter(Boolean) as string[]
    })}export default function ${mode === 'create' ? 'New' : 'Edit'}${model.name}Page(${isEdit ? `{
  params
}: {
  params: { id: string }
}` : ''}) {
  ${isEdit ? `const { data: item } = use${model.name}(Number(params.id))` : ''}
  const { mutate, isPending } = use${hookType}${model.name}()
  
  const [formData, setFormData] = useState({
    ${formDataInit}
  })
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    mutate(${isEdit ? '{ id: Number(params.id), data: formData }' : 'formData'})
  }
  
  return (
    <div className="p-8 max-w-4xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">${mode === 'create' ? 'Create' : 'Edit'} ${model.name}</h1>
      
      <form onSubmit={handleSubmit} className="space-y-6">
        ${formFields.map(f => `
        <div>
          <label className="block text-sm font-medium mb-2">${f.label}</label>
          ${f.type === 'textarea' 
            ? `<textarea
              value={formData.${f.name}}
              onChange={(e) => setFormData({ ...formData, ${f.name}: e.target.value })}
              className="w-full px-4 py-2 border rounded-lg"
              rows={4}
            />`
            : f.type === 'checkbox'
            ? `<input
              type="checkbox"
              checked={formData.${f.name}}
              onChange={(e) => setFormData({ ...formData, ${f.name}: e.target.checked })}
              className="w-4 h-4"
            />`
            : `<input
              type="text"
              value={formData.${f.name}}
              onChange={(e) => setFormData({ ...formData, ${f.name}: e.target.value })}
              className="w-full px-4 py-2 border rounded-lg"
            />`
          }
        </div>`).join('')}
        
        <div className="flex gap-3">
          <button
            type="submit"
            disabled={isPending}
            className="px-6 py-2 bg-primary-600 text-white rounded-lg"
          >
            {isPending ? 'Saving...' : 'Save'}
          </button>
          ${backLink ? `<Link href="${backLink}" className="px-6 py-2 border rounded-lg">Cancel</Link>` : ''}
        </div>
      </form>
    </div>
  )
}
`
  }
}

/**
 * Component builder - generate components with shared component integration
 */
export class ComponentBuilder {
  constructor(
    private template: string,
    private sharedComponents: string[] = []
  ) {}
  
  /**
   * Build an item card component (posts, products, etc.)
   */
  buildItemCard(options: {
    model: ParsedModel
    displayFields: Array<{
      field: string
      type: 'title' | 'text' | 'image' | 'date' | 'tags' | 'author'
      useShared?: string  // Which shared component to use
    }>
    linkTo?: string
  }): string {
    const { model, displayFields, linkTo } = options
    
    const usedShared = new Set<string>()
    displayFields.forEach(f => {
      if (f.useShared) usedShared.add(f.useShared)
    })
    
    return `${CodeBuilder.header(this.template, `${model.name} card component`)}${CodeBuilder.imports({
      types: [model],
      shared: Array.from(usedShared),
      custom: linkTo ? ["import Link from 'next/link'"] : []
    })}interface ${model.name}CardProps {
  ${model.nameLower}: ${model.name}
}

export function ${model.name}Card({ ${model.nameLower} }: ${model.name}CardProps) {
  return (
    <article className="bg-white rounded-lg border p-6">
      ${displayFields.map(f => {
        if (f.type === 'title' && linkTo) {
          return `<Link href={\`${linkTo}/\${${model.nameLower}.id}\`}>
        <h2 className="text-xl font-bold mb-2 hover:text-primary-600">{${model.nameLower}.${f.field}}</h2>
      </Link>`
        }
        if (f.type === 'date' && f.useShared === 'TimeAgo') {
          return `<TimeAgo date={${model.nameLower}.${f.field}} className="text-sm text-neutral-500" />`
        }
        if (f.type === 'author' && f.useShared === 'Avatar') {
          return `<div className="flex items-center gap-2">
        <Avatar src={${model.nameLower}.${f.field}?.avatar} alt={${model.nameLower}.${f.field}?.name} size="sm" />
        <span className="text-sm text-neutral-600">{${model.nameLower}.${f.field}?.name}</span>
      </div>`
        }
        return `<p className="text-neutral-700">{${model.nameLower}.${f.field}}</p>`
      }).join('\n      ')}
    </article>
  )
}
`
  }
}

/**
 * Template factory - high-level template generator
 */
export class TemplateFactory {
  private fileManager: FileManager
  private modelResolver: ModelResolver
  private fieldResolver: FieldResolver
  private pageBuilder: PageBuilder
  private componentBuilder: ComponentBuilder
  
  constructor(
    projectPath: string,
    templateName: string,
    models: ParsedModel[],
    mappings: SchemaMapping
  ) {
    this.fileManager = new FileManager(projectPath)
    this.modelResolver = new ModelResolver(models, mappings)
    this.fieldResolver = new FieldResolver(mappings)
    this.pageBuilder = new PageBuilder(templateName, {}, {})
    this.componentBuilder = new ComponentBuilder(templateName, ['Avatar', 'Badge', 'TimeAgo', 'Button', 'Card'])
  }
  
  /**
   * Generate complete template
   */
  generate(definition: TemplateDefinition): void {
    // Create directories
    definition.directories.forEach(dir => this.fileManager.ensureDir(dir))
    
    // Generate files from definition
    const files: Record<string, string> = {}
    
    for (const page of definition.pages) {
      if (page.type === 'list') {
        files[page.path] = this.pageBuilder.buildListPage({
          model: this.modelResolver.requireModel(page.model),
          title: page.title,
          cardComponent: page.cardComponent,
          filters: page.filters,
          sortBy: page.sortBy,
          includeRelations: page.includeRelations
        })
      } else if (page.type === 'detail') {
        files[page.path] = this.pageBuilder.buildDetailPage({
          model: this.modelResolver.requireModel(page.model),
          title: page.title,
          displayFields: page.displayFields || [],
          includeRelations: page.includeRelations,
          backLink: page.backLink
        })
      } else if (page.type === 'form') {
        files[page.path] = this.pageBuilder.buildFormPage({
          model: this.modelResolver.requireModel(page.model),
          mode: page.mode as 'create' | 'edit',
          fields: page.formFields || [],
          backLink: page.backLink
        })
      }
    }
    
    // Generate components from definition
    for (const component of definition.components || []) {
      if (component.type === 'item-card') {
        files[component.path] = this.componentBuilder.buildItemCard({
          model: this.modelResolver.requireModel(component.model),
          displayFields: component.displayFields || [],
          linkTo: component.linkTo
        })
      }
    }
    
    // Write all files
    this.fileManager.writeFiles(files)
  }
}

/**
 * Template definition interface (declarative template spec)
 */
export interface TemplateDefinition {
  name: string
  directories: string[]
  pages: Array<{
    type: 'list' | 'detail' | 'form' | 'custom'
    path: string
    model: string
    title: string
    cardComponent?: string
    filters?: string[]
    sortBy?: string
    includeRelations?: string[]
    displayFields?: any[]
    formFields?: any[]
    mode?: string
    backLink?: string
  }>
  components?: Array<{
    type: 'item-card' | 'custom'
    path: string
    model: string
    displayFields?: any[]
    linkTo?: string
  }>
}

/**
 * USAGE EXAMPLE:
 * 
 * const factory = new TemplateFactory(projectPath, 'blog', models, mappings)
 * 
 * factory.generate({
 *   name: 'blog',
 *   directories: ['app/(blog)', 'app/admin/posts', 'components'],
 *   pages: [
 *     {
 *       type: 'list',
 *       path: 'app/(blog)/posts/page.tsx',
 *       model: 'post',
 *       title: 'All Posts',
 *       cardComponent: 'PostCard',
 *       sortBy: 'createdAt',
 *       includeRelations: ['author']
 *     },
 *     {
 *       type: 'detail',
 *       path: 'app/(blog)/posts/[slug]/page.tsx',
 *       model: 'post',
 *       title: 'Post',
 *       displayFields: [
 *         { field: 'title', label: 'Title', format: 'text' },
 *         { field: 'content', label: 'Content', format: 'html' }
 *       ],
 *       backLink: '/posts'
 *     },
 *     {
 *       type: 'form',
 *       path: 'app/admin/posts/new/page.tsx',
 *       model: 'post',
 *       title: 'New Post',
 *       mode: 'create',
 *       formFields: [
 *         { name: 'title', label: 'Title', type: 'text' },
 *         { name: 'content', label: 'Content', type: 'textarea' }
 *       ]
 *     }
 *   ],
 *   components: [
 *     {
 *       type: 'item-card',
 *       path: 'components/PostCard.tsx',
 *       model: 'post',
 *       displayFields: [
 *         { field: 'title', type: 'title' },
 *         { field: 'excerpt', type: 'text' },
 *         { field: 'author', type: 'author', useShared: 'Avatar' },
 *         { field: 'createdAt', type: 'date', useShared: 'TimeAgo' }
 *       ],
 *       linkTo: '/posts'
 *     }
 *   ]
 * })
 * 
 * Result: Entire blog template generated from declarative definition!
 */

