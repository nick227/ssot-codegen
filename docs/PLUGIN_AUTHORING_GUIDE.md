# Plugin Authoring Guide

Complete guide for creating custom SSOT Codegen plugins.

---

## Overview

SSOT Codegen supports two plugin APIs:
- **V2 Plugin API** (Recommended) - Modern phase-based architecture with lifecycle hooks
- **V1 Plugin API** (Legacy) - Simple feature generation interface

This guide focuses on the **V2 Plugin API**, which provides:
- ✅ Full access to the generation pipeline
- ✅ Custom phase injection
- ✅ Lifecycle hooks (validate, generate, healthCheck)
- ✅ Dependency injection and context sharing
- ✅ Integration with PhaseRunner

---

## Quick Start

### 1. Create Plugin File

Create a new file in `packages/gen/src/plugins/`:

```typescript
// packages/gen/src/plugins/my-custom-plugin.ts

import { PluginV2, type PluginContext } from './plugin-v2.interface.js'
import type { GenerationPhase } from '../generator/phase-runner.js'

export class MyCustomPlugin implements PluginV2 {
  // Basic metadata
  name = 'my-custom-plugin'
  version = '1.0.0'
  description = 'My awesome custom plugin'
  
  // Plugin requirements
  requirements = {
    models: {
      required: ['User'],  // Requires User model in schema
      optional: []
    },
    envVars: {
      required: ['MY_API_KEY'],  // Requires MY_API_KEY env var
      optional: ['MY_DEBUG']
    }
  }
  
  // Validation hook (runs before generation)
  async validate(context: PluginContext): Promise<{ valid: boolean; errors: string[] }> {
    const errors: string[] = []
    
    // Check if User model exists
    const hasUser = context.schema.models.some(m => m.name === 'User')
    if (!hasUser) {
      errors.push('User model is required')
    }
    
    // Check if API key is set
    if (!process.env.MY_API_KEY) {
      errors.push('MY_API_KEY environment variable is required')
    }
    
    return { 
      valid: errors.length === 0, 
      errors 
    }
  }
  
  // Generation hook (runs during code generation)
  async generate(context: PluginContext) {
    const { outputDir, schema } = context
    
    // Your plugin logic here
    const code = this.generateMyCode(schema)
    
    return {
      files: {
        'plugins/my-plugin.ts': code
      },
      envVars: {
        MY_API_KEY: 'your-api-key-here'
      },
      dependencies: {
        'my-package': '^1.0.0'
      },
      metadata: {
        generatedAt: new Date().toISOString()
      }
    }
  }
  
  // Health check hook (for self-validation tests)
  async healthCheck(context: PluginContext) {
    return {
      checks: [
        {
          name: 'My Plugin Connection',
          passed: true,
          message: 'Successfully connected to service'
        }
      ]
    }
  }
  
  // Helper method
  private generateMyCode(schema: any): string {
    return `// Generated by ${this.name}\nexport const myFeature = () => { /* ... */ }`
  }
}
```

### 2. Register Plugin

Add to `packages/gen/src/plugins/plugin-manager.ts`:

```typescript
import { MyCustomPlugin } from './my-custom-plugin.js'

export function loadPlugins(config: PluginConfig): FeaturePlugin[] {
  const plugins: FeaturePlugin[] = []
  
  // ... existing plugins ...
  
  if (config.enableMyPlugin) {
    plugins.push(new MyCustomPlugin())
  }
  
  return plugins
}
```

### 3. Enable Plugin

Set environment variable:

```bash
ENABLE_MY_PLUGIN=true pnpm ssot generate example
```

---

## Plugin API Reference

### PluginV2 Interface

```typescript
interface PluginV2 {
  // Metadata
  name: string
  version: string
  description: string
  
  // Requirements (optional)
  requirements?: {
    models?: {
      required?: string[]
      optional?: string[]
    }
    envVars?: {
      required?: string[]
      optional?: string[]
    }
    dependencies?: Record<string, string>
  }
  
  // Lifecycle Hooks
  validate?(context: PluginContext): Promise<ValidationResult>
  generate?(context: PluginContext): Promise<GenerationResult>
  healthCheck?(context: PluginContext): Promise<HealthCheckResult>
  
  // Advanced Features
  registerPhases?(): GenerationPhase[]
  onBeforeGenerate?(context: PluginContext): Promise<void>
  onAfterGenerate?(context: PluginContext): Promise<void>
}
```

### PluginContext

```typescript
interface PluginContext {
  schema: ParsedSchema          // Prisma schema AST
  outputDir: string             // Output directory path
  config: GeneratorConfig       // Generator configuration
  logger: CLILogger            // Logger instance
  models: string[]             // Model names
  pathsConfig: PathsConfig     // Path resolution config
}
```

### ValidationResult

```typescript
interface ValidationResult {
  valid: boolean
  errors: string[]
  warnings?: string[]
}
```

### GenerationResult

```typescript
interface GenerationResult {
  files: Record<string, string>              // filename -> content
  envVars?: Record<string, string>           // env var -> default value
  dependencies?: Record<string, string>      // package -> version
  metadata?: Record<string, unknown>         // custom metadata
}
```

### HealthCheckResult

```typescript
interface HealthCheckResult {
  checks: Array<{
    name: string
    passed: boolean
    message: string
    details?: Record<string, unknown>
  }>
}
```

---

## Advanced Features

### Custom Generation Phases

Inject custom phases into the generation pipeline:

```typescript
import { GenerationPhase, type PhaseContext, type PhaseResult, PhaseResults } from '../generator/phase-runner.js'

class MyCustomPhase extends GenerationPhase {
  readonly name = 'myCustomPhase'
  readonly order = 100  // Run after standard phases (0-13)
  
  getDescription(): string {
    return 'Running my custom logic'
  }
  
  async execute(context: PhaseContext): Promise<PhaseResult> {
    // Read from context
    const { schema, outputDir } = context
    
    // Your phase logic here
    const filesGenerated = await this.doCustomWork(context)
    
    // Use typed result builder
    return PhaseResults.success({ customData: 'value' }, filesGenerated)
  }
  
  private async doCustomWork(context: PhaseContext): Promise<number> {
    // Implementation
    return 0
  }
}

export class MyPluginWithPhases implements PluginV2 {
  name = 'my-plugin-with-phases'
  version = '1.0.0'
  description = 'Plugin with custom phases'
  
  registerPhases(): GenerationPhase[] {
    return [
      new MyCustomPhase()
    ]
  }
}
```

#### Phase Order Reference

Standard phases run in this order (0-13):

| Order | Phase | Description |
|-------|-------|-------------|
| 0 | SetupOutputDir | Determines output directory |
| 1 | ParseSchema | Parses Prisma schema |
| 2 | ValidateSchema | Validates schema structure |
| 3 | AnalyzeRelationships | Analyzes model relationships |
| 4 | GenerateCode | Generates all code files |
| 5 | WriteFiles | Writes generated files to disk |
| 6 | WriteInfrastructure | Writes base infrastructure |
| 7 | GenerateBarrels | Generates barrel exports |
| 8 | GenerateOpenAPI | Generates OpenAPI spec |
| 9 | WriteManifest | Writes generation manifest |
| 10 | GenerateTsConfig | Generates TypeScript config |
| 11 | WriteStandalone | Writes standalone project files |
| 12 | WriteTests | Generates test suite |
| 13 | FormatCode | Formats generated code (optional) |

**Inserting Custom Phases:**

- **Before standard phases**: Use order < 0 (e.g., -1, -10)
- **Between phases**: Use fractional order (e.g., 4.5 runs between phases 4 and 5)
- **After standard phases**: Use order > 13 (e.g., 100, 200)

```typescript
class PreProcessPhase extends GenerationPhase {
  readonly order = -1  // Runs before everything
  // ...
}

class PostProcessPhase extends GenerationPhase {
  readonly order = 100  // Runs after everything
  // ...
}

class InterceptPhase extends GenerationPhase {
  readonly order = 5.5  // Runs between WriteFiles (5) and WriteInfrastructure (6)
  // ...
}
```

### Plugin-Phase Extension API

PhaseRunner provides methods to programmatically control phase execution:

```typescript
import { PhaseRunner } from '../generator/phase-runner.js'
import { createAllPhases } from '../generator/phases/index.js'

// Create runner
const runner = new PhaseRunner(config, logger)

// Register all standard phases
const standardPhases = createAllPhases()
runner.registerPhases(standardPhases)

// Add custom phases
runner.registerPhase(new MyCustomPhase())

// Run all phases in order
await runner.run()
```

**Advanced Pattern: Conditional Phase Injection**

```typescript
export class ConditionalPlugin implements PluginV2 {
  name = 'conditional-plugin'
  version = '1.0.0'
  description = 'Conditionally adds phases'
  
  registerPhases(): GenerationPhase[] {
    const phases: GenerationPhase[] = []
    
    // Always add this phase
    phases.push(new AlwaysRunPhase())
    
    // Conditionally add based on environment
    if (process.env.ENABLE_EXPERIMENTAL === 'true') {
      phases.push(new ExperimentalPhase())
    }
    
    return phases
  }
}
```

**Future Enhancement: insertBefore/insertAfter Hooks**

*Note: This API is planned but not yet implemented. Current approach is to use phase order numbers.*

```typescript
// Planned API (not yet available)
runner.insertBefore('writeFiles', new PreWritePhase())
runner.insertAfter('generateCode', new PostGeneratePhase())
runner.replace('writeTests', new CustomTestPhase())
```

If you need this functionality now, please open an issue on GitHub!
```

### Lifecycle Hooks

```typescript
export class MyPluginWithHooks implements PluginV2 {
  name = 'my-plugin-with-hooks'
  version = '1.0.0'
  description = 'Plugin with lifecycle hooks'
  
  async onBeforeGenerate(context: PluginContext): Promise<void> {
    // Setup work before generation starts
    console.log('Preparing plugin...')
  }
  
  async onAfterGenerate(context: PluginContext): Promise<void> {
    // Cleanup or post-processing after generation
    console.log('Plugin work complete!')
  }
}
```

### Accessing Schema Information

```typescript
async generate(context: PluginContext) {
  const { schema } = context
  
  // Iterate over models
  for (const model of schema.models) {
    console.log(`Model: ${model.name}`)
    
    // Access fields
    for (const field of model.fields) {
      console.log(`  Field: ${field.name} (${field.type})`)
    }
    
    // Check for specific annotations
    const serviceAnnotation = model.documentation?.includes('@service')
    if (serviceAnnotation) {
      // Handle service-annotated models
    }
  }
  
  // Filter models by criteria
  const userModels = schema.models.filter(m => 
    m.fields.some(f => f.name === 'email')
  )
  
  return { files: {} }
}
```

---

## Real-World Examples

### Example 1: Simple Code Generator

```typescript
export class SimpleCodeGenPlugin implements PluginV2 {
  name = 'simple-code-gen'
  version = '1.0.0'
  description = 'Generates utility functions'
  
  async generate(context: PluginContext) {
    const { schema, outputDir } = context
    
    const utilCode = `
// @generated
export const modelNames = ${JSON.stringify(schema.models.map(m => m.name))};

export function isValidModel(name: string): boolean {
  return modelNames.includes(name);
}
`
    
    return {
      files: {
        'utils/model-helpers.ts': utilCode
      }
    }
  }
}
```

### Example 2: API Integration Plugin

```typescript
export class APIIntegrationPlugin implements PluginV2 {
  name = 'api-integration'
  version = '1.0.0'
  description = 'Integrates with external API'
  
  requirements = {
    envVars: {
      required: ['API_BASE_URL', 'API_KEY']
    }
  }
  
  async validate(context: PluginContext) {
    const errors: string[] = []
    
    if (!process.env.API_BASE_URL) {
      errors.push('API_BASE_URL is required')
    }
    
    if (!process.env.API_KEY) {
      errors.push('API_KEY is required')
    }
    
    return { valid: errors.length === 0, errors }
  }
  
  async generate(context: PluginContext) {
    const apiClient = this.generateAPIClient()
    
    return {
      files: {
        'integrations/api-client.ts': apiClient
      },
      envVars: {
        API_BASE_URL: 'https://api.example.com',
        API_KEY: 'your-api-key'
      },
      dependencies: {
        'axios': '^1.6.0'
      }
    }
  }
  
  async healthCheck() {
    // Test API connection
    const isConnected = await this.testConnection()
    
    return {
      checks: [
        {
          name: 'API Connection',
          passed: isConnected,
          message: isConnected 
            ? 'Successfully connected to API' 
            : 'Failed to connect to API'
        }
      ]
    }
  }
  
  private generateAPIClient(): string {
    return `
import axios from 'axios'

const apiClient = axios.create({
  baseURL: process.env.API_BASE_URL,
  headers: {
    'Authorization': \`Bearer \${process.env.API_KEY}\`
  }
})

export default apiClient
`
  }
  
  private async testConnection(): Promise<boolean> {
    try {
      // Test logic here
      return true
    } catch {
      return false
    }
  }
}
```

### Example 3: Service Integration with @service Annotation

```typescript
export class ServiceIntegrationPlugin implements PluginV2 {
  name = 'service-integration'
  version = '1.0.0'
  description = 'Generates service integrations from @service annotations'
  
  async generate(context: PluginContext) {
    const { schema } = context
    const files: Record<string, string> = {}
    
    // Find models with @service annotation
    for (const model of schema.models) {
      const doc = model.documentation || ''
      const serviceMatch = doc.match(/@service\s+(\w+)/)
      
      if (serviceMatch) {
        const serviceName = serviceMatch[1]
        files[`services/${serviceName.toLowerCase()}-integration.ts`] = 
          this.generateServiceIntegration(serviceName, model)
      }
    }
    
    return { files }
  }
  
  private generateServiceIntegration(serviceName: string, model: any): string {
    return `
// @generated
// Service integration for ${serviceName}

export class ${serviceName}Integration {
  async process${model.name}(data: any) {
    // Implementation
  }
}
`
  }
}
```

---

## Testing Your Plugin

### Unit Tests

```typescript
import { describe, it, expect } from 'vitest'
import { MyCustomPlugin } from '../my-custom-plugin.js'

describe('MyCustomPlugin', () => {
  it('should validate successfully with correct config', async () => {
    const plugin = new MyCustomPlugin()
    
    const context = {
      schema: {
        models: [{ name: 'User', fields: [] }]
      },
      outputDir: '/tmp/test',
      config: {},
      logger: console,
      models: ['User'],
      pathsConfig: {}
    }
    
    process.env.MY_API_KEY = 'test-key'
    
    const result = await plugin.validate(context)
    expect(result.valid).toBe(true)
    expect(result.errors).toHaveLength(0)
  })
  
  it('should generate expected files', async () => {
    const plugin = new MyCustomPlugin()
    
    const context = {
      schema: { models: [] },
      outputDir: '/tmp/test',
      config: {},
      logger: console,
      models: [],
      pathsConfig: {}
    }
    
    const result = await plugin.generate(context)
    
    expect(result.files).toHaveProperty('plugins/my-plugin.ts')
    expect(result.envVars).toHaveProperty('MY_API_KEY')
  })
})
```

### Integration Tests

Generate with your plugin enabled and verify output:

```bash
# Enable plugin
ENABLE_MY_PLUGIN=true pnpm ssot generate minimal

# Verify files were generated
ls generated/minimal-1/src/plugins/

# Run generated project tests
cd generated/minimal-1
pnpm install
pnpm test
```

---

## Best Practices

### 1. Clear Requirements

```typescript
requirements = {
  models: {
    required: ['User', 'Post'],
    optional: ['Comment']
  },
  envVars: {
    required: ['API_KEY'],
    optional: ['DEBUG_MODE']
  }
}
```

### 2. Comprehensive Validation

```typescript
async validate(context: PluginContext) {
  const errors: string[] = []
  const warnings: string[] = []
  
  // Check required models
  for (const modelName of this.requirements.models?.required || []) {
    if (!context.models.includes(modelName)) {
      errors.push(`Required model '${modelName}' not found`)
    }
  }
  
  // Check env vars
  for (const envVar of this.requirements.envVars?.required || []) {
    if (!process.env[envVar]) {
      errors.push(`Required environment variable '${envVar}' not set`)
    }
  }
  
  // Provide helpful warnings
  if (context.models.length > 20) {
    warnings.push('Large schema detected - generation may take longer')
  }
  
  return { valid: errors.length === 0, errors, warnings }
}
```

### 3. Clean Code Generation

```typescript
private generateCode(model: string): string {
  // Use template literals for clean formatting
  return `// @generated
// This file is automatically generated. Do not edit manually.

export class ${model}Service {
  constructor() {
    // Initialize
  }
  
  async process() {
    // Implementation
  }
}
`
}
```

### 4. Helpful Health Checks

```typescript
async healthCheck(context: PluginContext) {
  const checks = []
  
  // Test API connection
  const apiCheck = await this.testAPI()
  checks.push({
    name: 'API Connection',
    passed: apiCheck.success,
    message: apiCheck.message,
    details: { latency: apiCheck.latency }
  })
  
  // Test file access
  const fileCheck = await this.testFileAccess(context.outputDir)
  checks.push({
    name: 'File Access',
    passed: fileCheck.success,
    message: fileCheck.message
  })
  
  return { checks }
}
```

### 5. Error Handling

```typescript
async generate(context: PluginContext) {
  try {
    const files = await this.generateFiles(context)
    return { files }
  } catch (error) {
    context.logger.error(`Plugin ${this.name} failed:`, error as Error)
    throw error
  }
}
```

---

## Debugging

### Enable Debug Logging

```typescript
async generate(context: PluginContext) {
  const { logger } = context
  
  logger.debug('Starting generation...')
  logger.info('Processing models:', context.models)
  
  // Your logic
  
  logger.debug('Generation complete')
  
  return { files: {} }
}
```

### Test Plugin in Isolation

```typescript
// test-plugin.ts
import { MyCustomPlugin } from './src/plugins/my-custom-plugin.js'

const plugin = new MyCustomPlugin()

const mockContext = {
  schema: { models: [] },
  outputDir: './test-output',
  config: {},
  logger: console,
  models: [],
  pathsConfig: {}
}

const result = await plugin.generate(mockContext)
console.log('Generated files:', Object.keys(result.files))
```

---

## See Also

- [Plugin V2 API Documentation](PLUGIN_API_V2.md)
- [Provider Plugins Index](PROVIDER_PLUGINS_INDEX.md)
- [Phase Runner Architecture](PHASE_RUNNER_ARCHITECTURE.md)
- [Plugin Configuration Guide](PLUGIN_CONFIGURATION.md)

---

## Need Help?

- Check existing plugins in `packages/gen/src/plugins/` for examples
- Review the [Plugin V2 Interface](../packages/gen/src/plugins/plugin-v2.interface.ts)
- Open an issue on GitHub for questions or feature requests

