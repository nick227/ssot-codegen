# UI Generation - Master Implementation Plan

## üéØ Executive Summary

Build TWO distinct UI generation systems:

**PATH 1: Dynamic Admin Panel** (Dev tool with field mapper)
- Zero-config data browser for any schema
- Uses intelligent field detection
- For development and internal admin panels
- **Read-only by default** (write mode per model/field)

**PATH 2: Production UI Templates** (Real apps with schema mapping)
- Pre-built UI projects (blog, e-commerce, CRM)
- Explicit schema-to-template variable mapping
- Production-ready components

**CRITICAL FOUNDATION**: Lock SDK contract first - all components depend on standardized hook shapes.

---

## üîí SDK Contract (MUST BE LOCKED FIRST)

**All UI packages depend on this standardized interface:**

```
useList(resource, params) ‚Üí { data, total, isLoading, error, refetch }
  params: { page, pageSize, sort, filters, search }

useGet(resource, { id }) ‚Üí { data, isLoading, error }

useCreate(resource) ‚Üí { mutate, isPending, error }

useUpdate(resource) ‚Üí { mutate, isPending, error }

useDelete(resource) ‚Üí { mutate, isPending, error }
```

**Adapters**: Translate to REST/GraphQL/tRPC backend implementations

**Decision**: Freeze this contract before ANY template or component work begins

---

## üé® Cross-Cutting Decisions (Decide Once, Use Everywhere)

### Routing Stacks
- **Web**: Next.js App Router (production templates and CRUD screens assume this)
- **Mobile**: Expo Router (Phase 2+, templates will support this)

### Theme System (Build First)
- **Web**: Tailwind extend configuration with semantic tokens
- **Mobile**: JavaScript tokens (React Native StyleSheet)
- **Requirement**: Identical token names across platforms
- **Priority**: Define tokens before any component styling

### Pagination Shape
- **Server returns**: `{ items: T[], total: number }`
- **Client sends**: `{ page: number, pageSize: number }`

### Filter Syntax (Server-agnostic)
```
{
  field: string
  op: 'eq' | 'ne' | 'in' | 'lt' | 'lte' | 'gt' | 'gte' | 
       'contains' | 'startsWith' | 'endsWith' | 'between'
  value: any
}
```

### Error Format
```
{
  code: string
  message: string
  details?: Record<string, any>
}
```

### Authentication Context
- Components receive `onUnauthorized` / redirect callback
- No auth mechanics in components
- Auth implementation stays in user's app

### Internationalization
- Strings via simple dictionary prop
- Templates ship with `en` default
- User provides translations

### Code Generation Standards

**Every generated file MUST include**:
```typescript
/**
 * Generated by SSOT UI Generator v1.0.0
 * Template: blog
 * Generated: 2025-01-15 10:32 AM
 * 
 * ‚ú® SAFE TO EDIT - Your changes preserved on regeneration
 * üîÑ To regenerate: pnpm ssot generate --ui
 * üìñ Docs: https://ssot-codegen.dev/ui/customization
 */
```

**File naming conventions**:
- Use Next.js conventions: `page.tsx`, `layout.tsx`, `[id]/page.tsx`
- Component files: kebab-case `post-card.tsx`, `user-avatar.tsx`
- No auto-generated suffixes: `PostList.tsx` not `PostList.generated.tsx`

**Code style**:
- Readable: Standard React patterns, not minified
- Typed: Full TypeScript with user's schema types
- Documented: Comments explain non-obvious logic
- Consistent: Follows project's existing style (Prettier/ESLint)

**Smart regeneration behavior**:
- Detect if file was modified by user
- Prompt before overwriting changed files
- Offer three-way merge or diff view
- Preserve user's customizations
- Or use "safe zones" with markers:
  ```typescript
  // ===== GENERATED CODE START - DO NOT EDIT =====
  const generatedConfig = { ... }
  // ===== GENERATED CODE END =====
  
  // ‚ú® YOUR CODE - Safe to edit
  const customizations = { ... }
  ```

---

## üì¶ Repository Structure (Docs-First)

```
monorepo/
‚îú‚îÄ‚îÄ packages/
‚îÇ   ‚îú‚îÄ‚îÄ ui-data-table/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stories/         (Storybook - 5+ examples)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ   ‚îú‚îÄ‚îÄ ui-form-builder/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stories/         (Storybook - 4+ examples)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ   ‚îú‚îÄ‚îÄ ui-crud-screens/
‚îÇ   ‚îú‚îÄ‚îÄ sdk-adapter/         (Shared adapter package)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rest-adapter.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ trpc-adapter.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ graphql-adapter.ts
‚îÇ   ‚îî‚îÄ‚îÄ admin-panel/
‚îÇ
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îú‚îÄ‚îÄ blog/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ template.json    (Metadata)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ examples/        (Full example projects)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ   ‚îú‚îÄ‚îÄ ecommerce/
‚îÇ   ‚îî‚îÄ‚îÄ crm/
‚îÇ
‚îî‚îÄ‚îÄ docs/
    ‚îú‚îÄ‚îÄ sdk-contract.md
    ‚îú‚îÄ‚îÄ theme-tokens.md
    ‚îî‚îÄ‚îÄ templates/
```

---

## ‚ö†Ô∏è Risks & Mitigations

### Risk 1: Scope Creep in Phase 1
**Mitigation**: 
- Ship ONLY data-table + form-builder first
- Defer auth-forms until a template actually needs it
- Defer dashboard-cards until required

### Risk 2: Template/SDK Mismatch
**Mitigation**:
- Freeze SDK hook contract before any template work
- All templates must validate against locked contract
- Breaking changes require major version bump

### Risk 3: Field-Mapper Accuracy (Admin Panel)
**Mitigation**:
- Keep admin panel READ-ONLY for v1
- Enable write mode only after manual allowlist per field
- Clear warnings on dangerous operations

### Risk 4: Bundle Size Bloat
**Mitigation**:
- Target: <60kb gzipped per package (without charts)
- Tree-shakeable exports
- Lazy load heavy components (rich text, charts)
- Monitor with bundlesize bot

---

## üé® Foundation: Theme Tokens (Week 0 - BUILD FIRST)

**Priority: CRITICAL - Must be defined before ANY component styling**

### Theme Token System

**Define once, use everywhere**:
- Semantic color tokens (primary, secondary, success, warning, error, neutral)
- Spacing scale (xs, sm, md, lg, xl, 2xl, etc.)
- Typography scale (headings, body, captions)
- Border radius (sm, md, lg, full)
- Shadow levels (sm, md, lg, xl)
- Z-index layers (dropdown, modal, tooltip, etc.)

**Implementation**:

**Web (Tailwind extend)**:
```javascript
// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
        primary: { DEFAULT: '#3B82F6', hover: '#2563EB' },
        secondary: { DEFAULT: '#64748B', hover: '#475569' }
        // ... all tokens
      },
      spacing: {
        xs: '0.5rem',  // 8px
        sm: '1rem',    // 16px
        md: '1.5rem',  // 24px
        // ... all tokens
      }
    }
  }
}
```

**Mobile (JavaScript tokens)**:
```javascript
// tokens.ts
export const tokens = {
  colors: {
    primary: { DEFAULT: '#3B82F6', hover: '#2563EB' },
    secondary: { DEFAULT: '#64748B', hover: '#475569' }
    // ... identical names to web
  },
  spacing: {
    xs: 8,
    sm: 16,
    md: 24,
    // ... identical names to web
  }
}

// Usage in React Native
import { tokens } from './tokens'
<View style={{ padding: tokens.spacing.md }} />
```

**Requirement**: Token names MUST be identical across platforms
**Deliverable**: Single source of truth JSON file that compiles to both formats

---

## üìã Implementation Sequence

### PHASE 1: Production UI Components (Weeks 1-4)
**Priority: HIGHEST - Build this first**
**Scope Control**: Ship data-table + form-builder FIRST, defer auth-forms and dashboard-cards

---

#### 1.1 @ssot-ui/data-table

**Acceptance Criteria**:

‚úÖ **Data Source**
- Accept resource string OR explicit fetcher conforming to SDK hook contract
- Work with `useList(resource, params)` contract
- Support custom data transformations

‚úÖ **Columns Configuration**
```
{
  key: string
  header: string
  sortable?: boolean
  filterType?: 'text' | 'enum' | 'boolean' | 'date-range' | 'number-range'
  cellRender?: (value, row) => ReactNode
}
```

‚úÖ **Search**
- Search across explicit field list provided by user
- Debounced input (300ms)
- Clear button
- Keyboard accessible

‚úÖ **Filters**
- One control per filterable column in dedicated filter panel
- Text filter: contains, equals, starts with, ends with operators
- Enum filter: multi-select dropdown with search
- Boolean filter: true/false/all toggle
- Date range filter: from/to date pickers (ISO strings)
- Number range filter: min/max inputs with between/lt/lte/gt/gte
- Active filter chips showing: "Field: Value √ó" with clear button
- "Clear all filters" action

‚úÖ **Sorting**
- Multi-column sort with stable visual "sort order" list
- Click header to toggle: none ‚Üí asc ‚Üí desc ‚Üí none
- Visual indicators: ‚Üë/‚Üì for primary, superscript ¬π¬≤¬≥ for secondary sorts
- Sort order displayed: "Sorted by: 1. createdAt ‚Üì  2. title ‚Üë  [Clear]"
- Keyboard navigation with Enter to toggle

‚úÖ **Pagination**
- Page numbers with prev/next
- Optional infinite scroll mode
- Page size selector
- Shows "X-Y of Z results"

‚úÖ **Export**
- CSV export with current filters and sort applied
- Client mode: total ‚â§ 10k rows (prevent massive downloads)
- Server mode required: total > 10k (server generates CSV via hook)
- Respects column visibility and custom formatters
- Filename format: {resource}-export-{timestamp}.csv

‚úÖ **Accessibility**
- ARIA roles: role="grid" on table, role="gridcell" on cells
- Header IDs linked to cells via headers attribute
- Roving tabindex for cell navigation
- Keyboard shortcuts: Arrow keys (navigate), Enter/Space (activate), Escape (close)
- Focus states: 2px outline on all interactive elements
- Screen reader announcements: Sort changes, filter updates, page changes
- WCAG 2.1 AA compliant (verified with axe)

‚úÖ **Performance**
- Virtualization: Auto-enable at threshold (default 1000 rows)
- SSR-safe fallback: Regular rendering on server, virtual in browser
- Memoized renders for cells and headers
- Lazy load heavy components (date pickers, rich selects)

‚úÖ **Definition of Done**
- 20+ unit tests covering all features
- Storybook with 5 examples (basic, filtered, sorted, custom cells, mocked latency)
- Works with mocked 2-second latency
- Documentation for REST/tRPC/GraphQL adapters
- Bundle size < 60kb gzipped (without virtual scroll lib)
- **DX Requirements**:
  - Console errors include problem + solution + current data structure
  - TypeScript errors are actionable with clear fix suggestions
  - Generated example code has ownership comments
  - README includes common customization patterns
  - Error messages link to relevant documentation

---

#### 1.2 @ssot-ui/form-builder

**Acceptance Criteria**:

‚úÖ **Schema Input**
- Accept Zod schema (Prisma-derived from codegen)
- Parse schema to infer field types
- Support nested schemas (sections)

‚úÖ **Field Widgets by Type**
```
String      ‚Üí Text input
Int/Float   ‚Üí Number input  
Boolean     ‚Üí Switch/Checkbox
DateTime    ‚Üí Date picker
Enum        ‚Üí Select dropdown
Relation    ‚Üí Autocomplete select (async fetch via getOptions hook)
String[]    ‚Üí Tags input or multi-select
```

**Relations handling**:
- Force explicit `getOptions` hook (no implicit includes)
- User provides: `getOptions: useUserList` for author field
- Component calls hook with search query
- Prevents N+1 queries and massive payloads
- Example: Author select fetches users on demand, not included in post data

‚úÖ **Validation**
- Integrate with zodResolver (react-hook-form)
- Show inline errors per field (from Zod schema)
- Prevent submit if client validation fails
- Async server errors: Map to specific fields via error.details
- Example: Server returns `{ code: 'VALIDATION_ERROR', details: { fields: { email: 'Already exists' } } }`
- Form displays error under email field

‚úÖ **Field Customization**
- Override widget per field
- Set labels, placeholders, help text
- Mark fields as disabled/readonly
- Conditional field visibility

‚úÖ **Layout Presets**
- 1-column (mobile default)
- 2-column (desktop)
- Sections with titles
- Custom grid layout

‚úÖ **Advanced Widgets** (Optional, Lazy Loaded)
- File picker: Pluggable adapter (S3/Cloudinary/local)
  - Don't bake storage choice into core
  - User provides upload handler
  - Component handles UI only (preview, progress, validation)
- Rich text editor: Lazy loaded, sanitizes output (XSS protection)
- Date range picker: From/to with validation
- Color picker: Hex/RGB with preview

‚úÖ **Form Submission**
- Async submit handler
- Loading state during submit
- Success/error callbacks
- Optimistic updates option

‚úÖ **Definition of Done**
- 20+ tests (field mapping, validation, submission)
- 4 Storybook stories (simple, relations, file upload, wizard)
- Documentation with adapter examples
- Works with all Prisma field types
- **DX Requirements**:
  - Validation errors show field name and user's schema field
  - Generated forms are readable (not minified/obfuscated)
  - Field widgets use conventional names from user schema
  - Error states include recovery suggestions

---

#### 1.3 @ssot-ui/crud-screens

**Acceptance Criteria**:

‚úÖ **Component Composition**
- Consumes data-table + form-builder
- Generates List/Detail/Create/Edit via props (NOT codegen)
- Composable, not monolithic

‚úÖ **Screens**
```
<ListScreen resource="post" columns={[...]} />
<DetailScreen resource="post" sections={[...]} />
<CreateScreen resource="post" fields={[...]} />
<EditScreen resource="post" fields={[...]} />
```

‚úÖ **Navigation**
- Breadcrumbs with back button
- Links between screens
- Router-agnostic (Next.js App Router default)

‚úÖ **States**
- Explicit Empty, Error, Loading components passed as props (theme globally)
- User can provide custom state components per screen
- No hidden state logic - all wiring visible
- Example: `<ListScreen emptyState={<MyEmptyState />} loadingState={<MySkeleton />} />`

‚úÖ **Definition of Done**
- 10 tests around prop wiring and navigation
- Demo page showing all four screens connected
- Documentation for Next.js integration
- Works with SDK contract hooks
- **DX Requirements**:
  - Generated screens have clear ownership comments
  - Breadcrumbs use semantic names from user schema
  - Empty states have actionable CTAs
  - Loading states show what's loading (not just spinners)

---

#### 1.X DEFERRED to Post-Template Phase

**@ssot-ui/auth-forms** - Defer until blog template needs it

**@ssot-ui/dashboard-cards** - Defer until dashboard template needs it

**Rationale**: Focus on core CRUD functionality first, add specialized components when templates require them

---

### PHASE 2: Production UI Templates (Weeks 5-8)
**Priority: HIGH - Build after core components**

#### 2.1 Template Metadata Format

**template.json structure**:
```
{
  name: string
  description: string
  version: string
  minSdkVersion: string        // Required SDK hook contract version
  tokenSet: string             // e.g., 'ssot-tokens@1'
  router: 'nextjs-app' | 'nextjs-pages' | 'expo'
  
  requiredModels: [
    {
      template: 'user'
      description: 'User/Author model'
      requiredFields: [
        { template: 'name', type: 'String', description: 'Display name' }
        { template: 'avatar', type: 'String?', description: 'Profile image' }
      ]
      optionalFields: [
        { template: 'bio', type: 'String?', description: 'User bio' }
      ]
    }
  ]
  
  featureFlags: {
    auth: boolean              // Auth integration
    comments: boolean          // Comment system
    search: boolean            // Global search
    seo: boolean               // Metadata + Open Graph
  }
  
  migrations: [
    { from: '1.0.0', to: '1.1.0', breaking: false, description: 'Added SEO support' }
  ]
  
  breakingChangePolicy: {
    requiresMajorBump: ['change field types', 'remove required fields', 'change router']
    requiresMinorBump: ['add optional fields', 'add feature flags']
  }
}
```

**Compiler validates**:
- All required models are mapped
- All required fields are mapped
- Field types match or are compatible
- Warns on type mismatches (e.g., template expects DateTime, user has String)
- Requires explicit transform if types don't match
- Produces diff view: template field ‚Üí chosen field + confidence score
- Persists validation result to `ui-mapping.md`
- Fails with actionable diff showing missing mappings

**Compiler generates**:
- Ownership comments in every file
- `ui-README.md` with customization guide
- `ui-mapping.md` with human-readable mapping report
- Inline documentation explaining generated code
- Helpful error messages with solutions

---

#### 2.2 Mapping Configuration in ssot.config.ts

**Format**:
```
uiProjects: {
  template: 'blog'
  
  schemaMappings: {
    models: {
      'user': 'User'
      'post': 'BlogPost'
      'comment': 'Comment'
    }
    
    fields: {
      'user.name': 'User.email'
      'post.title': 'BlogPost.heading'
      'post.author': 'BlogPost.writer'
      'post.author.name': 'BlogPost.writer.fullName'  // Nested!
    }
  }
}
```

**Resolver Logic**:
- Try exact match first
- Try plural/singular variations
- Check type compatibility
- Calculate confidence score (0-100)
- Suggest top 3 candidates

---

#### 2.3 CLI: `pnpm ssot ui init <template>`

**Auto-Detection**:
- Compare template.json to user's Prisma schema
- Match models by similarity (case-insensitive, plural/singular)
- Suggest fields based on type and name similarity
- Show confidence scores

**Interactive Flow**:
```
$ pnpm ssot ui init blog

‚úì Detected model mappings:
  user ‚Üí User (100% confidence)
  post ‚Üí Post (100% confidence)
  comment ‚Üí Comment (100% confidence)

‚ö† Need field mappings:
  user.name (required String)
    User has: id, email, username, firstName
    ‚Üí Suggest: email (90%) or firstName (85%)
  > email

  post.title (required String)
    Post has: id, heading, body, slug
    ‚Üí Suggest: heading (95%)
  > heading

‚úì Generated ssot.config.ts with mappings
‚úì Generated mapping.report.md
```

**Validation**:
- All required fields must be mapped
- Types must match or be compatible
- CLI prevents generation if invalid

---

#### 2.4 Blog Template (First Template)

**Template contents**:
- PostList screen with table/card views
- PostDetail screen with full post display
- PostCreate form with rich text editor
- PostEdit form pre-populated
- UserProfile screen with user info and posts
- CommentSection component with nested replies
- Navigation and routing setup
- Authentication integration
- Search functionality

**Template variables**:
- Model: user, post, comment
- User fields: name, avatar, bio
- Post fields: title, content, excerpt, published, author, createdAt
- Comment fields: content, author, post, createdAt

**Generated files include**:
- Ownership comments (template version, generation date, edit-safety)
- Inline code comments explaining purpose
- TypeScript types using user's schema names
- Conventional Next.js file structure
- Clear component/function names

**Generated documentation**:
- `ui-README.md` - Customization guide, file structure, common tasks
- `ui-mapping.md` - All schema mappings in readable format
- Inline comments explaining template decisions
- Examples of common customizations
- Troubleshooting section with solutions

**Blog template specific requirements**:

‚úÖ **SEO (if featureFlags.seo = true)**:
- Generate metadata export in each page.tsx
- Open Graph tags for social sharing
- Structured data (JSON-LD) for posts
- Sitemap generation (optional)
- Example:
  ```typescript
  export const metadata = {
    title: post.heading,
    description: post.summary,
    openGraph: {
      title: post.heading,
      description: post.summary,
      images: [post.coverImage]
    }
  }
  ```

‚úÖ **Content Security**:
- Rich text content: Sanitize HTML to prevent XSS
- Use DOMPurify or similar before rendering
- Whitelist allowed tags and attributes
- Strip script tags, event handlers
- Example: `<div dangerouslySetInnerHTML={{ __html: sanitize(post.body) }} />`

‚úÖ **Auth Integration (if featureFlags.auth = true)**:
- Auth-gated routes (create, edit, delete)
- Public routes (list, detail, read-only comments)
- Example: Comments read-only when auth is off

‚úÖ **Definition of Done**:
- Example repo deployable to Vercel (build succeeds)
- Mapping works with 2 different schemas (tested)
- SEO validation passes (metadata present, OG tags valid)
- Security audit passes (XSS tests, sanitization verified)
- Performance: Lighthouse score >90

---

#### 2.5 Additional Templates (Priority Order)

**E-commerce template**:
- Models: product, category, order, cart, user
- Screens: ProductList, ProductDetail, Cart, Checkout, OrderHistory
- Features: Product filtering, image galleries, payment integration

**CRM template**:
- Models: contact, company, deal, task, user
- Screens: ContactList, ContactDetail, KanbanBoard, ActivityFeed
- Features: Drag-and-drop, pipeline management, notes

**Dashboard template**:
- Models: metric, report, user
- Screens: Overview, Analytics, Reports, Settings
- Features: Real-time charts, KPI cards, export

---

### PHASE 3: Dynamic Admin Panel (Weeks 9-12)
**Priority: MEDIUM - Build after production templates**
**Critical Constraint**: READ-ONLY by default, write mode per model/field toggle

#### 3.1 Field Mapping Library (Hint Layer Only)

**Build pattern library**:
- Create library.json with semantic concepts
- Organize by categories (identity, display, content, temporal, status, etc.)
- Define 50-100 core field patterns with variations
- Specify confidence scores per pattern
- Include display hints (component type, priority, format)
- Document pattern matching rules

**Semantic concepts to include**:
- Identity: id, uuid, primary keys
- Display: title, name, label, heading
- Content: description, body, text, summary
- Temporal: createdAt, updatedAt, publishedAt
- Status: published, active, enabled, archived
- Contact: email, phone, address
- Media: avatar, image, photo, thumbnail
- Quantitative: views, count, rating, price
- Security: password, token, hash, secret
- Relational: author, creator, user, owner

---

#### 3.2 Field Matcher Engine

**Build matching system**:
- Implement pattern matching (exact, prefix, suffix, contains, regex)
- Support case-insensitive matching
- Calculate confidence scores
- Apply context awareness (model-specific boosts)
- Handle type validation
- Return ranked matches with reasons

**Matcher features**:
- Cache results for performance
- Support custom pattern extensions
- Allow user overrides via config
- Apply minimum confidence thresholds
- Provide fallback classifications

---

#### 3.3 User Configuration Layer

**Add fieldMappings to ssot.config.ts**:
- Support custom pattern definitions
- Allow model-specific field overrides
- Enable global field overrides
- Support ignore list for sensitive fields
- Set minimum confidence threshold

**Override priority system**:
- Model-specific overrides (highest priority)
- Global overrides
- Ignore list
- Auto-detection with custom patterns
- Confidence threshold check
- Generic fallback (lowest priority)

---

#### 3.4 Schema Analyzer

**Build analysis engine**:
- Parse Prisma schema at runtime
- Classify each field using matcher
- Determine display priorities
- Identify primary display fields
- Group fields by semantic category
- Generate model profiles with metadata

**Model profile includes**:
- All fields with classifications
- Primary field for titles
- Subtitle field
- Image field
- Date field
- Status fields
- Relations (belongs-to and has-many)

---

#### 3.5 Dynamic UI Components (Hint-Based Display Only)

**SmartTable/SmartDetail/SmartForm use hint layer for**:
- **title**: Primary display field (bold, prominent)
- **identifier**: Unique reference (link to detail)
- **primaryDate**: Most relevant timestamp
- **status**: Boolean/enum state (badge)
- **avatar**: Image/icon representation
- **subtitle**: Secondary description

**NOT used for**:
- Auto-generating write operations
- Inferring relationships
- Security decisions
- Data transformations

**Purpose**: Smart display formatting, NOT data manipulation

---

#### 3.6 Admin Panel Application

**Build main panel**:
- Dashboard with model statistics (count, recent additions)
- Sidebar with all models listed (auto-discovered from SDK or schema)
- Dynamic routing (/:model, /:model/:id)
- Use SmartTable for list views (read-only)
- Use SmartDetail for detail views (read-only)
- SmartForm ONLY if write mode enabled per model
- Include search and filter UI
- Add pagination controls
- Show loading states
- Handle errors gracefully

**Panel features**:
- Works with any Prisma schema (zero config)
- **READ-ONLY by default** (safe data browser)
- Write mode: toggle per model OR per field
- Embeddable in existing apps (route mount point)
- Standalone CLI: `pnpm ssot dev --admin`
- Clear warnings on dangerous operations
- Audit logging for write operations

**Write Mode Configuration** (v2+):
```
adminPanel: {
  writeMode: {
    enabled: true
    allowlist: ['Post', 'Comment']  // Only these models writable
    fieldAllowlist: {
      User: ['name', 'bio']  // Only these User fields writable
    }
  }
}
```

---

#### 3.7 Library Seeding System

**Build pattern discovery**:
- Analyze multiple real-world schemas
- Extract field name patterns
- Calculate occurrence frequencies
- Identify common types per field name
- Group by contexts (model types)
- Generate confidence scores

**Auto-seed workflow**:
- Collect schemas from GitHub repositories
- Analyze 100-1000 schemas
- Generate pattern suggestions
- Review and approve high-confidence patterns
- Add to library.json
- Update documentation

---

### PHASE 4: Integration & Polish (Weeks 13-16)
**Priority: HIGH - Essential finishing touches**

#### 4.1 CLI Integration

**Extend ssot CLI**:
- Add generate --ui flag for production templates
- Add dev --admin flag for admin panel
- Add ui init command for template setup
- Add ui configure command for interactive mapping
- Add ui analyze command to review mappings
- Add ui list command to show available templates

**CLI features**:
- Interactive prompts with suggestions
- Validation of mappings
- Preview before generation
- Watch mode for development
- Error messages with solutions

---

#### 4.2 Code Generation Pipeline

**Integrate with existing pipeline**:
- Add UIGenerationPhase to pipeline
- Generate UI based on uiProjects config
- Place files in generated/ui/ directory
- Respect user's chosen template
- Apply schema mappings correctly
- Generate navigation/routing
- Generate theme/styling

**Generated structure**:
- screens/ directory with all pages
- components/ directory with reusable pieces
- navigation/ with routing setup
- theme/ with styling configuration
- README with usage instructions

---

#### 4.3 Documentation & Error Messages

**Create comprehensive docs**:

**For production templates**:
- Getting started guide
- Available templates list
- Configuration reference
- Schema mapping guide
- Customization examples
- Troubleshooting section

**For admin panel**:
- Installation guide
- Configuration options
- Field mapping reference
- Security best practices
- Embedding instructions

**For component packages**:
- API documentation per package
- Usage examples
- Customization guide
- TypeScript types reference
- Storybook stories

**Error message standards**:

All errors must include:
1. **What happened**: Clear problem statement
2. **Why it happened**: Root cause explanation
3. **How to fix**: Actionable solution
4. **Current state**: Show relevant data/context
5. **Documentation link**: URL to detailed docs

**Example console error**:
```
‚ö†Ô∏è @ssot-ui/data-table: Field 'writer.email' returned undefined

Problem:
  The field 'writer.email' is not present in the data

Why:
  The relation 'writer' was not included in the query
  
How to fix:
  Add the relation to your query hook:
  
  useBlogPostList({ 
    include: { writer: true } 
  })

Current data structure:
  { id, heading, body, writerId, createdAt }
  
üìñ Docs: https://ssot-codegen.dev/ui/troubleshooting#missing-relation-data
```

**TypeScript error guidance**:
```typescript
// If user uses wrong field name:
columns={[
  { key: 'title' }  // TS Error
  //     ^^^^^^^ 
  // Property 'title' does not exist on type 'BlogPost'
  // 
  // üí° Did you mean 'heading'?
  //    Check your mapping: ui-mapping.md
]}
```

---

#### 4.4 Testing

**Unit tests**:
- Test each component package independently
- Test template compiler logic
- Test mapping resolver with various scenarios
- Test field matcher with edge cases
- Test schema analyzer

**Integration tests**:
- Test full template generation end-to-end
- Test admin panel with various schemas
- Test all component packages together
- Test CLI commands

**E2E tests**:
- Generate actual projects
- Verify file structure
- Check generated code validity
- Test with different schema configurations
- Validate mappings work correctly

---

#### 4.5 Examples & Demos

**Create example projects**:
- Blog example with full configuration
- E-commerce example
- CRM example
- Dashboard example
- Admin panel demo

**Each example includes**:
- Complete Prisma schema
- ssot.config.ts with mappings
- Generated UI code
- Deployment instructions
- Live demo link

---

## üîß Gaps to Fill (Close Before Implementation)

### Sort/Filter Wire Format Serialization

**Define canonical format** for all adapters:

**Sort** (client ‚Üí server):
```json
{
  "sort": [
    { "field": "createdAt", "dir": "desc" },
    { "field": "title", "dir": "asc" }
  ]
}
```

**Filter** (client ‚Üí server):
```json
{
  "filters": [
    { "field": "published", "op": "eq", "value": true },
    { "field": "views", "op": "gte", "value": 100 }
  ]
}
```

**Adapters** (REST/tRPC/GraphQL):
- Must translate this format to backend query language
- Contract tests ensure all adapters handle all operators
- Document adapter implementation guide

---

### Date/Time Handling

**Rule**: Always ISO strings on wire, local display in UI

**Server**:
- Stores in UTC
- Returns ISO strings: `"2025-01-15T10:30:00.000Z"`

**Client**:
- Receives ISO strings
- Displays in user's local timezone
- Sends ISO strings for mutations

**Display helpers**:
```typescript
formatDate(isoString)     ‚Üí "Jan 15, 2025"
formatDateTime(isoString) ‚Üí "Jan 15, 2025 10:30 AM"
formatRelative(isoString) ‚Üí "2 hours ago"
```

**Date pickers**:
- User selects in local timezone
- Converts to UTC ISO string before sending
- Server receives UTC

---

### i18n Strategy

**Components accept messages dictionary**:
```typescript
<DataTable
  messages={{
    search: 'Buscar...',
    noResults: 'No se encontraron resultados',
    loading: 'Cargando...'
  }}
/>
```

**Templates ship with**:
- English (en) only by default
- Messages object structure documented
- Users provide translations for other languages

**NOT included**:
- Auto-translation
- Multiple language bundles
- Language detection

**Keep it simple**: Dict prop, users own translations

---

### Accessibility Bar (WCAG 2.1 AA)

**Checklist in each package README**:
- [ ] Keyboard navigation (all interactive elements reachable)
- [ ] Focus indicators (visible 2px outline, 3:1 contrast ratio)
- [ ] ARIA labels (all controls labeled, roles assigned)
- [ ] Color contrast (4.5:1 for text, 3:1 for large text)
- [ ] Screen reader support (meaningful announcements)
- [ ] Skip links (bypass navigation)
- [ ] No keyboard traps (can escape all modals/dropdowns)
- [ ] Form labels (explicit or aria-label)
- [ ] Error messages (associated with fields via aria-describedby)

**Verification**:
- Axe CI check on all Storybook stories
- Manual keyboard-only testing
- Screen reader testing (NVDA/JAWS)

---

## üîê Security Checklist for Templates

### CSRF Protection
**Guidance in template README**:
- Use framework's built-in CSRF tokens (Next.js, Expo)
- Include CSRF token in all mutation requests
- Validate tokens on server
- Example: Next.js Server Actions have built-in protection

### Auth Boundaries
**Generated code**:
- Clear separation between public and protected routes
- Auth middleware at layout level
- Redirect to login if unauthorized
- Example: `/posts/new` requires auth, `/posts/[id]` is public

### XSS in Rich Text Editor
**Template code**:
- Always sanitize rich text content before rendering
- Use DOMPurify with strict whitelist
- Strip script tags, event handlers, data URIs
- Example provided in generated component

### File Upload Validation
**Template code**:
- Validate file type (both client and server)
- Validate file size (prevent DoS)
- Scan for malware (if using cloud storage)
- Generate safe filenames (prevent path traversal)
- Example:
  ```typescript
  const allowedTypes = ['image/jpeg', 'image/png']
  const maxSize = 5 * 1024 * 1024 // 5MB
  
  if (!allowedTypes.includes(file.type)) {
    throw new Error('Invalid file type')
  }
  ```

### Rate Limiting Hints
**Template README includes**:
- Recommend rate limiting on create/update/delete routes
- Example: 10 requests per minute per IP
- Suggest using Vercel rate limiting or custom middleware
- Not enforced by template (user's responsibility)

### SQL Injection (via SDK)
**Not a concern**:
- SDK uses Prisma (parameterized queries)
- Filter operators are whitelisted
- No raw SQL in generated code
- Document: "Safe by default via Prisma"

---

## ‚ö†Ô∏è Risk Hotspots & Mitigations

### Risk 1: SDK Contract Mismatch
**Hotspot**: Components expect exact hook shapes, backend changes break UI

**Mitigation**:
- Freeze SDK hook contract before any component work
- Version the contract: `@ssot-sdk-contract@1.0.0`
- Add adapter contract tests with mock server
- Breaking changes require major version bump
- Adapters translate to REST/GraphQL/tRPC (shield components from backend changes)

**Test**:
```typescript
describe('REST Adapter Contract', () => {
  it('useList returns correct shape', async () => {
    const result = await adapter.list('post', { page: 1, pageSize: 20 })
    expect(result).toMatchObject({
      items: expect.any(Array),
      total: expect.any(Number)
    })
  })
})
```

---

### Risk 2: Bundle Size Bloat
**Hotspot**: Rich text editors, charts, date pickers are heavy

**Mitigation**:
- Lazy load all heavy dependencies
- Example: `const RichTextEditor = lazy(() => import('./RichTextEditor'))`
- Tree-shakeable exports (import only what you use)
- Bundlesize bot on every PR (fails if >60kb gzipped)
- Monitor with `@next/bundle-analyzer`

**Thresholds**:
- @ssot-ui/data-table: <60kb gzipped
- @ssot-ui/form-builder: <80kb gzipped (includes react-hook-form)
- Rich text plugin: Lazy loaded, not counted in core bundle

---

### Risk 3: Regeneration Conflicts
**Hotspot**: User edits generated file, regeneration overwrites changes

**Mitigation Strategy 1** (Safe Blocks + Prompt):
```typescript
// ===== GENERATED CODE START - DO NOT EDIT =====
const columns = [
  { key: 'title', header: 'Title' }
]
// ===== GENERATED CODE END =====

// ‚ú® YOUR CUSTOMIZATIONS - Safe to edit
const customColumns = [
  ...columns,
  { key: 'custom', header: 'Custom', cellRender: myRender }
]
```

**Mitigation Strategy 2** (Prompt Before Overwrite):
```bash
$ pnpm ssot generate --ui

‚ö†Ô∏è Detected changes in generated files:
  - app/(dashboard)/posts/page.tsx (modified 2 days ago)
  
Options:
  1) Keep your changes (skip regeneration)
  2) View diff
  3) Overwrite with new code
  4) Three-way merge
> 1

‚úì Skipped modified files
‚úì Regenerated unchanged files
```

**Decision**: Use Strategy 2 (prompt) as default. Safe blocks if user opts in.

**Never**: Silently overwrite user changes

---

### Risk 4: Template Doesn't Match User's Domain
**Hotspot**: Blog template used for e-commerce, weird results

**Mitigation**:
- Template selection wizard with domain matching
- Clear template descriptions and use cases
- Show required models before selection
- Suggest closest template based on schema
- Allow hybrid: "Start with blog, customize for your domain"

---

## ‚úÖ Phase Exit Criteria

### Phase 1 Exit: Components Ready
**Must achieve ALL**:
- [ ] data-table package published to npm
- [ ] form-builder package published to npm
- [ ] crud-screens package published to npm
- [ ] Each has 20+ tests passing
- [ ] Each has Storybook with examples
- [ ] Each has complete README
- [ ] Bundle size <60kb verified
- [ ] Accessibility audit passes (axe)
- [ ] Example "first render" time <5 minutes
- [ ] SDK contract locked and documented
- [ ] Theme tokens v1 published

**Gate**: Cannot start Phase 2 until ALL checkboxes complete

---

### Phase 2 Exit: Blog Template Works
**Must achieve ALL**:
- [ ] Blog template available via CLI
- [ ] Interactive `pnpm ssot ui init blog` works
- [ ] Auto-detection suggests ‚â•90% of fields correctly
- [ ] Compiler validates mappings with actionable errors
- [ ] Generated code compiles without TypeScript errors
- [ ] Two different schemas successfully generate working apps
- [ ] Example app deploys to Vercel in <5 minutes
- [ ] ui-README.md and ui-mapping.md generated
- [ ] SEO metadata generated correctly
- [ ] Content sanitization prevents XSS
- [ ] Lighthouse score >90 on example

**Test schemas**:
1. Standard blog (Post, User, Comment with expected field names)
2. Custom blog (BlogPost, Author, Reply with different field names)

**Gate**: Cannot start Phase 3 until blog template proven with diverse schemas

---

### Phase 3 Exit: Admin Panel Works
**Must achieve ALL**:
- [ ] Admin panel lists 100% of models from any schema
- [ ] Zero crashes with unknown field types
- [ ] Field mapper achieves 80% hint accuracy (manual review of 100 schemas)
- [ ] Read-only mode works perfectly
- [ ] Write mode disabled by default
- [ ] CLI `pnpm ssot dev --admin` launches successfully
- [ ] Renders 1000 items in <2 seconds with virtualization
- [ ] Dangerous operations show clear warnings
- [ ] Embeddable in existing Next.js app
- [ ] Security fields (passwords, tokens) hidden automatically

**Gate**: Admin panel must be safe and functional before v1 release

---

### Final Release Gate
**Must achieve ALL**:
- [ ] All phase exit criteria met
- [ ] Full documentation published
- [ ] Security audit completed
- [ ] Performance benchmarks met
- [ ] All tests passing (200+ total)
- [ ] CI/CD pipeline configured
- [ ] Example projects deployed
- [ ] Beta users provide positive feedback
- [ ] No critical bugs open
- [ ] Licensing clear
- [ ] Attribution documented

---

## üîì Telemetry (Opt-In)

**Anonymous usage counters** to catch performance regressions:

**Collected** (if user opts in):
- Component usage frequency (which components used)
- Render timings (95th percentile)
- Bundle sizes after build
- Error rates (crashes, validation failures)

**NOT collected**:
- User data or schema structure
- Field names or values
- IP addresses or identifiers

**Implementation**:
- Opt-in during `ssot ui init`
- Can disable anytime in config
- Open source the telemetry code
- Aggregate data published quarterly

---

## üìú Licensing & Attribution

**Template license**:
- MIT license on all templates
- Users can modify and redistribute
- Attribution appreciated but not required

**Component packages**:
- MIT license
- Free for commercial use
- No restrictions

**Clarify**:
- Generated code belongs to user
- No usage restrictions
- No telemetry without opt-in
- Open source friendly

---

## üéØ Key Decisions Summary

### What We're Building:

**PATH 1: Dynamic Admin Panel**
- Purpose: Dev tool for exploring any schema
- Technology: Field mapper with smart detection
- Configuration: Zero config with optional overrides
- Use case: Development, internal admin panels

**PATH 2: Production UI Templates**
- Purpose: Real production applications
- Technology: Pre-built templates with schema mapping
- Configuration: Explicit mapping required
- Use case: Production apps, client projects

### What We're NOT Building:
- Universal AI-powered UI generator
- One-size-fits-all solution
- Automatic production-ready code without config

### Build Order:
1. Production component packages (immediate value)
2. Production templates with mapping (most requested)
3. Dynamic admin panel (nice-to-have dev tool)

### Field Mapper Usage:
- Only used in dynamic admin panel
- Not used in production templates
- Optional user overrides available

### Schema Mapping Usage:
- Only used in production templates
- Explicit configuration required
- Interactive CLI helper available

---

## üìä Success Metrics

### Phase 1 Success:
- Five component packages published
- Each package has 20+ tests
- Documentation complete
- Storybook stories created
- First user feedback received

### Phase 2 Success:
- Three templates available (blog, ecommerce, CRM)
- Interactive CLI working
- Schema mapping 90% auto-detected
- User can generate working app in under 10 minutes
- Example projects deployed

### Phase 3 Success:
- Admin panel works with any schema
- Field mapper 80%+ accuracy
- Zero config required for basic usage
- User overrides working
- Standalone mode available

### Phase 4 Success:
- Full documentation published
- All tests passing
- CI/CD pipeline configured
- First production deployments
- Community feedback positive

---

## üöÄ Immediate Next Step

**Start with @ssot-ui/data-table package**

Why this first:
- Most requested feature
- Clear, bounded scope
- No dependencies on other systems
- Can be used standalone
- Quick win for users
- Foundation for other components

Tasks for data-table:
1. Create package structure
2. Define TypeScript interfaces
3. Implement core table component
4. Add search functionality
5. Add filter functionality
6. Add sort functionality
7. Add pagination
8. Add responsive design
9. Write documentation
10. Create examples
11. Write tests
12. Publish to npm

Estimated: 1 week for MVP, 2 weeks for polish

---

## üí° Critical Requirements

### For All Components:
- TypeScript with strict mode
- Full type safety
- Comprehensive documentation
- Unit test coverage >80%
- Accessibility compliant (WCAG 2.1 AA)
- Mobile responsive
- Dark mode support
- Customizable styling
- Zero breaking changes after 1.0

### For Templates:
- Production-ready code quality
- Best practices followed
- Security considered
- Performance optimized
- SEO friendly
- Documented customization
- Example configurations

### For Admin Panel:
- Works with any valid Prisma schema
- Secure by default (hide passwords, tokens)
- Fast with large datasets
- Clear error messages
- Helpful defaults
- Easy to embed

---

## üéØ End Goal

Users can:

**For Production Apps**:
- Choose a template (blog, ecommerce, CRM)
- Configure schema mappings
- Generate production-ready UI
- Customize as needed
- Deploy to production
- Time saved: Days to hours

**For Development**:
- Start dev server with --admin flag
- Get instant CRUD for all models
- Explore data visually
- Test relationships
- Debug schema issues
- Time saved: Build admin panel (weeks to minutes)

**Result**: Complete full-stack from Prisma schema to production app with both backend API and frontend UI.

---

## üìà KPIs to Track

### Phase 1: Component Quality

**Time to First Data Table Rendering**
- Target: < 5 minutes from npm install to working table
- Measure: Time from `npm i @ssot-ui/data-table` to rendering data

**Bundle Size**
- Target: < 60kb gzipped per package (without charts)
- Measure: Bundlesize bot on each PR
- Monitor: Tree-shaking effectiveness

**Accessibility Compliance**
- Target: 100% pass rate on axe audits
- Measure: Run axe on all Storybook examples
- Check: Keyboard navigation, screen reader, ARIA

**Test Coverage**
- Target: > 80% line coverage per package
- Measure: Vitest coverage reports
- Focus: User interactions, edge cases, error states

---

### Phase 2: Template Mapping Success

**Auto-Detection Accuracy**
- Target: ‚â• 90% of required fields successfully suggested
- Measure: CLI auto-detection confidence scores
- Track: Percent of fields matched without user input

**Template Generation Time**
- Target: < 10 minutes from init to working app
- Measure: `pnpm ssot ui init` to `npm run dev` succeeds
- Include: Mapping config + code generation + install

**Mapping Validation Success**
- Target: 100% catch rate for invalid mappings
- Measure: Compiler validates all mappings before generation
- Zero: Runtime errors due to missing mappings

**Template Deployability**
- Target: Example projects deploy to Vercel/Netlify in < 5 min
- Measure: CI/CD pipeline duration
- Check: Build succeeds, no TypeScript errors

---

### Phase 3: Admin Panel Discovery

**Model Discovery Success**
- Target: 100% of Prisma models listed in admin panel
- Measure: Zero crashes with unknown field types
- Validate: Works with any valid Prisma schema

**Field Mapper Accuracy**
- Target: 80% of fields correctly classified with hints
- Measure: Manual review of 100 diverse schemas
- Accept: Lower accuracy OK since it's read-only hints

**Admin Panel Performance**
- Target: < 2 seconds to render list of 1000 records
- Measure: Virtual scrolling kicks in at threshold
- Check: No UI freezing during data load

**Zero Configuration Success**
- Target: Admin panel works immediately with zero config
- Measure: `pnpm ssot dev --admin` succeeds out of box
- Validate: All models browsable without setup

---

### Cross-Cutting Metrics

**Developer Experience**
- SDK contract conformance: 100% (locked)
- TypeScript errors in generated code: 0
- Documentation completeness: All APIs documented
- Storybook example coverage: 5+ examples per component
- Generated code readability: Passes manual review (looks hand-written)
- Ownership comments: 100% of generated files
- Error helpfulness: All errors include solution + docs link
- Time to first customization: < 5 minutes from generation
- Regeneration safety: 100% preserve user changes (with prompt)

**Performance Benchmarks**
- Initial load (FCP): < 1.5s
- Time to Interactive (TTI): < 3s
- Lighthouse score: > 90 (performance, accessibility, best practices)

**Community Feedback**
- GitHub stars/week growth
- npm downloads/week growth
- Issue close rate: > 80% within 7 days
- User survey satisfaction: > 4.5/5

---

This is the complete, consolidated, sequential plan for UI generation.


