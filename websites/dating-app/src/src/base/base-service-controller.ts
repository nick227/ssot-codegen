// @generated
// This file is automatically generated. Do not edit manually.

import type { Request, Response } from 'express'
import { ZodError, type ZodSchema } from 'zod'
import { logger } from '@/logger'

// AuthRequest type - defined locally to avoid dependency on auth plugin
// If @/auth/jwt exists, it will export AuthRequest with user property
type AuthRequest = Request & {
  user?: {
    userId?: number | string
    [key: string]: unknown
  }
}

/**
 * Configuration for service controller
 */
export interface ServiceControllerConfig {
  serviceName: string
}

/**
 * Options for wrapping a service method
 */
export interface WrapOptions<T = unknown> {
  schema?: ZodSchema<T>
  statusCode?: number
  extractParams?: (req: Request) => unknown[]
  requireAuth?: boolean
}

/**
 * Base Service Controller
 * 
 * Eliminates 90-96% of boilerplate from service integration controllers
 * by providing common functionality: auth checking, validation, error handling, logging.
 * 
 * @example
 * ```typescript
 * const controller = new BaseServiceController({ serviceName: 'ai-agent' })
 * 
 * export const sendMessage = controller.wrap(
 *   'sendMessage',
 *   aiAgentService.sendMessage
 * )
 * ```
 */
export class BaseServiceController {
  constructor(private config: ServiceControllerConfig) {}

  /**
   * Wrap a service method with standard auth, validation, and error handling
   * 
   * @param methodName - Name of the service method
   * @param serviceFn - Service function to call (receives userId as first param)
   * @param options - Additional options (schema, statusCode, etc.)
   */
  wrap<T>(
    methodName: string,
    serviceFn: (userId: number | string, ...args: unknown[]) => Promise<T>,
    options: WrapOptions = {}
  ) {
    const requireAuth = options.requireAuth !== false  // Default: true
    
    return async (req: AuthRequest | Request, res: Response): Promise<Response | void> => {
      try {
        // 1. Extract and validate user ID (if auth required)
        let userId: number | string | undefined
        
        if (requireAuth) {
          userId = (req as AuthRequest).user?.userId
          if (!userId) {
            logger.warn({ method: methodName }, 'Authentication required')
            return res.status(401).json({ error: 'Authentication required' })
          }
        }
        
        // 2. Parse and validate request data
        let data = req.body
        if (options.schema) {
          try {
            data = options.schema.parse(req.body)
          } catch (error) {
            if (error instanceof ZodError) {
              logger.warn(
                { error: error.errors, method: methodName },
                `Validation error in ${methodName}`
              )
              return res.status(400).json({
                error: 'Validation Error',
                details: error.errors
              })
            }
            throw error
          }
        }
        
        // 3. Extract additional parameters
        const params = options.extractParams
          ? options.extractParams(req)
          : [data]
        
        // 4. Call service method
        const result = await serviceFn(userId!, ...params)
        
        // 5. Log success
        logger.info(
          { userId, method: methodName, service: this.config.serviceName },
          `Service method ${methodName} executed successfully`
        )
        
        // 6. Return response
        const statusCode = options.statusCode || 201
        return res.status(statusCode).json(result)
      } catch (error: unknown) {
        return this.handleServiceError(error, methodName, req as AuthRequest, res)
      }
    }
  }

  /**
   * Handle service errors with consistent error responses
   */
  private handleServiceError(
    error: unknown,
    methodName: string,
    req: AuthRequest,
    res: Response
  ): Response {
    // Validation errors (should be caught earlier, but defensive)
    if (error instanceof ZodError) {
      logger.warn(
        { error: error.errors, method: methodName },
        `Validation error in ${methodName}`
      )
      return res.status(400).json({
        error: 'Validation Error',
        details: error.errors
      })
    }
    
    // Authorization/Forbidden errors
    const errorMessage = error instanceof Error ? error.message : String(error)
    if (
      errorMessage.includes('Unauthorized') ||
      errorMessage.includes('Forbidden') ||
      errorMessage.includes('unauthorized') ||
      errorMessage.includes('forbidden')
    ) {
      logger.warn(
        { error: errorMessage, userId: req.user?.userId, method: methodName },
        `Authorization error in ${methodName}`
      )
      return res.status(403).json({ error: errorMessage })
    }
    
    // Not found errors
    if (
      errorMessage.includes('not found') ||
      errorMessage.includes('Not found') ||
      errorMessage.includes('NOT FOUND')
    ) {
      logger.warn(
        { error: errorMessage, method: methodName },
        `Resource not found in ${methodName}`
      )
      return res.status(404).json({ error: errorMessage })
    }
    
    // Generic server errors
    logger.error(
      { error, userId: req.user?.userId, method: methodName, service: this.config.serviceName },
      `Error in ${methodName}`
    )
    
    const finalErrorMessage = error instanceof Error ? error.message : 'Unknown error'
    return res.status(500).json({
      error: 'Internal Server Error',
      message: process.env.NODE_ENV === 'development' ? finalErrorMessage : undefined
    })
  }
  
  /**
   * Create a public (non-authenticated) service method wrapper
   * 
   * @example
   * ```typescript
   * export const initiateLogin = controller.wrapPublic(
   *   'initiateLogin',
   *   googleAuthService.initiateLogin
   * )
   * ```
   */
  wrapPublic<T>(
    methodName: string,
    serviceFn: (...args: unknown[]) => Promise<T>,
    options: Omit<WrapOptions, 'requireAuth'> = {}
  ) {
    return async (req: Request, res: Response): Promise<Response | void> => {
      try {
        // 1. Parse and validate request data
        let data = req.body
        if (options.schema) {
          try {
            data = options.schema.parse(req.body)
          } catch (error) {
            if (error instanceof ZodError) {
              logger.warn(
                { error: error.errors, method: methodName },
                `Validation error in ${methodName}`
              )
              return res.status(400).json({
                error: 'Validation Error',
                details: error.errors
              })
            }
            throw error
          }
        }
        
        // 2. Extract parameters
        const params = options.extractParams
          ? options.extractParams(req)
          : [data]
        
        // 3. Call service method
        const result = await serviceFn(...params)
        
        // 4. Log success
        logger.info(
          { method: methodName, service: this.config.serviceName },
          `Public service method ${methodName} executed successfully`
        )
        
        // 5. Return response
        const statusCode = options.statusCode || 201
        return res.status(statusCode).json(result)
      } catch (error: unknown) {
        return this.handleServiceError(error, methodName, {} as AuthRequest, res)
      }
    }
  }
}
