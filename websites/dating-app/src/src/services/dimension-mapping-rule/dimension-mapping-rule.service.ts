// @generated
// This file is automatically generated. Do not edit manually.

import prisma from '@/db'
import type { DimensionMappingRuleCreateDTO, DimensionMappingRuleUpdateDTO, DimensionMappingRuleQueryDTO } from '@/contracts/dimension-mapping-rule'
import type { Prisma } from '@prisma/client'
import { TargetType } from '@prisma/client'
import { logger } from '@/logger'

export const dimensionMappingRuleService = {
  /**
   * List DimensionMappingRule records with pagination and relationships
   */
  async list(query: DimensionMappingRuleQueryDTO) {
    const { skip = 0, take = 20, orderBy, where } = query
    
    logger.debug({ skip, take }, 'Listing DimensionMappingRule records')
    
    const whereWithSoftDelete = where
    
    const [items, total] = await Promise.all([
      prisma.dimensionMappingRule.findMany({
        skip,
        take,
        orderBy: orderBy as Prisma.DimensionMappingRuleOrderByWithRelationInput,
        where: whereWithSoftDelete as Prisma.DimensionMappingRuleWhereInput,
      include: {
        dimension: {
          select: { id: true, name: true }
        }
      }
      }),
      prisma.dimensionMappingRule.count({
        where: whereWithSoftDelete as Prisma.DimensionMappingRuleWhereInput,
      })
    ])
    
    return {
      data: items,
      meta: {
        total,
        skip,
        take,
        hasMore: skip + take < total
      }
    }
  },
  
  /**
   * Find DimensionMappingRule by ID with relationships
   */
  async findById(id: string) {
    return prisma.dimensionMappingRule.findUnique({
      where: { id },
      include: {
        dimension: {
          select: { id: true, name: true }
        }
      }
    })
  },
  
  /**
   * Create DimensionMappingRule
   */
  async create(data: Prisma.DimensionMappingRuleCreateInput) {
    const item = await prisma.dimensionMappingRule.create({
      data,
      include: {
        dimension: {
          select: { id: true, name: true }
        }
      }
    })
    logger.info({ dimensionMappingRuleId: item.id }, 'DimensionMappingRule created')
    return item
  },
  
  /**
   * Update DimensionMappingRule
   */
  async update(id: string, data: DimensionMappingRuleUpdateDTO) {
    const item = await prisma.dimensionMappingRule.update({
      where: { id },
      data: data as Prisma.DimensionMappingRuleUpdateInput,
      include: {
        dimension: {
          select: { id: true, name: true }
        }
      }
    })
    logger.info({ dimensionMappingRuleId: id }, 'DimensionMappingRule updated')
    return item
  },
  
  /**
   * Delete DimensionMappingRule
   */
  async delete(id: string) {
    await prisma.dimensionMappingRule.delete({
      where: { id }
    })
    logger.info({ dimensionMappingRuleId: id }, 'DimensionMappingRule deleted')
    return true
  },
  
  /**
   * Count DimensionMappingRule records
   */
  async count(where?: Prisma.DimensionMappingRuleWhereInput) {
    return prisma.dimensionMappingRule.count({ where })
  },
  
  /**
   * Check if DimensionMappingRule exists
   */
  async exists(id: string) {
    const count = await prisma.dimensionMappingRule.count({
      where: { id }
    })
    return count > 0
  },
  
  /**
   * Create multiple DimensionMappingRule records (bulk operation)
   */
  async createMany(data: Prisma.DimensionMappingRuleCreateManyInput[]) {
    const result = await prisma.dimensionMappingRule.createMany({
      data,
      skipDuplicates: true
    })
    logger.info({ count: result.count }, 'DimensionMappingRule bulk created')
    return result
  },
  
  /**
   * Update multiple DimensionMappingRule records (bulk operation)
   */
  async updateMany(where: Prisma.DimensionMappingRuleWhereInput, data: Prisma.DimensionMappingRuleUpdateManyMutationInput) {
    const result = await prisma.dimensionMappingRule.updateMany({
      where,
      data
    })
    logger.info({ count: result.count }, 'DimensionMappingRule bulk updated')
    return result
  },
  
  /**
   * Delete multiple DimensionMappingRule records (bulk operation)
   */
  async deleteMany(where: Prisma.DimensionMappingRuleWhereInput) {
    const result = await prisma.dimensionMappingRule.deleteMany({ where })
    logger.info({ count: result.count }, 'DimensionMappingRule bulk deleted')
    return result
  },

  /**
   * Search DimensionMappingRules with text query and filters
   * Auto-generated from searchable fields: eventType, metaKey, metaValue, version, matchType
   */
  async search(params: {
    q: string
    eventType?: string
    targetType?: TargetType
    metaKey?: string
    metaValue?: string
    minWeight?: number
    maxWeight?: number
    isActive?: boolean
    version?: string
    matchType?: string
    minCreatedAt?: Date | string
    maxCreatedAt?: Date | string
    skip?: number
    take?: number
  }) {
    const where: Prisma.DimensionMappingRuleWhereInput = {
      AND: [
        params.q ? {
          OR: [
            { eventType: { contains: params.q } },
            { metaKey: { contains: params.q } },
            { metaValue: { contains: params.q } },
            { version: { contains: params.q } },
            { matchType: { contains: params.q } }
          ]
        } : {},
        params.eventType ? { eventType: params.eventType } : {},
        params.targetType ? { targetType: params.targetType } : {},
        params.metaKey ? { metaKey: params.metaKey } : {},
        params.metaValue ? { metaValue: params.metaValue } : {},
        params.minWeight ? { weight: { gte: params.minWeight } } : {},
        params.maxWeight ? { weight: { lte: params.maxWeight } } : {},
        params.isActive !== undefined ? { isActive: params.isActive } : {},
        params.version ? { version: params.version } : {},
        params.matchType ? { matchType: params.matchType } : {},
        params.minCreatedAt ? { createdAt: { gte: params.minCreatedAt } } : {},
        params.maxCreatedAt ? { createdAt: { lte: params.maxCreatedAt } } : {}
      ].filter(condition => Object.keys(condition).length > 0)
    }
    
    return prisma.dimensionMappingRule.findMany({
      where,
      skip: params.skip || 0,
      take: Math.min(params.take || 20, 100)
    })
  },

  /**
   * Get active DimensionMappingRules
   * Auto-generated from 'isActive' field detection
   */
  async getActive(query?: Prisma.DimensionMappingRuleWhereInput) {
    return prisma.dimensionMappingRule.findMany({
      where: {
        isActive: true,
        ...query
      }
    })
  },

  /**
   * Get DimensionMappingRules by DimensionMappingRuleToPersonalityDimension
   * Auto-generated from foreign key detection: dimensionId
   */
  async getByDimensionMappingRuleToPersonalityDimension(dimensionId: string, options?: {
    skip?: number
    take?: number
  }) {
    return prisma.dimensionMappingRule.findMany({
      where: { dimensionId,
        isActive: true },
      skip: options?.skip || 0,
      take: options?.take || 20
    })
  }
}
