// @generated
// This file is automatically generated. Do not edit manually.

import prisma from '@/db'
import type { BehaviorEventArchiveCreateDTO, BehaviorEventArchiveUpdateDTO, BehaviorEventArchiveQueryDTO } from '@/contracts/behavior-event-archive'
import type { Prisma } from '@prisma/client'
import { EventType, TargetType } from '@prisma/client'
import { logger } from '@/logger'

export const behaviorEventArchiveService = {
  /**
   * List BehaviorEventArchive records with pagination
   */
  async list(query: BehaviorEventArchiveQueryDTO) {
    const { skip = 0, take = 20, orderBy, where, include, select } = query
    
    logger.debug({ skip, take }, 'Listing BehaviorEventArchive records')
    
    const whereWithSoftDelete = where
    
    const [items, total] = await Promise.all([
      prisma.behaviorEventArchive.findMany({
        skip,
        take,
        ...(orderBy && { orderBy: orderBy as Prisma.BehaviorEventArchiveOrderByWithRelationInput }),
        ...(whereWithSoftDelete && { where: whereWithSoftDelete as Prisma.BehaviorEventArchiveWhereInput }),
        ...(include && { include: include as Prisma.BehaviorEventArchiveInclude }),
        ...(select && { select: select as Prisma.BehaviorEventArchiveSelect })
      }),
      prisma.behaviorEventArchive.count({
        where: whereWithSoftDelete as Prisma.BehaviorEventArchiveWhereInput,
      })
    ])
    
    return {
      data: items,
      meta: {
        total,
        skip,
        take,
        hasMore: skip + take < total
      }
    }
  },
  
  /**
   * Find BehaviorEventArchive by ID
   */
  async findById(id: string) {
    return prisma.behaviorEventArchive.findUnique({
      where: { id }
    })
  },
  
  /**
   * Create BehaviorEventArchive
   */
  async create(data: Prisma.BehaviorEventArchiveCreateInput) {
    const item = await prisma.behaviorEventArchive.create({
      data
    })
    logger.info({ behaviorEventArchiveId: item.id }, 'BehaviorEventArchive created')
    return item
  },
  
  /**
   * Update BehaviorEventArchive
   */
  async update(id: string, data: BehaviorEventArchiveUpdateDTO) {
    const item = await prisma.behaviorEventArchive.update({
      where: { id },
      data: data as Prisma.BehaviorEventArchiveUpdateInput
    })
    logger.info({ behaviorEventArchiveId: id }, 'BehaviorEventArchive updated')
    return item
  },
  
  /**
   * Delete BehaviorEventArchive
   */
  async delete(id: string) {
    await prisma.behaviorEventArchive.delete({
      where: { id }
    })
    logger.info({ behaviorEventArchiveId: id }, 'BehaviorEventArchive deleted')
    return true
  },
  
  /**
   * Count BehaviorEventArchive records
   */
  async count(where?: Prisma.BehaviorEventArchiveWhereInput) {
    return prisma.behaviorEventArchive.count({ where })
  },
  
  /**
   * Check if BehaviorEventArchive exists
   */
  async exists(id: string) {
    const count = await prisma.behaviorEventArchive.count({
      where: { id }
    })
    return count > 0
  },
  
  /**
   * Create multiple BehaviorEventArchive records (bulk operation)
   */
  async createMany(data: Prisma.BehaviorEventArchiveCreateManyInput[]) {
    const result = await prisma.behaviorEventArchive.createMany({
      data,
      skipDuplicates: true
    })
    logger.info({ count: result.count }, 'BehaviorEventArchive bulk created')
    return result
  },
  
  /**
   * Update multiple BehaviorEventArchive records (bulk operation)
   */
  async updateMany(where: Prisma.BehaviorEventArchiveWhereInput, data: Prisma.BehaviorEventArchiveUpdateManyMutationInput) {
    const result = await prisma.behaviorEventArchive.updateMany({
      where,
      data
    })
    logger.info({ count: result.count }, 'BehaviorEventArchive bulk updated')
    return result
  },
  
  /**
   * Delete multiple BehaviorEventArchive records (bulk operation)
   */
  async deleteMany(where: Prisma.BehaviorEventArchiveWhereInput) {
    const result = await prisma.behaviorEventArchive.deleteMany({ where })
    logger.info({ count: result.count }, 'BehaviorEventArchive bulk deleted')
    return result
  },

  /**
   * Search BehaviorEventArchives with text query and filters
   * Auto-generated from searchable fields: userId, targetId, ruleVersion
   */
  async search(params: {
    q: string
    userId?: string
    eventType?: EventType
    targetType?: TargetType
    targetId?: string
    minProcessedAt?: Date | string
    maxProcessedAt?: Date | string
    ruleVersion?: string
    minCreatedAt?: Date | string
    maxCreatedAt?: Date | string
    minArchivedAt?: Date | string
    maxArchivedAt?: Date | string
    skip?: number
    take?: number
  }) {
    const where: Prisma.BehaviorEventArchiveWhereInput = {
      AND: [
        params.q ? {
          OR: [
            { userId: { contains: params.q } },
            { targetId: { contains: params.q } },
            { ruleVersion: { contains: params.q } }
          ]
        } : {},
        params.userId ? { userId: params.userId } : {},
        params.eventType ? { eventType: params.eventType } : {},
        params.targetType ? { targetType: params.targetType } : {},
        params.targetId ? { targetId: params.targetId } : {},
        params.minProcessedAt ? { processedAt: { gte: params.minProcessedAt } } : {},
        params.maxProcessedAt ? { processedAt: { lte: params.maxProcessedAt } } : {},
        params.ruleVersion ? { ruleVersion: params.ruleVersion } : {},
        params.minCreatedAt ? { createdAt: { gte: params.minCreatedAt } } : {},
        params.maxCreatedAt ? { createdAt: { lte: params.maxCreatedAt } } : {},
        params.minArchivedAt ? { archivedAt: { gte: params.minArchivedAt } } : {},
        params.maxArchivedAt ? { archivedAt: { lte: params.maxArchivedAt } } : {}
      ].filter(condition => Object.keys(condition).length > 0)
    }
    
    return prisma.behaviorEventArchive.findMany({
      where,
      skip: params.skip || 0,
      take: Math.min(params.take || 20, 100)
    })
  }
}
